[
    {
        "label": "setup_path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "setup_path",
        "description": "setup_path",
        "detail": "setup_path",
        "documentation": {}
    },
    {
        "label": "airsim",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "airsim",
        "description": "airsim",
        "detail": "airsim",
        "documentation": {}
    },
    {
        "label": "Vector3r",
        "importPath": "airsim",
        "description": "airsim",
        "isExtraImport": true,
        "detail": "airsim",
        "documentation": {}
    },
    {
        "label": "Quaternionr",
        "importPath": "airsim",
        "description": "airsim",
        "isExtraImport": true,
        "detail": "airsim",
        "documentation": {}
    },
    {
        "label": "Pose",
        "importPath": "airsim",
        "description": "airsim",
        "isExtraImport": true,
        "detail": "airsim",
        "documentation": {}
    },
    {
        "label": "MultirotorClient",
        "importPath": "airsim",
        "description": "airsim",
        "isExtraImport": true,
        "detail": "airsim",
        "documentation": {}
    },
    {
        "label": "Vector3r",
        "importPath": "airsim",
        "description": "airsim",
        "isExtraImport": true,
        "detail": "airsim",
        "documentation": {}
    },
    {
        "label": "MultirotorClient",
        "importPath": "airsim",
        "description": "airsim",
        "isExtraImport": true,
        "detail": "airsim",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "sleep",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "sleep",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "Value",
        "importPath": "cntk.core",
        "description": "cntk.core",
        "isExtraImport": true,
        "detail": "cntk.core",
        "documentation": {}
    },
    {
        "label": "he_uniform",
        "importPath": "cntk.initializer",
        "description": "cntk.initializer",
        "isExtraImport": true,
        "detail": "cntk.initializer",
        "documentation": {}
    },
    {
        "label": "Sequential",
        "importPath": "cntk.layers",
        "description": "cntk.layers",
        "isExtraImport": true,
        "detail": "cntk.layers",
        "documentation": {}
    },
    {
        "label": "Convolution2D",
        "importPath": "cntk.layers",
        "description": "cntk.layers",
        "isExtraImport": true,
        "detail": "cntk.layers",
        "documentation": {}
    },
    {
        "label": "Dense",
        "importPath": "cntk.layers",
        "description": "cntk.layers",
        "isExtraImport": true,
        "detail": "cntk.layers",
        "documentation": {}
    },
    {
        "label": "default_options",
        "importPath": "cntk.layers",
        "description": "cntk.layers",
        "isExtraImport": true,
        "detail": "cntk.layers",
        "documentation": {}
    },
    {
        "label": "Signature",
        "importPath": "cntk.layers.typing",
        "description": "cntk.layers.typing",
        "isExtraImport": true,
        "detail": "cntk.layers.typing",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "cntk.layers.typing",
        "description": "cntk.layers.typing",
        "isExtraImport": true,
        "detail": "cntk.layers.typing",
        "documentation": {}
    },
    {
        "label": "adam",
        "importPath": "cntk.learners",
        "description": "cntk.learners",
        "isExtraImport": true,
        "detail": "cntk.learners",
        "documentation": {}
    },
    {
        "label": "learning_rate_schedule",
        "importPath": "cntk.learners",
        "description": "cntk.learners",
        "isExtraImport": true,
        "detail": "cntk.learners",
        "documentation": {}
    },
    {
        "label": "momentum_schedule",
        "importPath": "cntk.learners",
        "description": "cntk.learners",
        "isExtraImport": true,
        "detail": "cntk.learners",
        "documentation": {}
    },
    {
        "label": "UnitType",
        "importPath": "cntk.learners",
        "description": "cntk.learners",
        "isExtraImport": true,
        "detail": "cntk.learners",
        "documentation": {}
    },
    {
        "label": "TensorBoardProgressWriter",
        "importPath": "cntk.logging",
        "description": "cntk.logging",
        "isExtraImport": true,
        "detail": "cntk.logging",
        "documentation": {}
    },
    {
        "label": "abs",
        "importPath": "cntk.ops",
        "description": "cntk.ops",
        "isExtraImport": true,
        "detail": "cntk.ops",
        "documentation": {}
    },
    {
        "label": "argmax",
        "importPath": "cntk.ops",
        "description": "cntk.ops",
        "isExtraImport": true,
        "detail": "cntk.ops",
        "documentation": {}
    },
    {
        "label": "element_select",
        "importPath": "cntk.ops",
        "description": "cntk.ops",
        "isExtraImport": true,
        "detail": "cntk.ops",
        "documentation": {}
    },
    {
        "label": "less",
        "importPath": "cntk.ops",
        "description": "cntk.ops",
        "isExtraImport": true,
        "detail": "cntk.ops",
        "documentation": {}
    },
    {
        "label": "relu",
        "importPath": "cntk.ops",
        "description": "cntk.ops",
        "isExtraImport": true,
        "detail": "cntk.ops",
        "documentation": {}
    },
    {
        "label": "reduce_max",
        "importPath": "cntk.ops",
        "description": "cntk.ops",
        "isExtraImport": true,
        "detail": "cntk.ops",
        "documentation": {}
    },
    {
        "label": "reduce_sum",
        "importPath": "cntk.ops",
        "description": "cntk.ops",
        "isExtraImport": true,
        "detail": "cntk.ops",
        "documentation": {}
    },
    {
        "label": "square",
        "importPath": "cntk.ops",
        "description": "cntk.ops",
        "isExtraImport": true,
        "detail": "cntk.ops",
        "documentation": {}
    },
    {
        "label": "CloneMethod",
        "importPath": "cntk.ops.functions",
        "description": "cntk.ops.functions",
        "isExtraImport": true,
        "detail": "cntk.ops.functions",
        "documentation": {}
    },
    {
        "label": "Function",
        "importPath": "cntk.ops.functions",
        "description": "cntk.ops.functions",
        "isExtraImport": true,
        "detail": "cntk.ops.functions",
        "documentation": {}
    },
    {
        "label": "Trainer",
        "importPath": "cntk.train",
        "description": "cntk.train",
        "isExtraImport": true,
        "detail": "cntk.train",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "pprint",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pprint",
        "description": "pprint",
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "O_EXCL",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "cv2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cv2",
        "description": "cv2",
        "detail": "cv2",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "rospy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "rospy",
        "description": "rospy",
        "detail": "rospy",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "sensor_msgs.msg",
        "description": "sensor_msgs.msg",
        "isExtraImport": true,
        "detail": "sensor_msgs.msg",
        "documentation": {}
    },
    {
        "label": "CameraInfo",
        "importPath": "sensor_msgs.msg",
        "description": "sensor_msgs.msg",
        "isExtraImport": true,
        "detail": "sensor_msgs.msg",
        "documentation": {}
    },
    {
        "label": "TFMessage",
        "importPath": "tf2_msgs.msg",
        "description": "tf2_msgs.msg",
        "isExtraImport": true,
        "detail": "tf2_msgs.msg",
        "documentation": {}
    },
    {
        "label": "TransformStamped",
        "importPath": "geometry_msgs.msg",
        "description": "geometry_msgs.msg",
        "isExtraImport": true,
        "detail": "geometry_msgs.msg",
        "documentation": {}
    },
    {
        "label": "CvBridge",
        "importPath": "cv_bridge",
        "description": "cv_bridge",
        "isExtraImport": true,
        "detail": "cv_bridge",
        "documentation": {}
    },
    {
        "label": "to_quaternion",
        "importPath": "airsim.utils",
        "description": "airsim.utils",
        "isExtraImport": true,
        "detail": "airsim.utils",
        "documentation": {}
    },
    {
        "label": "to_eularian_angles",
        "importPath": "airsim.utils",
        "description": "airsim.utils",
        "isExtraImport": true,
        "detail": "airsim.utils",
        "documentation": {}
    },
    {
        "label": "to_quaternion",
        "importPath": "airsim.utils",
        "description": "airsim.utils",
        "isExtraImport": true,
        "detail": "airsim.utils",
        "documentation": {}
    },
    {
        "label": "to_quaternion",
        "importPath": "airsim.utils",
        "description": "airsim.utils",
        "isExtraImport": true,
        "detail": "airsim.utils",
        "documentation": {}
    },
    {
        "label": "os,sys,logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.sys.logging",
        "description": "os.sys.logging",
        "detail": "os.sys.logging",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "ImageRequest",
        "importPath": "airsim.types",
        "description": "airsim.types",
        "isExtraImport": true,
        "detail": "airsim.types",
        "documentation": {}
    },
    {
        "label": "Vector3r",
        "importPath": "airsim.types",
        "description": "airsim.types",
        "isExtraImport": true,
        "detail": "airsim.types",
        "documentation": {}
    },
    {
        "label": "Pose",
        "importPath": "airsim.types",
        "description": "airsim.types",
        "isExtraImport": true,
        "detail": "airsim.types",
        "documentation": {}
    },
    {
        "label": "Vector3r",
        "importPath": "airsim.types",
        "description": "airsim.types",
        "isExtraImport": true,
        "detail": "airsim.types",
        "documentation": {}
    },
    {
        "label": "Pose",
        "importPath": "airsim.types",
        "description": "airsim.types",
        "isExtraImport": true,
        "detail": "airsim.types",
        "documentation": {}
    },
    {
        "label": "Vector3r",
        "importPath": "airsim.types",
        "description": "airsim.types",
        "isExtraImport": true,
        "detail": "airsim.types",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "draw",
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "isExtraImport": true,
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "pylab",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pylab",
        "description": "pylab",
        "detail": "pylab",
        "documentation": {}
    },
    {
        "label": "array",
        "importPath": "pylab",
        "description": "pylab",
        "isExtraImport": true,
        "detail": "pylab",
        "documentation": {}
    },
    {
        "label": "arange",
        "importPath": "pylab",
        "description": "pylab",
        "isExtraImport": true,
        "detail": "pylab",
        "documentation": {}
    },
    {
        "label": "uint8",
        "importPath": "pylab",
        "description": "pylab",
        "isExtraImport": true,
        "detail": "pylab",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "eventlet",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "eventlet",
        "description": "eventlet",
        "detail": "eventlet",
        "documentation": {}
    },
    {
        "label": "Timeout",
        "importPath": "eventlet",
        "description": "eventlet",
        "isExtraImport": true,
        "detail": "eventlet",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "KDTree",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "KDTree",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "KDTree",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "KDTree",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "KDTree",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "KDTree",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "utils",
        "description": "utils",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "gc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gc",
        "description": "gc",
        "detail": "gc",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "scipy.interpolate",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "interp1d",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "Proj",
        "importPath": "pyproj",
        "description": "pyproj",
        "isExtraImport": true,
        "detail": "pyproj",
        "documentation": {}
    },
    {
        "label": "mul",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "gym",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gym",
        "description": "gym",
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "error",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "seeding",
        "importPath": "gym.utils",
        "description": "gym.utils",
        "isExtraImport": true,
        "detail": "gym.utils",
        "documentation": {}
    },
    {
        "label": "Qr",
        "importPath": "tensorflow.python.ops.gen_linalg_ops",
        "description": "tensorflow.python.ops.gen_linalg_ops",
        "isExtraImport": true,
        "detail": "tensorflow.python.ops.gen_linalg_ops",
        "documentation": {}
    },
    {
        "label": "MazeView2D",
        "importPath": "gym_maze.envs.maze_view_2d",
        "description": "gym_maze.envs.maze_view_2d",
        "isExtraImport": true,
        "detail": "gym_maze.envs.maze_view_2d",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "pygame",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygame",
        "description": "pygame",
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "block",
        "importPath": "numpy.core.shape_base",
        "description": "numpy.core.shape_base",
        "isExtraImport": true,
        "detail": "numpy.core.shape_base",
        "documentation": {}
    },
    {
        "label": "trajs_utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "setSeed",
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "isExtraImport": true,
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "BUFFER_SIZE",
        "importPath": "numpy.lib.format",
        "description": "numpy.lib.format",
        "isExtraImport": true,
        "detail": "numpy.lib.format",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "MazeEnv",
        "importPath": "gym_maze.envs.maze_env",
        "description": "gym_maze.envs.maze_env",
        "isExtraImport": true,
        "detail": "gym_maze.envs.maze_env",
        "documentation": {}
    },
    {
        "label": "yaml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yaml",
        "description": "yaml",
        "detail": "yaml",
        "documentation": {}
    },
    {
        "label": "matplotlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib",
        "description": "matplotlib",
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "mplot3d",
        "importPath": "mpl_toolkits",
        "description": "mpl_toolkits",
        "isExtraImport": true,
        "detail": "mpl_toolkits",
        "documentation": {}
    },
    {
        "label": "mplot3d",
        "importPath": "mpl_toolkits",
        "description": "mpl_toolkits",
        "isExtraImport": true,
        "detail": "mpl_toolkits",
        "documentation": {}
    },
    {
        "label": "mplot3d",
        "importPath": "mpl_toolkits",
        "description": "mpl_toolkits",
        "isExtraImport": true,
        "detail": "mpl_toolkits",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "NewMyAirSimClient",
        "importPath": "airsimgeo.newMyAirSimClient",
        "description": "airsimgeo.newMyAirSimClient",
        "isExtraImport": true,
        "detail": "airsimgeo.newMyAirSimClient",
        "documentation": {}
    },
    {
        "label": "NewMyAirSimClient",
        "importPath": "airsimgeo.newMyAirSimClient",
        "description": "airsimgeo.newMyAirSimClient",
        "isExtraImport": true,
        "detail": "airsimgeo.newMyAirSimClient",
        "documentation": {}
    },
    {
        "label": "QUIT",
        "importPath": "pygame.constants",
        "description": "pygame.constants",
        "isExtraImport": true,
        "detail": "pygame.constants",
        "documentation": {}
    },
    {
        "label": "poisson",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "DotMap",
        "importPath": "dotmap",
        "description": "dotmap",
        "isExtraImport": true,
        "detail": "dotmap",
        "documentation": {}
    },
    {
        "label": "ConfigParser",
        "importPath": "configparser",
        "description": "configparser",
        "isExtraImport": true,
        "detail": "configparser",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "winsound",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "winsound",
        "description": "winsound",
        "detail": "winsound",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.environment.set_wind",
        "description": "demos.demos_from_airsim.environment.set_wind",
        "peekOfCode": "client = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.enableApiControl(True)\nclient.armDisarm(True)\nprint(\"Setting wind to 10m/s in forward direction\") # NED\nwind = airsim.Vector3r(10, 0, 0)\nclient.simSetWind(wind)\n# Takeoff or hover\nlanded = client.getMultirotorState().landed_state\nif landed == airsim.LandedState.Landed:",
        "detail": "demos.demos_from_airsim.environment.set_wind",
        "documentation": {}
    },
    {
        "label": "wind",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.environment.set_wind",
        "description": "demos.demos_from_airsim.environment.set_wind",
        "peekOfCode": "wind = airsim.Vector3r(10, 0, 0)\nclient.simSetWind(wind)\n# Takeoff or hover\nlanded = client.getMultirotorState().landed_state\nif landed == airsim.LandedState.Landed:\n    print(\"taking off...\")\n    client.takeoffAsync().join()\nelse:\n    print(\"already flying...\")\n    client.hoverAsync().join()",
        "detail": "demos.demos_from_airsim.environment.set_wind",
        "documentation": {}
    },
    {
        "label": "landed",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.environment.set_wind",
        "description": "demos.demos_from_airsim.environment.set_wind",
        "peekOfCode": "landed = client.getMultirotorState().landed_state\nif landed == airsim.LandedState.Landed:\n    print(\"taking off...\")\n    client.takeoffAsync().join()\nelse:\n    print(\"already flying...\")\n    client.hoverAsync().join()\ntime.sleep(5)\nprint(\"Setting wind to 15m/s towards right\") # NED\nwind = airsim.Vector3r(0, 15, 0)",
        "detail": "demos.demos_from_airsim.environment.set_wind",
        "documentation": {}
    },
    {
        "label": "wind",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.environment.set_wind",
        "description": "demos.demos_from_airsim.environment.set_wind",
        "peekOfCode": "wind = airsim.Vector3r(0, 15, 0)\nclient.simSetWind(wind)\ntime.sleep(5)\n# Set wind to 0\nprint(\"Resetting wind to 0\")\nwind = airsim.Vector3r(0, 0, 0)\nclient.simSetWind(wind)",
        "detail": "demos.demos_from_airsim.environment.set_wind",
        "documentation": {}
    },
    {
        "label": "wind",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.environment.set_wind",
        "description": "demos.demos_from_airsim.environment.set_wind",
        "peekOfCode": "wind = airsim.Vector3r(0, 0, 0)\nclient.simSetWind(wind)",
        "detail": "demos.demos_from_airsim.environment.set_wind",
        "documentation": {}
    },
    {
        "label": "RunConsoleCmd",
        "kind": 2,
        "importPath": "demos.demos_from_airsim.environment.unreal_console_commands",
        "description": "demos.demos_from_airsim.environment.unreal_console_commands",
        "peekOfCode": "def RunConsoleCmd(client, cmd):\n    client.simRunConsoleCommand(cmd)\n    print(f\"Running Unreal Console cmd '{cmd}' and sleeping for 1 second\")\n    time.sleep(1.0)\ndef RunCmdList(client):\n    RunConsoleCmd(client, 'stat fps')\n    RunConsoleCmd(client, 'stat unit')\n    RunConsoleCmd(client, 'stat unitGraph')\n    RunConsoleCmd(client, 'show COLLISION')\n    RunConsoleCmd(client, 'show CollisionVisibility')",
        "detail": "demos.demos_from_airsim.environment.unreal_console_commands",
        "documentation": {}
    },
    {
        "label": "RunCmdList",
        "kind": 2,
        "importPath": "demos.demos_from_airsim.environment.unreal_console_commands",
        "description": "demos.demos_from_airsim.environment.unreal_console_commands",
        "peekOfCode": "def RunCmdList(client):\n    RunConsoleCmd(client, 'stat fps')\n    RunConsoleCmd(client, 'stat unit')\n    RunConsoleCmd(client, 'stat unitGraph')\n    RunConsoleCmd(client, 'show COLLISION')\n    RunConsoleCmd(client, 'show CollisionVisibility')\n    RunConsoleCmd(client, 'stat game')\n    RunConsoleCmd(client, 'show COLLISION')\n    RunConsoleCmd(client, 'show CollisionVisibility')\n    RunConsoleCmd(client, 'stat game')",
        "detail": "demos.demos_from_airsim.environment.unreal_console_commands",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "demos.demos_from_airsim.environment.unreal_console_commands",
        "description": "demos.demos_from_airsim.environment.unreal_console_commands",
        "peekOfCode": "def main():\n    client = airsim.client.MultirotorClient()\n    client.confirmConnection()\n    RunCmdList(client)\nif __name__ == \"__main__\":\n    main()",
        "detail": "demos.demos_from_airsim.environment.unreal_console_commands",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.environment.weather",
        "description": "demos.demos_from_airsim.environment.weather",
        "peekOfCode": "client = airsim.VehicleClient()\nclient.confirmConnection()\nclient.simEnableWeather(True)\nairsim.wait_key('Press any key to enable rain at 25%')\nclient.simSetWeatherParameter(airsim.WeatherParameter.Rain, 0.25);\nairsim.wait_key('Press any key to enable rain at 75%')\nclient.simSetWeatherParameter(airsim.WeatherParameter.Rain, 0.75);\nairsim.wait_key('Press any key to enable snow at 50%')\nclient.simSetWeatherParameter(airsim.WeatherParameter.Snow, 0.50);\nairsim.wait_key('Press any key to enable maple leaves at 50%')",
        "detail": "demos.demos_from_airsim.environment.weather",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.arm",
        "description": "demos.demos_from_airsim.multirotor.arm",
        "peekOfCode": "client = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.armDisarm(True)",
        "detail": "demos.demos_from_airsim.multirotor.arm",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.box",
        "description": "demos.demos_from_airsim.multirotor.box",
        "peekOfCode": "client = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.enableApiControl(True)\nclient.armDisarm(True)\nclient.takeoffAsync().join()\nprint(\"Flying a small square box using moveByVelocityZ\")\n# AirSim uses NED coordinates so negative axis is up.\n# z of -7 is 7 meters above the original launch point.\nz = -7\n# Fly given velocity vector for 5 seconds",
        "detail": "demos.demos_from_airsim.multirotor.box",
        "documentation": {}
    },
    {
        "label": "z",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.box",
        "description": "demos.demos_from_airsim.multirotor.box",
        "peekOfCode": "z = -7\n# Fly given velocity vector for 5 seconds\nduration = 5\nspeed = 1\ndelay = duration * speed\n# using airsim.DrivetrainType.MaxDegreeOfFreedom means we can control the drone yaw independently\n# from the direction the drone is flying.  I've set values here that make the drone always point inwards\n# towards the inside of the box (which would be handy if you are building a 3d scan of an object in the real world).\nvx = speed\nvy = 0",
        "detail": "demos.demos_from_airsim.multirotor.box",
        "documentation": {}
    },
    {
        "label": "duration",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.box",
        "description": "demos.demos_from_airsim.multirotor.box",
        "peekOfCode": "duration = 5\nspeed = 1\ndelay = duration * speed\n# using airsim.DrivetrainType.MaxDegreeOfFreedom means we can control the drone yaw independently\n# from the direction the drone is flying.  I've set values here that make the drone always point inwards\n# towards the inside of the box (which would be handy if you are building a 3d scan of an object in the real world).\nvx = speed\nvy = 0\nprint(\"moving by velocity vx=\" + str(vx) + \", vy=\" + str(vy) + \", yaw=90\")\nclient.moveByVelocityZAsync(vx,vy,z,duration, airsim.DrivetrainType.MaxDegreeOfFreedom, airsim.YawMode(False, 90)).join()",
        "detail": "demos.demos_from_airsim.multirotor.box",
        "documentation": {}
    },
    {
        "label": "speed",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.box",
        "description": "demos.demos_from_airsim.multirotor.box",
        "peekOfCode": "speed = 1\ndelay = duration * speed\n# using airsim.DrivetrainType.MaxDegreeOfFreedom means we can control the drone yaw independently\n# from the direction the drone is flying.  I've set values here that make the drone always point inwards\n# towards the inside of the box (which would be handy if you are building a 3d scan of an object in the real world).\nvx = speed\nvy = 0\nprint(\"moving by velocity vx=\" + str(vx) + \", vy=\" + str(vy) + \", yaw=90\")\nclient.moveByVelocityZAsync(vx,vy,z,duration, airsim.DrivetrainType.MaxDegreeOfFreedom, airsim.YawMode(False, 90)).join()\ntime.sleep(delay)",
        "detail": "demos.demos_from_airsim.multirotor.box",
        "documentation": {}
    },
    {
        "label": "delay",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.box",
        "description": "demos.demos_from_airsim.multirotor.box",
        "peekOfCode": "delay = duration * speed\n# using airsim.DrivetrainType.MaxDegreeOfFreedom means we can control the drone yaw independently\n# from the direction the drone is flying.  I've set values here that make the drone always point inwards\n# towards the inside of the box (which would be handy if you are building a 3d scan of an object in the real world).\nvx = speed\nvy = 0\nprint(\"moving by velocity vx=\" + str(vx) + \", vy=\" + str(vy) + \", yaw=90\")\nclient.moveByVelocityZAsync(vx,vy,z,duration, airsim.DrivetrainType.MaxDegreeOfFreedom, airsim.YawMode(False, 90)).join()\ntime.sleep(delay)\nvx = 0",
        "detail": "demos.demos_from_airsim.multirotor.box",
        "documentation": {}
    },
    {
        "label": "vx",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.box",
        "description": "demos.demos_from_airsim.multirotor.box",
        "peekOfCode": "vx = speed\nvy = 0\nprint(\"moving by velocity vx=\" + str(vx) + \", vy=\" + str(vy) + \", yaw=90\")\nclient.moveByVelocityZAsync(vx,vy,z,duration, airsim.DrivetrainType.MaxDegreeOfFreedom, airsim.YawMode(False, 90)).join()\ntime.sleep(delay)\nvx = 0\nvy = speed\nprint(\"moving by velocity vx=\" + str(vx) + \", vy=\" + str(vy)+ \", yaw=180\")\nclient.moveByVelocityZAsync(vx,vy,z,duration, airsim.DrivetrainType.MaxDegreeOfFreedom, airsim.YawMode(False, 180)).join()\ntime.sleep(delay)",
        "detail": "demos.demos_from_airsim.multirotor.box",
        "documentation": {}
    },
    {
        "label": "vy",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.box",
        "description": "demos.demos_from_airsim.multirotor.box",
        "peekOfCode": "vy = 0\nprint(\"moving by velocity vx=\" + str(vx) + \", vy=\" + str(vy) + \", yaw=90\")\nclient.moveByVelocityZAsync(vx,vy,z,duration, airsim.DrivetrainType.MaxDegreeOfFreedom, airsim.YawMode(False, 90)).join()\ntime.sleep(delay)\nvx = 0\nvy = speed\nprint(\"moving by velocity vx=\" + str(vx) + \", vy=\" + str(vy)+ \", yaw=180\")\nclient.moveByVelocityZAsync(vx,vy,z,duration, airsim.DrivetrainType.MaxDegreeOfFreedom, airsim.YawMode(False, 180)).join()\ntime.sleep(delay)\nvx = -speed",
        "detail": "demos.demos_from_airsim.multirotor.box",
        "documentation": {}
    },
    {
        "label": "vx",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.box",
        "description": "demos.demos_from_airsim.multirotor.box",
        "peekOfCode": "vx = 0\nvy = speed\nprint(\"moving by velocity vx=\" + str(vx) + \", vy=\" + str(vy)+ \", yaw=180\")\nclient.moveByVelocityZAsync(vx,vy,z,duration, airsim.DrivetrainType.MaxDegreeOfFreedom, airsim.YawMode(False, 180)).join()\ntime.sleep(delay)\nvx = -speed\nvy = 0\nprint(\"moving by velocity vx=\" + str(vx) + \", vy=\" + str(vy)+ \", yaw=270\")\nclient.moveByVelocityZAsync(vx, vy, z,duration, airsim.DrivetrainType.MaxDegreeOfFreedom, airsim.YawMode(False, 270)).join()\ntime.sleep(delay)",
        "detail": "demos.demos_from_airsim.multirotor.box",
        "documentation": {}
    },
    {
        "label": "vy",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.box",
        "description": "demos.demos_from_airsim.multirotor.box",
        "peekOfCode": "vy = speed\nprint(\"moving by velocity vx=\" + str(vx) + \", vy=\" + str(vy)+ \", yaw=180\")\nclient.moveByVelocityZAsync(vx,vy,z,duration, airsim.DrivetrainType.MaxDegreeOfFreedom, airsim.YawMode(False, 180)).join()\ntime.sleep(delay)\nvx = -speed\nvy = 0\nprint(\"moving by velocity vx=\" + str(vx) + \", vy=\" + str(vy)+ \", yaw=270\")\nclient.moveByVelocityZAsync(vx, vy, z,duration, airsim.DrivetrainType.MaxDegreeOfFreedom, airsim.YawMode(False, 270)).join()\ntime.sleep(delay)\nvx = 0",
        "detail": "demos.demos_from_airsim.multirotor.box",
        "documentation": {}
    },
    {
        "label": "vx",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.box",
        "description": "demos.demos_from_airsim.multirotor.box",
        "peekOfCode": "vx = -speed\nvy = 0\nprint(\"moving by velocity vx=\" + str(vx) + \", vy=\" + str(vy)+ \", yaw=270\")\nclient.moveByVelocityZAsync(vx, vy, z,duration, airsim.DrivetrainType.MaxDegreeOfFreedom, airsim.YawMode(False, 270)).join()\ntime.sleep(delay)\nvx = 0\nvy = -speed\nprint(\"moving by velocity vx=\" + str(vx) + \", vy=\" + str(vy) + \", yaw=0\")\nclient.moveByVelocityZAsync(vx, vy,z,duration, airsim.DrivetrainType.MaxDegreeOfFreedom, airsim.YawMode(False, 0)).join()\ntime.sleep(delay)",
        "detail": "demos.demos_from_airsim.multirotor.box",
        "documentation": {}
    },
    {
        "label": "vy",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.box",
        "description": "demos.demos_from_airsim.multirotor.box",
        "peekOfCode": "vy = 0\nprint(\"moving by velocity vx=\" + str(vx) + \", vy=\" + str(vy)+ \", yaw=270\")\nclient.moveByVelocityZAsync(vx, vy, z,duration, airsim.DrivetrainType.MaxDegreeOfFreedom, airsim.YawMode(False, 270)).join()\ntime.sleep(delay)\nvx = 0\nvy = -speed\nprint(\"moving by velocity vx=\" + str(vx) + \", vy=\" + str(vy) + \", yaw=0\")\nclient.moveByVelocityZAsync(vx, vy,z,duration, airsim.DrivetrainType.MaxDegreeOfFreedom, airsim.YawMode(False, 0)).join()\ntime.sleep(delay)\nclient.hoverAsync().join()",
        "detail": "demos.demos_from_airsim.multirotor.box",
        "documentation": {}
    },
    {
        "label": "vx",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.box",
        "description": "demos.demos_from_airsim.multirotor.box",
        "peekOfCode": "vx = 0\nvy = -speed\nprint(\"moving by velocity vx=\" + str(vx) + \", vy=\" + str(vy) + \", yaw=0\")\nclient.moveByVelocityZAsync(vx, vy,z,duration, airsim.DrivetrainType.MaxDegreeOfFreedom, airsim.YawMode(False, 0)).join()\ntime.sleep(delay)\nclient.hoverAsync().join()\nclient.landAsync().join()",
        "detail": "demos.demos_from_airsim.multirotor.box",
        "documentation": {}
    },
    {
        "label": "vy",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.box",
        "description": "demos.demos_from_airsim.multirotor.box",
        "peekOfCode": "vy = -speed\nprint(\"moving by velocity vx=\" + str(vx) + \", vy=\" + str(vy) + \", yaw=0\")\nclient.moveByVelocityZAsync(vx, vy,z,duration, airsim.DrivetrainType.MaxDegreeOfFreedom, airsim.YawMode(False, 0)).join()\ntime.sleep(delay)\nclient.hoverAsync().join()\nclient.landAsync().join()",
        "detail": "demos.demos_from_airsim.multirotor.box",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.clock_speed",
        "description": "demos.demos_from_airsim.multirotor.clock_speed",
        "peekOfCode": "client = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.enableApiControl(True)\nclient.armDisarm(True)\nclient.moveByVelocityZAsync(0, 0, -20, 3).join()\nwhile True:\n    client.moveByVelocityZAsync(5, 5, -2, 1).join()\n    time.sleep(10)\nclient.armDisarm(False)\nclient.reset()",
        "detail": "demos.demos_from_airsim.multirotor.clock_speed",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.disarm",
        "description": "demos.demos_from_airsim.multirotor.disarm",
        "peekOfCode": "client = airsim.MultirotorClient()\nclient.armDisarm(False)",
        "detail": "demos.demos_from_airsim.multirotor.disarm",
        "documentation": {}
    },
    {
        "label": "ReplayMemory",
        "kind": 6,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "class ReplayMemory(object):\n    \"\"\"\n    ReplayMemory keeps track of the environment dynamic.\n    We store all the transitions (s(t), action, s(t+1), reward, done).\n    The replay memory allows us to efficiently sample mini-batches from it, and generate the correct state representation\n    (w.r.t the number of previous frames needed).\n    \"\"\"\n    def __init__(self, size, sample_shape, history_length=4):\n        self._pos = 0\n        self._count = 0",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "History",
        "kind": 6,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "class History(object):\n    \"\"\"\n    Accumulator keeping track of the N previous frames to be used by the agent\n    for evaluation\n    \"\"\"\n    def __init__(self, shape):\n        self._buffer = np.zeros(shape, dtype=np.float32)\n    @property\n    def value(self):\n        \"\"\" Underlying buffer with N previous states stacked along first axis",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "LinearEpsilonAnnealingExplorer",
        "kind": 6,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "class LinearEpsilonAnnealingExplorer(object):\n    \"\"\"\n    Exploration policy using Linear Epsilon Greedy\n    Attributes:\n        start (float): start value\n        end (float): end value\n        steps (int): number of steps between start and end\n    \"\"\"\n    def __init__(self, start, end, steps):\n        self._start = start",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "DeepQAgent",
        "kind": 6,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "class DeepQAgent(object):\n    \"\"\"\n    Implementation of Deep Q Neural Network agent like in:\n        Nature 518. \"Human-level control through deep reinforcement learning\" (Mnih & al. 2015)\n    \"\"\"\n    def __init__(self, input_shape, nb_actions,\n                 gamma=0.99, explorer=LinearEpsilonAnnealingExplorer(1, 0.1, 1000000),\n                 learning_rate=0.00025, momentum=0.95, minibatch_size=32,\n                 memory_size=500000, train_after=10000, train_interval=4, target_update_interval=10000,\n                 monitor=True):",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "huber_loss",
        "kind": 2,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "def huber_loss(y, y_hat, delta):\n    \"\"\" Compute the Huber Loss as part of the model graph\n    Huber Loss is more robust to outliers. It is defined as:\n     if |y - y_hat| < delta :\n        0.5 * (y - y_hat)**2\n    else :\n        delta * |y - y_hat| - 0.5 * delta**2\n    Attributes:\n        y (Tensor[-1, 1]): Target value\n        y_hat(Tensor[-1, 1]): Estimated value",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "transform_input",
        "kind": 2,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "def transform_input(responses):\n    img1d = np.array(responses[0].image_data_float, dtype=np.float)\n    img1d = 255/np.maximum(np.ones(img1d.size), img1d)\n    img2d = np.reshape(img1d, (responses[0].height, responses[0].width))\n    from PIL import Image\n    image = Image.fromarray(img2d)\n    im_final = np.array(image.resize((84, 84)).convert('L')) \n    return im_final\ndef interpret_action(action):\n    scaling_factor = 0.25",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "interpret_action",
        "kind": 2,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "def interpret_action(action):\n    scaling_factor = 0.25\n    if action == 0:\n        quad_offset = (0, 0, 0)\n    elif action == 1:\n        quad_offset = (scaling_factor, 0, 0)\n    elif action == 2:\n        quad_offset = (0, scaling_factor, 0)\n    elif action == 3:\n        quad_offset = (0, 0, scaling_factor)",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "compute_reward",
        "kind": 2,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "def compute_reward(quad_state, quad_vel, collision_info):\n    thresh_dist = 7\n    beta = 1\n    z = -10\n    pts = [np.array([-.55265, -31.9786, -19.0225]), np.array([48.59735, -63.3286, -60.07256]), np.array([193.5974, -55.0786, -46.32256]), np.array([369.2474, 35.32137, -62.5725]), np.array([541.3474, 143.6714, -32.07256])]\n    quad_pt = np.array(list((quad_state.x_val, quad_state.y_val, quad_state.z_val)))\n    if collision_info.has_collided:\n        reward = -100\n    else:    \n        dist = 10000000",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "isDone",
        "kind": 2,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "def isDone(reward):\n    done = 0\n    if  reward <= -10:\n        done = 1\n    return done\ninitX = -.55265\ninitY = -31.9786\ninitZ = -19.0225\n# connect to the AirSim simulator \nclient = airsim.MultirotorClient()",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "initX",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "initX = -.55265\ninitY = -31.9786\ninitZ = -19.0225\n# connect to the AirSim simulator \nclient = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.enableApiControl(True)\nclient.armDisarm(True)\nclient.takeoffAsync().join()\nclient.moveToPositionAsync(initX, initY, initZ, 5).join()",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "initY",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "initY = -31.9786\ninitZ = -19.0225\n# connect to the AirSim simulator \nclient = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.enableApiControl(True)\nclient.armDisarm(True)\nclient.takeoffAsync().join()\nclient.moveToPositionAsync(initX, initY, initZ, 5).join()\nclient.moveByVelocityAsync(1, -0.67, -0.8, 5).join()",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "initZ",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "initZ = -19.0225\n# connect to the AirSim simulator \nclient = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.enableApiControl(True)\nclient.armDisarm(True)\nclient.takeoffAsync().join()\nclient.moveToPositionAsync(initX, initY, initZ, 5).join()\nclient.moveByVelocityAsync(1, -0.67, -0.8, 5).join()\ntime.sleep(0.5)",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "client = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.enableApiControl(True)\nclient.armDisarm(True)\nclient.takeoffAsync().join()\nclient.moveToPositionAsync(initX, initY, initZ, 5).join()\nclient.moveByVelocityAsync(1, -0.67, -0.8, 5).join()\ntime.sleep(0.5)\n# Make RL agent\nNumBufferFrames = 4",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "NumBufferFrames",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "NumBufferFrames = 4\nSizeRows = 84\nSizeCols = 84\nNumActions = 7\nagent = DeepQAgent((NumBufferFrames, SizeRows, SizeCols), NumActions, monitor=True)\n# Train\nepoch = 100\ncurrent_step = 0\nmax_steps = epoch * 250000\nresponses = client.simGetImages([airsim.ImageRequest(3, airsim.ImageType.DepthPerspective, True, False)])",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "SizeRows",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "SizeRows = 84\nSizeCols = 84\nNumActions = 7\nagent = DeepQAgent((NumBufferFrames, SizeRows, SizeCols), NumActions, monitor=True)\n# Train\nepoch = 100\ncurrent_step = 0\nmax_steps = epoch * 250000\nresponses = client.simGetImages([airsim.ImageRequest(3, airsim.ImageType.DepthPerspective, True, False)])\ncurrent_state = transform_input(responses)",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "SizeCols",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "SizeCols = 84\nNumActions = 7\nagent = DeepQAgent((NumBufferFrames, SizeRows, SizeCols), NumActions, monitor=True)\n# Train\nepoch = 100\ncurrent_step = 0\nmax_steps = epoch * 250000\nresponses = client.simGetImages([airsim.ImageRequest(3, airsim.ImageType.DepthPerspective, True, False)])\ncurrent_state = transform_input(responses)\nwhile True:",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "NumActions",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "NumActions = 7\nagent = DeepQAgent((NumBufferFrames, SizeRows, SizeCols), NumActions, monitor=True)\n# Train\nepoch = 100\ncurrent_step = 0\nmax_steps = epoch * 250000\nresponses = client.simGetImages([airsim.ImageRequest(3, airsim.ImageType.DepthPerspective, True, False)])\ncurrent_state = transform_input(responses)\nwhile True:\n    action = agent.act(current_state)",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "agent",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "agent = DeepQAgent((NumBufferFrames, SizeRows, SizeCols), NumActions, monitor=True)\n# Train\nepoch = 100\ncurrent_step = 0\nmax_steps = epoch * 250000\nresponses = client.simGetImages([airsim.ImageRequest(3, airsim.ImageType.DepthPerspective, True, False)])\ncurrent_state = transform_input(responses)\nwhile True:\n    action = agent.act(current_state)\n    quad_offset = interpret_action(action)",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "epoch",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "epoch = 100\ncurrent_step = 0\nmax_steps = epoch * 250000\nresponses = client.simGetImages([airsim.ImageRequest(3, airsim.ImageType.DepthPerspective, True, False)])\ncurrent_state = transform_input(responses)\nwhile True:\n    action = agent.act(current_state)\n    quad_offset = interpret_action(action)\n    quad_vel = client.getMultirotorState().kinematics_estimated.linear_velocity\n    client.moveByVelocityAsync(quad_vel.x_val+quad_offset[0], quad_vel.y_val+quad_offset[1], quad_vel.z_val+quad_offset[2], 5).join()",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "current_step",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "current_step = 0\nmax_steps = epoch * 250000\nresponses = client.simGetImages([airsim.ImageRequest(3, airsim.ImageType.DepthPerspective, True, False)])\ncurrent_state = transform_input(responses)\nwhile True:\n    action = agent.act(current_state)\n    quad_offset = interpret_action(action)\n    quad_vel = client.getMultirotorState().kinematics_estimated.linear_velocity\n    client.moveByVelocityAsync(quad_vel.x_val+quad_offset[0], quad_vel.y_val+quad_offset[1], quad_vel.z_val+quad_offset[2], 5).join()\n    time.sleep(0.5)",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "max_steps",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "max_steps = epoch * 250000\nresponses = client.simGetImages([airsim.ImageRequest(3, airsim.ImageType.DepthPerspective, True, False)])\ncurrent_state = transform_input(responses)\nwhile True:\n    action = agent.act(current_state)\n    quad_offset = interpret_action(action)\n    quad_vel = client.getMultirotorState().kinematics_estimated.linear_velocity\n    client.moveByVelocityAsync(quad_vel.x_val+quad_offset[0], quad_vel.y_val+quad_offset[1], quad_vel.z_val+quad_offset[2], 5).join()\n    time.sleep(0.5)\n    quad_state = client.getMultirotorState().kinematics_estimated.position",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "responses",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "responses = client.simGetImages([airsim.ImageRequest(3, airsim.ImageType.DepthPerspective, True, False)])\ncurrent_state = transform_input(responses)\nwhile True:\n    action = agent.act(current_state)\n    quad_offset = interpret_action(action)\n    quad_vel = client.getMultirotorState().kinematics_estimated.linear_velocity\n    client.moveByVelocityAsync(quad_vel.x_val+quad_offset[0], quad_vel.y_val+quad_offset[1], quad_vel.z_val+quad_offset[2], 5).join()\n    time.sleep(0.5)\n    quad_state = client.getMultirotorState().kinematics_estimated.position\n    quad_vel = client.getMultirotorState().kinematics_estimated.linear_velocity",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "current_state",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.DQNdrone",
        "description": "demos.demos_from_airsim.multirotor.DQNdrone",
        "peekOfCode": "current_state = transform_input(responses)\nwhile True:\n    action = agent.act(current_state)\n    quad_offset = interpret_action(action)\n    quad_vel = client.getMultirotorState().kinematics_estimated.linear_velocity\n    client.moveByVelocityAsync(quad_vel.x_val+quad_offset[0], quad_vel.y_val+quad_offset[1], quad_vel.z_val+quad_offset[2], 5).join()\n    time.sleep(0.5)\n    quad_state = client.getMultirotorState().kinematics_estimated.position\n    quad_vel = client.getMultirotorState().kinematics_estimated.linear_velocity\n    collision_info = client.simGetCollisionInfo()",
        "detail": "demos.demos_from_airsim.multirotor.DQNdrone",
        "documentation": {}
    },
    {
        "label": "LidarTest",
        "kind": 6,
        "importPath": "demos.demos_from_airsim.multirotor.drone_lidar",
        "description": "demos.demos_from_airsim.multirotor.drone_lidar",
        "peekOfCode": "class LidarTest:\n    def __init__(self):\n        # connect to the AirSim simulator\n        self.client = airsim.MultirotorClient()\n        self.client.confirmConnection()\n        self.client.enableApiControl(True)\n    def execute(self):\n        print(\"arming the drone...\")\n        self.client.armDisarm(True)\n        state = self.client.getMultirotorState()",
        "detail": "demos.demos_from_airsim.multirotor.drone_lidar",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.drone_stress_test",
        "description": "demos.demos_from_airsim.multirotor.drone_stress_test",
        "peekOfCode": "client = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.enableApiControl(True)\nclient.armDisarm(True)\nfor idx in range(3000):\n    client.moveToPositionAsync(0, 0, -10, 5).join()\n    client.reset()\n    client.enableApiControl(True)\n    print(\"%d\" % idx)\n# that's enough fun for now. let's quite cleanly",
        "detail": "demos.demos_from_airsim.multirotor.drone_stress_test",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.gimbal",
        "description": "demos.demos_from_airsim.multirotor.gimbal",
        "peekOfCode": "client = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.enableApiControl(True)\nclient.armDisarm(True)\n# MultirotorClient.wait_key('Press any key to takeoff')\nprint(\"Taking off\")\nclient.takeoffAsync().join()\nprint(\"Ready\")\nfor i in range(5):\n    client.moveToPositionAsync(float(-50.00), float( 50.26), float( -20.58), float( 3.5))",
        "detail": "demos.demos_from_airsim.multirotor.gimbal",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.hello_drone",
        "description": "demos.demos_from_airsim.multirotor.hello_drone",
        "peekOfCode": "client = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.enableApiControl(True)\nclient.armDisarm(True)\nstate = client.getMultirotorState()\ns = pprint.pformat(state)\nprint(\"state: %s\" % s)\nimu_data = client.getImuData()\ns = pprint.pformat(imu_data)\nprint(\"imu_data: %s\" % s)",
        "detail": "demos.demos_from_airsim.multirotor.hello_drone",
        "documentation": {}
    },
    {
        "label": "state",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.hello_drone",
        "description": "demos.demos_from_airsim.multirotor.hello_drone",
        "peekOfCode": "state = client.getMultirotorState()\ns = pprint.pformat(state)\nprint(\"state: %s\" % s)\nimu_data = client.getImuData()\ns = pprint.pformat(imu_data)\nprint(\"imu_data: %s\" % s)\nbarometer_data = client.getBarometerData()\ns = pprint.pformat(barometer_data)\nprint(\"barometer_data: %s\" % s)\nmagnetometer_data = client.getMagnetometerData()",
        "detail": "demos.demos_from_airsim.multirotor.hello_drone",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.hello_drone",
        "description": "demos.demos_from_airsim.multirotor.hello_drone",
        "peekOfCode": "s = pprint.pformat(state)\nprint(\"state: %s\" % s)\nimu_data = client.getImuData()\ns = pprint.pformat(imu_data)\nprint(\"imu_data: %s\" % s)\nbarometer_data = client.getBarometerData()\ns = pprint.pformat(barometer_data)\nprint(\"barometer_data: %s\" % s)\nmagnetometer_data = client.getMagnetometerData()\ns = pprint.pformat(magnetometer_data)",
        "detail": "demos.demos_from_airsim.multirotor.hello_drone",
        "documentation": {}
    },
    {
        "label": "imu_data",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.hello_drone",
        "description": "demos.demos_from_airsim.multirotor.hello_drone",
        "peekOfCode": "imu_data = client.getImuData()\ns = pprint.pformat(imu_data)\nprint(\"imu_data: %s\" % s)\nbarometer_data = client.getBarometerData()\ns = pprint.pformat(barometer_data)\nprint(\"barometer_data: %s\" % s)\nmagnetometer_data = client.getMagnetometerData()\ns = pprint.pformat(magnetometer_data)\nprint(\"magnetometer_data: %s\" % s)\ngps_data = client.getGpsData()",
        "detail": "demos.demos_from_airsim.multirotor.hello_drone",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.hello_drone",
        "description": "demos.demos_from_airsim.multirotor.hello_drone",
        "peekOfCode": "s = pprint.pformat(imu_data)\nprint(\"imu_data: %s\" % s)\nbarometer_data = client.getBarometerData()\ns = pprint.pformat(barometer_data)\nprint(\"barometer_data: %s\" % s)\nmagnetometer_data = client.getMagnetometerData()\ns = pprint.pformat(magnetometer_data)\nprint(\"magnetometer_data: %s\" % s)\ngps_data = client.getGpsData()\ns = pprint.pformat(gps_data)",
        "detail": "demos.demos_from_airsim.multirotor.hello_drone",
        "documentation": {}
    },
    {
        "label": "barometer_data",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.hello_drone",
        "description": "demos.demos_from_airsim.multirotor.hello_drone",
        "peekOfCode": "barometer_data = client.getBarometerData()\ns = pprint.pformat(barometer_data)\nprint(\"barometer_data: %s\" % s)\nmagnetometer_data = client.getMagnetometerData()\ns = pprint.pformat(magnetometer_data)\nprint(\"magnetometer_data: %s\" % s)\ngps_data = client.getGpsData()\ns = pprint.pformat(gps_data)\nprint(\"gps_data: %s\" % s)\nairsim.wait_key('Press any key to takeoff')",
        "detail": "demos.demos_from_airsim.multirotor.hello_drone",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.hello_drone",
        "description": "demos.demos_from_airsim.multirotor.hello_drone",
        "peekOfCode": "s = pprint.pformat(barometer_data)\nprint(\"barometer_data: %s\" % s)\nmagnetometer_data = client.getMagnetometerData()\ns = pprint.pformat(magnetometer_data)\nprint(\"magnetometer_data: %s\" % s)\ngps_data = client.getGpsData()\ns = pprint.pformat(gps_data)\nprint(\"gps_data: %s\" % s)\nairsim.wait_key('Press any key to takeoff')\nclient.takeoffAsync().join()",
        "detail": "demos.demos_from_airsim.multirotor.hello_drone",
        "documentation": {}
    },
    {
        "label": "magnetometer_data",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.hello_drone",
        "description": "demos.demos_from_airsim.multirotor.hello_drone",
        "peekOfCode": "magnetometer_data = client.getMagnetometerData()\ns = pprint.pformat(magnetometer_data)\nprint(\"magnetometer_data: %s\" % s)\ngps_data = client.getGpsData()\ns = pprint.pformat(gps_data)\nprint(\"gps_data: %s\" % s)\nairsim.wait_key('Press any key to takeoff')\nclient.takeoffAsync().join()\nstate = client.getMultirotorState()\nprint(\"state: %s\" % pprint.pformat(state))",
        "detail": "demos.demos_from_airsim.multirotor.hello_drone",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.hello_drone",
        "description": "demos.demos_from_airsim.multirotor.hello_drone",
        "peekOfCode": "s = pprint.pformat(magnetometer_data)\nprint(\"magnetometer_data: %s\" % s)\ngps_data = client.getGpsData()\ns = pprint.pformat(gps_data)\nprint(\"gps_data: %s\" % s)\nairsim.wait_key('Press any key to takeoff')\nclient.takeoffAsync().join()\nstate = client.getMultirotorState()\nprint(\"state: %s\" % pprint.pformat(state))\nairsim.wait_key('Press any key to move vehicle to (-10, 10, -10) at 5 m/s')",
        "detail": "demos.demos_from_airsim.multirotor.hello_drone",
        "documentation": {}
    },
    {
        "label": "gps_data",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.hello_drone",
        "description": "demos.demos_from_airsim.multirotor.hello_drone",
        "peekOfCode": "gps_data = client.getGpsData()\ns = pprint.pformat(gps_data)\nprint(\"gps_data: %s\" % s)\nairsim.wait_key('Press any key to takeoff')\nclient.takeoffAsync().join()\nstate = client.getMultirotorState()\nprint(\"state: %s\" % pprint.pformat(state))\nairsim.wait_key('Press any key to move vehicle to (-10, 10, -10) at 5 m/s')\nclient.moveToPositionAsync(-10, 10, -10, 5).join()\nclient.hoverAsync().join()",
        "detail": "demos.demos_from_airsim.multirotor.hello_drone",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.hello_drone",
        "description": "demos.demos_from_airsim.multirotor.hello_drone",
        "peekOfCode": "s = pprint.pformat(gps_data)\nprint(\"gps_data: %s\" % s)\nairsim.wait_key('Press any key to takeoff')\nclient.takeoffAsync().join()\nstate = client.getMultirotorState()\nprint(\"state: %s\" % pprint.pformat(state))\nairsim.wait_key('Press any key to move vehicle to (-10, 10, -10) at 5 m/s')\nclient.moveToPositionAsync(-10, 10, -10, 5).join()\nclient.hoverAsync().join()\nstate = client.getMultirotorState()",
        "detail": "demos.demos_from_airsim.multirotor.hello_drone",
        "documentation": {}
    },
    {
        "label": "state",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.hello_drone",
        "description": "demos.demos_from_airsim.multirotor.hello_drone",
        "peekOfCode": "state = client.getMultirotorState()\nprint(\"state: %s\" % pprint.pformat(state))\nairsim.wait_key('Press any key to move vehicle to (-10, 10, -10) at 5 m/s')\nclient.moveToPositionAsync(-10, 10, -10, 5).join()\nclient.hoverAsync().join()\nstate = client.getMultirotorState()\nprint(\"state: %s\" % pprint.pformat(state))\nairsim.wait_key('Press any key to take images')\n# get camera images from the car\nresponses = client.simGetImages([",
        "detail": "demos.demos_from_airsim.multirotor.hello_drone",
        "documentation": {}
    },
    {
        "label": "state",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.hello_drone",
        "description": "demos.demos_from_airsim.multirotor.hello_drone",
        "peekOfCode": "state = client.getMultirotorState()\nprint(\"state: %s\" % pprint.pformat(state))\nairsim.wait_key('Press any key to take images')\n# get camera images from the car\nresponses = client.simGetImages([\n    airsim.ImageRequest(\"0\", airsim.ImageType.DepthVis),  #depth visualization image\n    airsim.ImageRequest(\"1\", airsim.ImageType.DepthPerspective, True), #depth in perspective projection\n    airsim.ImageRequest(\"1\", airsim.ImageType.Scene), #scene vision image in png format\n    airsim.ImageRequest(\"1\", airsim.ImageType.Scene, False, False)])  #scene vision image in uncompressed RGBA array\nprint('Retrieved images: %d' % len(responses))",
        "detail": "demos.demos_from_airsim.multirotor.hello_drone",
        "documentation": {}
    },
    {
        "label": "responses",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.hello_drone",
        "description": "demos.demos_from_airsim.multirotor.hello_drone",
        "peekOfCode": "responses = client.simGetImages([\n    airsim.ImageRequest(\"0\", airsim.ImageType.DepthVis),  #depth visualization image\n    airsim.ImageRequest(\"1\", airsim.ImageType.DepthPerspective, True), #depth in perspective projection\n    airsim.ImageRequest(\"1\", airsim.ImageType.Scene), #scene vision image in png format\n    airsim.ImageRequest(\"1\", airsim.ImageType.Scene, False, False)])  #scene vision image in uncompressed RGBA array\nprint('Retrieved images: %d' % len(responses))\ntmp_dir = os.path.join(tempfile.gettempdir(), \"airsim_drone\")\nprint (\"Saving images to %s\" % tmp_dir)\ntry:\n    os.makedirs(tmp_dir)",
        "detail": "demos.demos_from_airsim.multirotor.hello_drone",
        "documentation": {}
    },
    {
        "label": "tmp_dir",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.hello_drone",
        "description": "demos.demos_from_airsim.multirotor.hello_drone",
        "peekOfCode": "tmp_dir = os.path.join(tempfile.gettempdir(), \"airsim_drone\")\nprint (\"Saving images to %s\" % tmp_dir)\ntry:\n    os.makedirs(tmp_dir)\nexcept OSError:\n    if not os.path.isdir(tmp_dir):\n        raise\nfor idx, response in enumerate(responses):\n    filename = os.path.join(tmp_dir, str(idx))\n    if response.pixels_as_float:",
        "detail": "demos.demos_from_airsim.multirotor.hello_drone",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.high_res_camera",
        "description": "demos.demos_from_airsim.multirotor.high_res_camera",
        "peekOfCode": "client = airsim.VehicleClient()\nclient.confirmConnection()\nframecounter = 1\nprevtimestamp = datetime.now()\nwhile(framecounter <= 500):\n    if framecounter%150 == 0:\n        client.simGetImages([airsim.ImageRequest(\"high_res\", airsim.ImageType.Scene, False, False)])\n        print(\"High resolution image captured.\")\n    if framecounter%30 == 0:\n        now = datetime.now()",
        "detail": "demos.demos_from_airsim.multirotor.high_res_camera",
        "documentation": {}
    },
    {
        "label": "framecounter",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.high_res_camera",
        "description": "demos.demos_from_airsim.multirotor.high_res_camera",
        "peekOfCode": "framecounter = 1\nprevtimestamp = datetime.now()\nwhile(framecounter <= 500):\n    if framecounter%150 == 0:\n        client.simGetImages([airsim.ImageRequest(\"high_res\", airsim.ImageType.Scene, False, False)])\n        print(\"High resolution image captured.\")\n    if framecounter%30 == 0:\n        now = datetime.now()\n        print(f\"Time spent for 30 frames: {now-prevtimestamp}\")\n        prevtimestamp = now",
        "detail": "demos.demos_from_airsim.multirotor.high_res_camera",
        "documentation": {}
    },
    {
        "label": "prevtimestamp",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.high_res_camera",
        "description": "demos.demos_from_airsim.multirotor.high_res_camera",
        "peekOfCode": "prevtimestamp = datetime.now()\nwhile(framecounter <= 500):\n    if framecounter%150 == 0:\n        client.simGetImages([airsim.ImageRequest(\"high_res\", airsim.ImageType.Scene, False, False)])\n        print(\"High resolution image captured.\")\n    if framecounter%30 == 0:\n        now = datetime.now()\n        print(f\"Time spent for 30 frames: {now-prevtimestamp}\")\n        prevtimestamp = now\n    client.simGetImages([airsim.ImageRequest(\"low_res\", airsim.ImageType.Scene, False, False)])",
        "detail": "demos.demos_from_airsim.multirotor.high_res_camera",
        "documentation": {}
    },
    {
        "label": "KinectPublisher",
        "kind": 6,
        "importPath": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "description": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "peekOfCode": "class KinectPublisher:\n    def __init__(self):\n        self.bridge_rgb = CvBridge()\n        self.msg_rgb = Image()\n        self.bridge_d = CvBridge()\n        self.msg_d = Image()\n        self.msg_info = CameraInfo()\n        self.msg_tf = TFMessage()\n    def getDepthImage(self,response_d):\n        img_depth = np.array(response_d.image_data_float, dtype=np.float32)",
        "detail": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "documentation": {}
    },
    {
        "label": "CLAHE_ENABLED",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "description": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "peekOfCode": "CLAHE_ENABLED = False  # when enabled, RGB image is enhanced using CLAHE\nCAMERA_FX = 320\nCAMERA_FY = 320\nCAMERA_CX = 320\nCAMERA_CY = 240\nCAMERA_K1 = -0.000591\nCAMERA_K2 = 0.000519\nCAMERA_P1 = 0.000001\nCAMERA_P2 = -0.000030\nCAMERA_P3 = 0.0",
        "detail": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "documentation": {}
    },
    {
        "label": "CAMERA_FX",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "description": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "peekOfCode": "CAMERA_FX = 320\nCAMERA_FY = 320\nCAMERA_CX = 320\nCAMERA_CY = 240\nCAMERA_K1 = -0.000591\nCAMERA_K2 = 0.000519\nCAMERA_P1 = 0.000001\nCAMERA_P2 = -0.000030\nCAMERA_P3 = 0.0\nIMAGE_WIDTH = 640  # resolution should match values in settings.json",
        "detail": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "documentation": {}
    },
    {
        "label": "CAMERA_FY",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "description": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "peekOfCode": "CAMERA_FY = 320\nCAMERA_CX = 320\nCAMERA_CY = 240\nCAMERA_K1 = -0.000591\nCAMERA_K2 = 0.000519\nCAMERA_P1 = 0.000001\nCAMERA_P2 = -0.000030\nCAMERA_P3 = 0.0\nIMAGE_WIDTH = 640  # resolution should match values in settings.json\nIMAGE_HEIGHT = 480",
        "detail": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "documentation": {}
    },
    {
        "label": "CAMERA_CX",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "description": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "peekOfCode": "CAMERA_CX = 320\nCAMERA_CY = 240\nCAMERA_K1 = -0.000591\nCAMERA_K2 = 0.000519\nCAMERA_P1 = 0.000001\nCAMERA_P2 = -0.000030\nCAMERA_P3 = 0.0\nIMAGE_WIDTH = 640  # resolution should match values in settings.json\nIMAGE_HEIGHT = 480\nclass KinectPublisher:",
        "detail": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "documentation": {}
    },
    {
        "label": "CAMERA_CY",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "description": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "peekOfCode": "CAMERA_CY = 240\nCAMERA_K1 = -0.000591\nCAMERA_K2 = 0.000519\nCAMERA_P1 = 0.000001\nCAMERA_P2 = -0.000030\nCAMERA_P3 = 0.0\nIMAGE_WIDTH = 640  # resolution should match values in settings.json\nIMAGE_HEIGHT = 480\nclass KinectPublisher:\n    def __init__(self):",
        "detail": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "documentation": {}
    },
    {
        "label": "CAMERA_K1",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "description": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "peekOfCode": "CAMERA_K1 = -0.000591\nCAMERA_K2 = 0.000519\nCAMERA_P1 = 0.000001\nCAMERA_P2 = -0.000030\nCAMERA_P3 = 0.0\nIMAGE_WIDTH = 640  # resolution should match values in settings.json\nIMAGE_HEIGHT = 480\nclass KinectPublisher:\n    def __init__(self):\n        self.bridge_rgb = CvBridge()",
        "detail": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "documentation": {}
    },
    {
        "label": "CAMERA_K2",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "description": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "peekOfCode": "CAMERA_K2 = 0.000519\nCAMERA_P1 = 0.000001\nCAMERA_P2 = -0.000030\nCAMERA_P3 = 0.0\nIMAGE_WIDTH = 640  # resolution should match values in settings.json\nIMAGE_HEIGHT = 480\nclass KinectPublisher:\n    def __init__(self):\n        self.bridge_rgb = CvBridge()\n        self.msg_rgb = Image()",
        "detail": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "documentation": {}
    },
    {
        "label": "CAMERA_P1",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "description": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "peekOfCode": "CAMERA_P1 = 0.000001\nCAMERA_P2 = -0.000030\nCAMERA_P3 = 0.0\nIMAGE_WIDTH = 640  # resolution should match values in settings.json\nIMAGE_HEIGHT = 480\nclass KinectPublisher:\n    def __init__(self):\n        self.bridge_rgb = CvBridge()\n        self.msg_rgb = Image()\n        self.bridge_d = CvBridge()",
        "detail": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "documentation": {}
    },
    {
        "label": "CAMERA_P2",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "description": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "peekOfCode": "CAMERA_P2 = -0.000030\nCAMERA_P3 = 0.0\nIMAGE_WIDTH = 640  # resolution should match values in settings.json\nIMAGE_HEIGHT = 480\nclass KinectPublisher:\n    def __init__(self):\n        self.bridge_rgb = CvBridge()\n        self.msg_rgb = Image()\n        self.bridge_d = CvBridge()\n        self.msg_d = Image()",
        "detail": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "documentation": {}
    },
    {
        "label": "CAMERA_P3",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "description": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "peekOfCode": "CAMERA_P3 = 0.0\nIMAGE_WIDTH = 640  # resolution should match values in settings.json\nIMAGE_HEIGHT = 480\nclass KinectPublisher:\n    def __init__(self):\n        self.bridge_rgb = CvBridge()\n        self.msg_rgb = Image()\n        self.bridge_d = CvBridge()\n        self.msg_d = Image()\n        self.msg_info = CameraInfo()",
        "detail": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "documentation": {}
    },
    {
        "label": "IMAGE_WIDTH",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "description": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "peekOfCode": "IMAGE_WIDTH = 640  # resolution should match values in settings.json\nIMAGE_HEIGHT = 480\nclass KinectPublisher:\n    def __init__(self):\n        self.bridge_rgb = CvBridge()\n        self.msg_rgb = Image()\n        self.bridge_d = CvBridge()\n        self.msg_d = Image()\n        self.msg_info = CameraInfo()\n        self.msg_tf = TFMessage()",
        "detail": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "documentation": {}
    },
    {
        "label": "IMAGE_HEIGHT",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "description": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "peekOfCode": "IMAGE_HEIGHT = 480\nclass KinectPublisher:\n    def __init__(self):\n        self.bridge_rgb = CvBridge()\n        self.msg_rgb = Image()\n        self.bridge_d = CvBridge()\n        self.msg_d = Image()\n        self.msg_info = CameraInfo()\n        self.msg_tf = TFMessage()\n    def getDepthImage(self,response_d):",
        "detail": "demos.demos_from_airsim.multirotor.kinect_publisher",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.land",
        "description": "demos.demos_from_airsim.multirotor.land",
        "peekOfCode": "client = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.enableApiControl(True)\nclient.armDisarm(True)\nlanded = client.getMultirotorState().landed_state\nif landed == airsim.LandedState.Landed:\n    print(\"already landed...\")\nelse:\n    print(\"landing...\")\n    client.landAsync().join()",
        "detail": "demos.demos_from_airsim.multirotor.land",
        "documentation": {}
    },
    {
        "label": "landed",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.land",
        "description": "demos.demos_from_airsim.multirotor.land",
        "peekOfCode": "landed = client.getMultirotorState().landed_state\nif landed == airsim.LandedState.Landed:\n    print(\"already landed...\")\nelse:\n    print(\"landing...\")\n    client.landAsync().join()\nclient.armDisarm(False)\nclient.enableApiControl(False)",
        "detail": "demos.demos_from_airsim.multirotor.land",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.manual_mode_demo",
        "description": "demos.demos_from_airsim.multirotor.manual_mode_demo",
        "peekOfCode": "client = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.enableApiControl(True)\nclient.armDisarm(True)\nstate = client.getMultirotorState()\ns = pprint.pformat(state)\nprint(\"state: %s\" % s)\nclient.moveByManualAsync(vx_max = 1E6, vy_max = 1E6, z_min = -1E6, duration = 1E10)\nairsim.wait_key('Manual mode is setup. Press any key to send RC data to takeoff')\nclient.moveByRC(rcdata = airsim.RCData(pitch = 0.0, throttle = 1.0, is_initialized = True, is_valid = True))",
        "detail": "demos.demos_from_airsim.multirotor.manual_mode_demo",
        "documentation": {}
    },
    {
        "label": "state",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.manual_mode_demo",
        "description": "demos.demos_from_airsim.multirotor.manual_mode_demo",
        "peekOfCode": "state = client.getMultirotorState()\ns = pprint.pformat(state)\nprint(\"state: %s\" % s)\nclient.moveByManualAsync(vx_max = 1E6, vy_max = 1E6, z_min = -1E6, duration = 1E10)\nairsim.wait_key('Manual mode is setup. Press any key to send RC data to takeoff')\nclient.moveByRC(rcdata = airsim.RCData(pitch = 0.0, throttle = 1.0, is_initialized = True, is_valid = True))\nairsim.wait_key('Set Yaw and pitch to 0.5')\nclient.moveByRC(rcdata = airsim.RCData(roll = 0.5, throttle = 1.0, yaw = 0.5, is_initialized = True, is_valid = True))",
        "detail": "demos.demos_from_airsim.multirotor.manual_mode_demo",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.manual_mode_demo",
        "description": "demos.demos_from_airsim.multirotor.manual_mode_demo",
        "peekOfCode": "s = pprint.pformat(state)\nprint(\"state: %s\" % s)\nclient.moveByManualAsync(vx_max = 1E6, vy_max = 1E6, z_min = -1E6, duration = 1E10)\nairsim.wait_key('Manual mode is setup. Press any key to send RC data to takeoff')\nclient.moveByRC(rcdata = airsim.RCData(pitch = 0.0, throttle = 1.0, is_initialized = True, is_valid = True))\nairsim.wait_key('Set Yaw and pitch to 0.5')\nclient.moveByRC(rcdata = airsim.RCData(roll = 0.5, throttle = 1.0, yaw = 0.5, is_initialized = True, is_valid = True))",
        "detail": "demos.demos_from_airsim.multirotor.manual_mode_demo",
        "documentation": {}
    },
    {
        "label": "client.moveByManualAsync(vx_max",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.manual_mode_demo",
        "description": "demos.demos_from_airsim.multirotor.manual_mode_demo",
        "peekOfCode": "client.moveByManualAsync(vx_max = 1E6, vy_max = 1E6, z_min = -1E6, duration = 1E10)\nairsim.wait_key('Manual mode is setup. Press any key to send RC data to takeoff')\nclient.moveByRC(rcdata = airsim.RCData(pitch = 0.0, throttle = 1.0, is_initialized = True, is_valid = True))\nairsim.wait_key('Set Yaw and pitch to 0.5')\nclient.moveByRC(rcdata = airsim.RCData(roll = 0.5, throttle = 1.0, yaw = 0.5, is_initialized = True, is_valid = True))",
        "detail": "demos.demos_from_airsim.multirotor.manual_mode_demo",
        "documentation": {}
    },
    {
        "label": "client.moveByRC(rcdata",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.manual_mode_demo",
        "description": "demos.demos_from_airsim.multirotor.manual_mode_demo",
        "peekOfCode": "client.moveByRC(rcdata = airsim.RCData(pitch = 0.0, throttle = 1.0, is_initialized = True, is_valid = True))\nairsim.wait_key('Set Yaw and pitch to 0.5')\nclient.moveByRC(rcdata = airsim.RCData(roll = 0.5, throttle = 1.0, yaw = 0.5, is_initialized = True, is_valid = True))",
        "detail": "demos.demos_from_airsim.multirotor.manual_mode_demo",
        "documentation": {}
    },
    {
        "label": "client.moveByRC(rcdata",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.manual_mode_demo",
        "description": "demos.demos_from_airsim.multirotor.manual_mode_demo",
        "peekOfCode": "client.moveByRC(rcdata = airsim.RCData(roll = 0.5, throttle = 1.0, yaw = 0.5, is_initialized = True, is_valid = True))",
        "detail": "demos.demos_from_airsim.multirotor.manual_mode_demo",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "description": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "peekOfCode": "client = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.enableApiControl(True, \"Drone1\")\nclient.enableApiControl(True, \"Drone2\")\nclient.armDisarm(True, \"Drone1\")\nclient.armDisarm(True, \"Drone2\")\nairsim.wait_key('Press any key to takeoff')\nf1 = client.takeoffAsync(vehicle_name=\"Drone1\")\nf2 = client.takeoffAsync(vehicle_name=\"Drone2\")\nf1.join()",
        "detail": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "documentation": {}
    },
    {
        "label": "f1",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "description": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "peekOfCode": "f1 = client.takeoffAsync(vehicle_name=\"Drone1\")\nf2 = client.takeoffAsync(vehicle_name=\"Drone2\")\nf1.join()\nf2.join()\nstate1 = client.getMultirotorState(vehicle_name=\"Drone1\")\ns = pprint.pformat(state1)\nprint(\"state: %s\" % s)\nstate2 = client.getMultirotorState(vehicle_name=\"Drone2\")\ns = pprint.pformat(state2)\nprint(\"state: %s\" % s)",
        "detail": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "documentation": {}
    },
    {
        "label": "f2",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "description": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "peekOfCode": "f2 = client.takeoffAsync(vehicle_name=\"Drone2\")\nf1.join()\nf2.join()\nstate1 = client.getMultirotorState(vehicle_name=\"Drone1\")\ns = pprint.pformat(state1)\nprint(\"state: %s\" % s)\nstate2 = client.getMultirotorState(vehicle_name=\"Drone2\")\ns = pprint.pformat(state2)\nprint(\"state: %s\" % s)\nairsim.wait_key('Press any key to move vehicles')",
        "detail": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "documentation": {}
    },
    {
        "label": "state1",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "description": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "peekOfCode": "state1 = client.getMultirotorState(vehicle_name=\"Drone1\")\ns = pprint.pformat(state1)\nprint(\"state: %s\" % s)\nstate2 = client.getMultirotorState(vehicle_name=\"Drone2\")\ns = pprint.pformat(state2)\nprint(\"state: %s\" % s)\nairsim.wait_key('Press any key to move vehicles')\nf1 = client.moveToPositionAsync(-5, 5, -10, 5, vehicle_name=\"Drone1\")\nf2 = client.moveToPositionAsync(5, -5, -10, 5, vehicle_name=\"Drone2\")\nf1.join()",
        "detail": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "description": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "peekOfCode": "s = pprint.pformat(state1)\nprint(\"state: %s\" % s)\nstate2 = client.getMultirotorState(vehicle_name=\"Drone2\")\ns = pprint.pformat(state2)\nprint(\"state: %s\" % s)\nairsim.wait_key('Press any key to move vehicles')\nf1 = client.moveToPositionAsync(-5, 5, -10, 5, vehicle_name=\"Drone1\")\nf2 = client.moveToPositionAsync(5, -5, -10, 5, vehicle_name=\"Drone2\")\nf1.join()\nf2.join()",
        "detail": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "documentation": {}
    },
    {
        "label": "state2",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "description": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "peekOfCode": "state2 = client.getMultirotorState(vehicle_name=\"Drone2\")\ns = pprint.pformat(state2)\nprint(\"state: %s\" % s)\nairsim.wait_key('Press any key to move vehicles')\nf1 = client.moveToPositionAsync(-5, 5, -10, 5, vehicle_name=\"Drone1\")\nf2 = client.moveToPositionAsync(5, -5, -10, 5, vehicle_name=\"Drone2\")\nf1.join()\nf2.join()\nairsim.wait_key('Press any key to take images')\n# get camera images from the car",
        "detail": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "description": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "peekOfCode": "s = pprint.pformat(state2)\nprint(\"state: %s\" % s)\nairsim.wait_key('Press any key to move vehicles')\nf1 = client.moveToPositionAsync(-5, 5, -10, 5, vehicle_name=\"Drone1\")\nf2 = client.moveToPositionAsync(5, -5, -10, 5, vehicle_name=\"Drone2\")\nf1.join()\nf2.join()\nairsim.wait_key('Press any key to take images')\n# get camera images from the car\nresponses1 = client.simGetImages([",
        "detail": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "documentation": {}
    },
    {
        "label": "f1",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "description": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "peekOfCode": "f1 = client.moveToPositionAsync(-5, 5, -10, 5, vehicle_name=\"Drone1\")\nf2 = client.moveToPositionAsync(5, -5, -10, 5, vehicle_name=\"Drone2\")\nf1.join()\nf2.join()\nairsim.wait_key('Press any key to take images')\n# get camera images from the car\nresponses1 = client.simGetImages([\n    airsim.ImageRequest(\"0\", airsim.ImageType.DepthVis),  #depth visualization image\n    airsim.ImageRequest(\"1\", airsim.ImageType.Scene, False, False)], vehicle_name=\"Drone1\")  #scene vision image in uncompressed RGB array\nprint('Drone1: Retrieved images: %d' % len(responses1))",
        "detail": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "documentation": {}
    },
    {
        "label": "f2",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "description": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "peekOfCode": "f2 = client.moveToPositionAsync(5, -5, -10, 5, vehicle_name=\"Drone2\")\nf1.join()\nf2.join()\nairsim.wait_key('Press any key to take images')\n# get camera images from the car\nresponses1 = client.simGetImages([\n    airsim.ImageRequest(\"0\", airsim.ImageType.DepthVis),  #depth visualization image\n    airsim.ImageRequest(\"1\", airsim.ImageType.Scene, False, False)], vehicle_name=\"Drone1\")  #scene vision image in uncompressed RGB array\nprint('Drone1: Retrieved images: %d' % len(responses1))\nresponses2 = client.simGetImages([",
        "detail": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "documentation": {}
    },
    {
        "label": "responses1",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "description": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "peekOfCode": "responses1 = client.simGetImages([\n    airsim.ImageRequest(\"0\", airsim.ImageType.DepthVis),  #depth visualization image\n    airsim.ImageRequest(\"1\", airsim.ImageType.Scene, False, False)], vehicle_name=\"Drone1\")  #scene vision image in uncompressed RGB array\nprint('Drone1: Retrieved images: %d' % len(responses1))\nresponses2 = client.simGetImages([\n    airsim.ImageRequest(\"0\", airsim.ImageType.DepthVis),  #depth visualization image\n    airsim.ImageRequest(\"1\", airsim.ImageType.Scene, False, False)], vehicle_name=\"Drone2\")  #scene vision image in uncompressed RGB array\nprint('Drone2: Retrieved images: %d' % len(responses2))\ntmp_dir = os.path.join(tempfile.gettempdir(), \"airsim_drone\")\nprint (\"Saving images to %s\" % tmp_dir)",
        "detail": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "documentation": {}
    },
    {
        "label": "responses2",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "description": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "peekOfCode": "responses2 = client.simGetImages([\n    airsim.ImageRequest(\"0\", airsim.ImageType.DepthVis),  #depth visualization image\n    airsim.ImageRequest(\"1\", airsim.ImageType.Scene, False, False)], vehicle_name=\"Drone2\")  #scene vision image in uncompressed RGB array\nprint('Drone2: Retrieved images: %d' % len(responses2))\ntmp_dir = os.path.join(tempfile.gettempdir(), \"airsim_drone\")\nprint (\"Saving images to %s\" % tmp_dir)\ntry:\n    os.makedirs(tmp_dir)\nexcept OSError:\n    if not os.path.isdir(tmp_dir):",
        "detail": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "documentation": {}
    },
    {
        "label": "tmp_dir",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "description": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "peekOfCode": "tmp_dir = os.path.join(tempfile.gettempdir(), \"airsim_drone\")\nprint (\"Saving images to %s\" % tmp_dir)\ntry:\n    os.makedirs(tmp_dir)\nexcept OSError:\n    if not os.path.isdir(tmp_dir):\n        raise\nfor idx, response in enumerate(responses1 + responses2):\n    filename = os.path.join(tmp_dir, str(idx))\n    if response.pixels_as_float:",
        "detail": "demos.demos_from_airsim.multirotor.multi_agent_drone",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.navigate",
        "description": "demos.demos_from_airsim.multirotor.navigate",
        "peekOfCode": "client = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.enableApiControl(True)\nclient.armDisarm(True)\nclient.takeoffAsync().join()\n# you must first press \"1\" in the AirSim view to turn on the depth capture\n# get depth image\nyaw = 0\npi = 3.14159265483\nvx = 0",
        "detail": "demos.demos_from_airsim.multirotor.navigate",
        "documentation": {}
    },
    {
        "label": "yaw",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.navigate",
        "description": "demos.demos_from_airsim.multirotor.navigate",
        "peekOfCode": "yaw = 0\npi = 3.14159265483\nvx = 0\nvy = 0\ndriving = 0\nhelp = False\nwhile True:\n    # this will return png width= 256, height= 144\n    result = client.simGetImage(\"0\", airsim.ImageType.DepthVis)\n    if (result == \"\\0\"):",
        "detail": "demos.demos_from_airsim.multirotor.navigate",
        "documentation": {}
    },
    {
        "label": "pi",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.navigate",
        "description": "demos.demos_from_airsim.multirotor.navigate",
        "peekOfCode": "pi = 3.14159265483\nvx = 0\nvy = 0\ndriving = 0\nhelp = False\nwhile True:\n    # this will return png width= 256, height= 144\n    result = client.simGetImage(\"0\", airsim.ImageType.DepthVis)\n    if (result == \"\\0\"):\n        if (not help):",
        "detail": "demos.demos_from_airsim.multirotor.navigate",
        "documentation": {}
    },
    {
        "label": "vx",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.navigate",
        "description": "demos.demos_from_airsim.multirotor.navigate",
        "peekOfCode": "vx = 0\nvy = 0\ndriving = 0\nhelp = False\nwhile True:\n    # this will return png width= 256, height= 144\n    result = client.simGetImage(\"0\", airsim.ImageType.DepthVis)\n    if (result == \"\\0\"):\n        if (not help):\n            help = True",
        "detail": "demos.demos_from_airsim.multirotor.navigate",
        "documentation": {}
    },
    {
        "label": "vy",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.navigate",
        "description": "demos.demos_from_airsim.multirotor.navigate",
        "peekOfCode": "vy = 0\ndriving = 0\nhelp = False\nwhile True:\n    # this will return png width= 256, height= 144\n    result = client.simGetImage(\"0\", airsim.ImageType.DepthVis)\n    if (result == \"\\0\"):\n        if (not help):\n            help = True\n            print(\"Please press '1' in the AirSim view to enable the Depth camera view\")",
        "detail": "demos.demos_from_airsim.multirotor.navigate",
        "documentation": {}
    },
    {
        "label": "driving",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.navigate",
        "description": "demos.demos_from_airsim.multirotor.navigate",
        "peekOfCode": "driving = 0\nhelp = False\nwhile True:\n    # this will return png width= 256, height= 144\n    result = client.simGetImage(\"0\", airsim.ImageType.DepthVis)\n    if (result == \"\\0\"):\n        if (not help):\n            help = True\n            print(\"Please press '1' in the AirSim view to enable the Depth camera view\")\n    else:    ",
        "detail": "demos.demos_from_airsim.multirotor.navigate",
        "documentation": {}
    },
    {
        "label": "help",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.navigate",
        "description": "demos.demos_from_airsim.multirotor.navigate",
        "peekOfCode": "help = False\nwhile True:\n    # this will return png width= 256, height= 144\n    result = client.simGetImage(\"0\", airsim.ImageType.DepthVis)\n    if (result == \"\\0\"):\n        if (not help):\n            help = True\n            print(\"Please press '1' in the AirSim view to enable the Depth camera view\")\n    else:    \n        rawImage = np.fromstring(result, np.int8)",
        "detail": "demos.demos_from_airsim.multirotor.navigate",
        "documentation": {}
    },
    {
        "label": "printUsage",
        "kind": 2,
        "importPath": "demos.demos_from_airsim.multirotor.opencv_show",
        "description": "demos.demos_from_airsim.multirotor.opencv_show",
        "peekOfCode": "def printUsage():\n   print(\"Usage: python camera.py [depth|segmentation|scene]\")\ncameraType = \"depth\"\nfor arg in sys.argv[1:]:\n  cameraType = arg.lower()\ncameraTypeMap = { \n \"depth\": airsim.ImageType.DepthVis,\n \"segmentation\": airsim.ImageType.Segmentation,\n \"seg\": airsim.ImageType.Segmentation,\n \"scene\": airsim.ImageType.Scene,",
        "detail": "demos.demos_from_airsim.multirotor.opencv_show",
        "documentation": {}
    },
    {
        "label": "cameraType",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.opencv_show",
        "description": "demos.demos_from_airsim.multirotor.opencv_show",
        "peekOfCode": "cameraType = \"depth\"\nfor arg in sys.argv[1:]:\n  cameraType = arg.lower()\ncameraTypeMap = { \n \"depth\": airsim.ImageType.DepthVis,\n \"segmentation\": airsim.ImageType.Segmentation,\n \"seg\": airsim.ImageType.Segmentation,\n \"scene\": airsim.ImageType.Scene,\n \"disparity\": airsim.ImageType.DisparityNormalized,\n \"normals\": airsim.ImageType.SurfaceNormals",
        "detail": "demos.demos_from_airsim.multirotor.opencv_show",
        "documentation": {}
    },
    {
        "label": "cameraTypeMap",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.opencv_show",
        "description": "demos.demos_from_airsim.multirotor.opencv_show",
        "peekOfCode": "cameraTypeMap = { \n \"depth\": airsim.ImageType.DepthVis,\n \"segmentation\": airsim.ImageType.Segmentation,\n \"seg\": airsim.ImageType.Segmentation,\n \"scene\": airsim.ImageType.Scene,\n \"disparity\": airsim.ImageType.DisparityNormalized,\n \"normals\": airsim.ImageType.SurfaceNormals\n}\nif (not cameraType in cameraTypeMap):\n  printUsage()",
        "detail": "demos.demos_from_airsim.multirotor.opencv_show",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.opencv_show",
        "description": "demos.demos_from_airsim.multirotor.opencv_show",
        "peekOfCode": "client = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.enableApiControl(True)\nclient.armDisarm(True)\nclient.takeoffAsync().join()\nhelp = False\nfontFace = cv2.FONT_HERSHEY_SIMPLEX\nfontScale = 0.5\nthickness = 2\ntextSize, baseline = cv2.getTextSize(\"FPS\", fontFace, fontScale, thickness)",
        "detail": "demos.demos_from_airsim.multirotor.opencv_show",
        "documentation": {}
    },
    {
        "label": "help",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.opencv_show",
        "description": "demos.demos_from_airsim.multirotor.opencv_show",
        "peekOfCode": "help = False\nfontFace = cv2.FONT_HERSHEY_SIMPLEX\nfontScale = 0.5\nthickness = 2\ntextSize, baseline = cv2.getTextSize(\"FPS\", fontFace, fontScale, thickness)\nprint (textSize)\ntextOrg = (10, 10 + textSize[1])\nframeCount = 0\nstartTime=time.clock()\nfps = 0",
        "detail": "demos.demos_from_airsim.multirotor.opencv_show",
        "documentation": {}
    },
    {
        "label": "fontFace",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.opencv_show",
        "description": "demos.demos_from_airsim.multirotor.opencv_show",
        "peekOfCode": "fontFace = cv2.FONT_HERSHEY_SIMPLEX\nfontScale = 0.5\nthickness = 2\ntextSize, baseline = cv2.getTextSize(\"FPS\", fontFace, fontScale, thickness)\nprint (textSize)\ntextOrg = (10, 10 + textSize[1])\nframeCount = 0\nstartTime=time.clock()\nfps = 0\nwhile True:",
        "detail": "demos.demos_from_airsim.multirotor.opencv_show",
        "documentation": {}
    },
    {
        "label": "fontScale",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.opencv_show",
        "description": "demos.demos_from_airsim.multirotor.opencv_show",
        "peekOfCode": "fontScale = 0.5\nthickness = 2\ntextSize, baseline = cv2.getTextSize(\"FPS\", fontFace, fontScale, thickness)\nprint (textSize)\ntextOrg = (10, 10 + textSize[1])\nframeCount = 0\nstartTime=time.clock()\nfps = 0\nwhile True:\n    # because this method returns std::vector<uint8>, msgpack decides to encode it as a string unfortunately.",
        "detail": "demos.demos_from_airsim.multirotor.opencv_show",
        "documentation": {}
    },
    {
        "label": "thickness",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.opencv_show",
        "description": "demos.demos_from_airsim.multirotor.opencv_show",
        "peekOfCode": "thickness = 2\ntextSize, baseline = cv2.getTextSize(\"FPS\", fontFace, fontScale, thickness)\nprint (textSize)\ntextOrg = (10, 10 + textSize[1])\nframeCount = 0\nstartTime=time.clock()\nfps = 0\nwhile True:\n    # because this method returns std::vector<uint8>, msgpack decides to encode it as a string unfortunately.\n    rawImage = client.simGetImage(\"0\", cameraTypeMap[cameraType])",
        "detail": "demos.demos_from_airsim.multirotor.opencv_show",
        "documentation": {}
    },
    {
        "label": "textOrg",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.opencv_show",
        "description": "demos.demos_from_airsim.multirotor.opencv_show",
        "peekOfCode": "textOrg = (10, 10 + textSize[1])\nframeCount = 0\nstartTime=time.clock()\nfps = 0\nwhile True:\n    # because this method returns std::vector<uint8>, msgpack decides to encode it as a string unfortunately.\n    rawImage = client.simGetImage(\"0\", cameraTypeMap[cameraType])\n    if (rawImage == None):\n        print(\"Camera is not returning image, please check airsim for error messages\")\n        sys.exit(0)",
        "detail": "demos.demos_from_airsim.multirotor.opencv_show",
        "documentation": {}
    },
    {
        "label": "frameCount",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.opencv_show",
        "description": "demos.demos_from_airsim.multirotor.opencv_show",
        "peekOfCode": "frameCount = 0\nstartTime=time.clock()\nfps = 0\nwhile True:\n    # because this method returns std::vector<uint8>, msgpack decides to encode it as a string unfortunately.\n    rawImage = client.simGetImage(\"0\", cameraTypeMap[cameraType])\n    if (rawImage == None):\n        print(\"Camera is not returning image, please check airsim for error messages\")\n        sys.exit(0)\n    else:",
        "detail": "demos.demos_from_airsim.multirotor.opencv_show",
        "documentation": {}
    },
    {
        "label": "fps",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.opencv_show",
        "description": "demos.demos_from_airsim.multirotor.opencv_show",
        "peekOfCode": "fps = 0\nwhile True:\n    # because this method returns std::vector<uint8>, msgpack decides to encode it as a string unfortunately.\n    rawImage = client.simGetImage(\"0\", cameraTypeMap[cameraType])\n    if (rawImage == None):\n        print(\"Camera is not returning image, please check airsim for error messages\")\n        sys.exit(0)\n    else:\n        png = cv2.imdecode(airsim.string_to_uint8_array(rawImage), cv2.IMREAD_UNCHANGED)\n        cv2.putText(png,'FPS ' + str(fps),textOrg, fontFace, fontScale,(255,0,255),thickness)",
        "detail": "demos.demos_from_airsim.multirotor.opencv_show",
        "documentation": {}
    },
    {
        "label": "Position",
        "kind": 6,
        "importPath": "demos.demos_from_airsim.multirotor.orbit",
        "description": "demos.demos_from_airsim.multirotor.orbit",
        "peekOfCode": "class Position:\n    def __init__(self, pos):\n        self.x = pos.x_val\n        self.y = pos.y_val\n        self.z = pos.z_val\n# Make the drone fly in a circle.\nclass OrbitNavigator:\n    def __init__(self, radius = 2, altitude = 10, speed = 2, iterations = 1, center = [1,0], snapshots = None):\n        self.radius = radius\n        self.altitude = altitude",
        "detail": "demos.demos_from_airsim.multirotor.orbit",
        "documentation": {}
    },
    {
        "label": "OrbitNavigator",
        "kind": 6,
        "importPath": "demos.demos_from_airsim.multirotor.orbit",
        "description": "demos.demos_from_airsim.multirotor.orbit",
        "peekOfCode": "class OrbitNavigator:\n    def __init__(self, radius = 2, altitude = 10, speed = 2, iterations = 1, center = [1,0], snapshots = None):\n        self.radius = radius\n        self.altitude = altitude\n        self.speed = speed\n        self.iterations = iterations\n        self.snapshots = snapshots\n        self.snapshot_delta = None\n        self.next_snapshot = None\n        self.z = None",
        "detail": "demos.demos_from_airsim.multirotor.orbit",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.path",
        "description": "demos.demos_from_airsim.multirotor.path",
        "peekOfCode": "client = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.enableApiControl(True)\nprint(\"arming the drone...\")\nclient.armDisarm(True)\nstate = client.getMultirotorState()\nif state.landed_state == airsim.LandedState.Landed:\n    print(\"taking off...\")\n    client.takeoffAsync().join()\nelse:",
        "detail": "demos.demos_from_airsim.multirotor.path",
        "documentation": {}
    },
    {
        "label": "state",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.path",
        "description": "demos.demos_from_airsim.multirotor.path",
        "peekOfCode": "state = client.getMultirotorState()\nif state.landed_state == airsim.LandedState.Landed:\n    print(\"taking off...\")\n    client.takeoffAsync().join()\nelse:\n    client.hoverAsync().join()\ntime.sleep(1)\nstate = client.getMultirotorState()\nif state.landed_state == airsim.LandedState.Landed:\n    print(\"take off failed...\")",
        "detail": "demos.demos_from_airsim.multirotor.path",
        "documentation": {}
    },
    {
        "label": "state",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.path",
        "description": "demos.demos_from_airsim.multirotor.path",
        "peekOfCode": "state = client.getMultirotorState()\nif state.landed_state == airsim.LandedState.Landed:\n    print(\"take off failed...\")\n    sys.exit(1)\n# AirSim uses NED coordinates so negative axis is up.\n# z of -7 is 7 meters above the original launch point.\nz = -7\nprint(\"make sure we are hovering at 7 meters...\")\nclient.moveToZAsync(z, 1).join()\n# see https://github.com/Microsoft/AirSim/wiki/moveOnPath-demo",
        "detail": "demos.demos_from_airsim.multirotor.path",
        "documentation": {}
    },
    {
        "label": "z",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.path",
        "description": "demos.demos_from_airsim.multirotor.path",
        "peekOfCode": "z = -7\nprint(\"make sure we are hovering at 7 meters...\")\nclient.moveToZAsync(z, 1).join()\n# see https://github.com/Microsoft/AirSim/wiki/moveOnPath-demo\n# this method is async and we are not waiting for the result since we are passing timeout_sec=0.\nprint(\"flying on path...\")\nresult = client.moveOnPathAsync([airsim.Vector3r(125,0,z),\n                                airsim.Vector3r(125,-130,z),\n                                airsim.Vector3r(0,-130,z),\n                                airsim.Vector3r(0,0,z)],",
        "detail": "demos.demos_from_airsim.multirotor.path",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.path",
        "description": "demos.demos_from_airsim.multirotor.path",
        "peekOfCode": "result = client.moveOnPathAsync([airsim.Vector3r(125,0,z),\n                                airsim.Vector3r(125,-130,z),\n                                airsim.Vector3r(0,-130,z),\n                                airsim.Vector3r(0,0,z)],\n                        12, 120,\n                        airsim.DrivetrainType.ForwardOnly, airsim.YawMode(False,0), 20, 1).join()\n# drone will over-shoot so we bring it back to the start point before landing.\nclient.moveToPositionAsync(0,0,z,1).join()\nprint(\"landing...\")\nclient.landAsync().join()",
        "detail": "demos.demos_from_airsim.multirotor.path",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.pause_continue_drone",
        "description": "demos.demos_from_airsim.multirotor.pause_continue_drone",
        "peekOfCode": "client = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.enableApiControl(True)\nclient.armDisarm(True)\nprint(\"Taking off\")\nclient.moveByVelocityZAsync(0, 0, -20, 8).join()\ntime.sleep(3)    \nfor i in range(1, 6):\n    print(\"Starting command to run for 15sec\")\n    client.moveByVelocityZAsync(-1*i, -1*i, -20-i, 15)",
        "detail": "demos.demos_from_airsim.multirotor.pause_continue_drone",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.plot_markers",
        "description": "demos.demos_from_airsim.multirotor.plot_markers",
        "peekOfCode": "client = airsim.VehicleClient()\nclient.confirmConnection()\n# plot red arrows for 30 seconds\nclient.simPlotArrows(points_start = [Vector3r(x,y,0) for x, y in zip(np.linspace(0,10,20), np.linspace(0,0,20))], \n                        points_end = [Vector3r(x,y,0) for x, y in zip(np.linspace(0,10,20), np.linspace(10,10,20))], \n                        color_rgba = [1.0, 0.0, 1.0, 1.0], duration = 30.0, arrow_size = 10, thickness = 1)\n# plot magenta arrows for 15 seconds\nclient.simPlotArrows(points_start = [Vector3r(x,y,-3) for x, y in zip(np.linspace(0,10,20), np.linspace(0,0,20))], \n                        points_end = [Vector3r(x,y,-5) for x, y in zip(np.linspace(0,10,20), np.linspace(10,20,20))], \n                        color_rgba = [1.0, 1.0, 0.0, 1.0], duration = 15.0, arrow_size = 20, thickness = 3)",
        "detail": "demos.demos_from_airsim.multirotor.plot_markers",
        "documentation": {}
    },
    {
        "label": "client.simPlotArrows(points_start",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.plot_markers",
        "description": "demos.demos_from_airsim.multirotor.plot_markers",
        "peekOfCode": "client.simPlotArrows(points_start = [Vector3r(x,y,0) for x, y in zip(np.linspace(0,10,20), np.linspace(0,0,20))], \n                        points_end = [Vector3r(x,y,0) for x, y in zip(np.linspace(0,10,20), np.linspace(10,10,20))], \n                        color_rgba = [1.0, 0.0, 1.0, 1.0], duration = 30.0, arrow_size = 10, thickness = 1)\n# plot magenta arrows for 15 seconds\nclient.simPlotArrows(points_start = [Vector3r(x,y,-3) for x, y in zip(np.linspace(0,10,20), np.linspace(0,0,20))], \n                        points_end = [Vector3r(x,y,-5) for x, y in zip(np.linspace(0,10,20), np.linspace(10,20,20))], \n                        color_rgba = [1.0, 1.0, 0.0, 1.0], duration = 15.0, arrow_size = 20, thickness = 3)\n# plot red arrows for 10 seconds\nclient.simPlotArrows(points_start = [Vector3r(x,y,z) for x, y, z in zip(np.linspace(0,10,20), np.linspace(0,0,20), np.linspace(-3,-10, 20))], \n                        points_end = [Vector3r(x,y,z) for x, y, z in zip(np.linspace(0,10,20), np.linspace(10,20,20), np.linspace(-5,-8, 20))], ",
        "detail": "demos.demos_from_airsim.multirotor.plot_markers",
        "documentation": {}
    },
    {
        "label": "client.simPlotArrows(points_start",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.plot_markers",
        "description": "demos.demos_from_airsim.multirotor.plot_markers",
        "peekOfCode": "client.simPlotArrows(points_start = [Vector3r(x,y,-3) for x, y in zip(np.linspace(0,10,20), np.linspace(0,0,20))], \n                        points_end = [Vector3r(x,y,-5) for x, y in zip(np.linspace(0,10,20), np.linspace(10,20,20))], \n                        color_rgba = [1.0, 1.0, 0.0, 1.0], duration = 15.0, arrow_size = 20, thickness = 3)\n# plot red arrows for 10 seconds\nclient.simPlotArrows(points_start = [Vector3r(x,y,z) for x, y, z in zip(np.linspace(0,10,20), np.linspace(0,0,20), np.linspace(-3,-10, 20))], \n                        points_end = [Vector3r(x,y,z) for x, y, z in zip(np.linspace(0,10,20), np.linspace(10,20,20), np.linspace(-5,-8, 20))], \n                        color_rgba = [1.0, 0.0, 0.0, 1.0], duration = 10.0, arrow_size = 100, thickness = 5)\n# plot 2 white arrows which are persistent \nclient.simPlotArrows(points_start = [Vector3r(x,y,-2) for x, y in zip(np.linspace(0,10,20), np.linspace(0,20,20))], \n                        points_end = [Vector3r(x,y,-5) for x, y in zip(np.linspace(3,17,20), np.linspace(5,28,20))], ",
        "detail": "demos.demos_from_airsim.multirotor.plot_markers",
        "documentation": {}
    },
    {
        "label": "client.simPlotArrows(points_start",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.plot_markers",
        "description": "demos.demos_from_airsim.multirotor.plot_markers",
        "peekOfCode": "client.simPlotArrows(points_start = [Vector3r(x,y,z) for x, y, z in zip(np.linspace(0,10,20), np.linspace(0,0,20), np.linspace(-3,-10, 20))], \n                        points_end = [Vector3r(x,y,z) for x, y, z in zip(np.linspace(0,10,20), np.linspace(10,20,20), np.linspace(-5,-8, 20))], \n                        color_rgba = [1.0, 0.0, 0.0, 1.0], duration = 10.0, arrow_size = 100, thickness = 5)\n# plot 2 white arrows which are persistent \nclient.simPlotArrows(points_start = [Vector3r(x,y,-2) for x, y in zip(np.linspace(0,10,20), np.linspace(0,20,20))], \n                        points_end = [Vector3r(x,y,-5) for x, y in zip(np.linspace(3,17,20), np.linspace(5,28,20))], \n                        color_rgba = [1.0, 1.0, 1.0, 1.0], duration = 5.0, arrow_size = 100, thickness = 1, is_persistent = True)\n# plot points \nclient.simPlotPoints(points = [Vector3r(x,y,-5) for x, y in zip(np.linspace(0,-10,20), np.linspace(0,-20,20))], color_rgba=[1.0, 0.0, 0.0, 1.0], size = 25, duration = 20.0, is_persistent = False)\nclient.simPlotPoints(points = [Vector3r(x,y,z) for x, y, z in zip(np.linspace(0,-10,20), np.linspace(0,-20,20), np.linspace(0,-5,20))], color_rgba=[0.0, 0.0, 1.0, 1.0], size = 10, duration = 20.0, is_persistent = False)",
        "detail": "demos.demos_from_airsim.multirotor.plot_markers",
        "documentation": {}
    },
    {
        "label": "client.simPlotArrows(points_start",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.plot_markers",
        "description": "demos.demos_from_airsim.multirotor.plot_markers",
        "peekOfCode": "client.simPlotArrows(points_start = [Vector3r(x,y,-2) for x, y in zip(np.linspace(0,10,20), np.linspace(0,20,20))], \n                        points_end = [Vector3r(x,y,-5) for x, y in zip(np.linspace(3,17,20), np.linspace(5,28,20))], \n                        color_rgba = [1.0, 1.0, 1.0, 1.0], duration = 5.0, arrow_size = 100, thickness = 1, is_persistent = True)\n# plot points \nclient.simPlotPoints(points = [Vector3r(x,y,-5) for x, y in zip(np.linspace(0,-10,20), np.linspace(0,-20,20))], color_rgba=[1.0, 0.0, 0.0, 1.0], size = 25, duration = 20.0, is_persistent = False)\nclient.simPlotPoints(points = [Vector3r(x,y,z) for x, y, z in zip(np.linspace(0,-10,20), np.linspace(0,-20,20), np.linspace(0,-5,20))], color_rgba=[0.0, 0.0, 1.0, 1.0], size = 10, duration = 20.0, is_persistent = False)\nclient.simPlotPoints(points = [Vector3r(x,y,z) for x, y, z in zip(np.linspace(0,10,20), np.linspace(0,-20,20), np.linspace(0,-7,20))], color_rgba=[1.0, 0.0, 1.0, 1.0], size = 15, duration = 20.0, is_persistent = False)\n# plot line strip. 0-1, 1-2, 2-3\nclient.simPlotLineStrip(points = [Vector3r(x,y,-5) for x, y in zip(np.linspace(0,-10,10), np.linspace(0,-20,10))], color_rgba=[1.0, 0.0, 0.0, 1.0], thickness = 5, duration = 30.0, is_persistent = False)\n# plot line list. 0-1, 2-3, 4-5. Must be even. ",
        "detail": "demos.demos_from_airsim.multirotor.plot_markers",
        "documentation": {}
    },
    {
        "label": "client.simPlotPoints(points",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.plot_markers",
        "description": "demos.demos_from_airsim.multirotor.plot_markers",
        "peekOfCode": "client.simPlotPoints(points = [Vector3r(x,y,-5) for x, y in zip(np.linspace(0,-10,20), np.linspace(0,-20,20))], color_rgba=[1.0, 0.0, 0.0, 1.0], size = 25, duration = 20.0, is_persistent = False)\nclient.simPlotPoints(points = [Vector3r(x,y,z) for x, y, z in zip(np.linspace(0,-10,20), np.linspace(0,-20,20), np.linspace(0,-5,20))], color_rgba=[0.0, 0.0, 1.0, 1.0], size = 10, duration = 20.0, is_persistent = False)\nclient.simPlotPoints(points = [Vector3r(x,y,z) for x, y, z in zip(np.linspace(0,10,20), np.linspace(0,-20,20), np.linspace(0,-7,20))], color_rgba=[1.0, 0.0, 1.0, 1.0], size = 15, duration = 20.0, is_persistent = False)\n# plot line strip. 0-1, 1-2, 2-3\nclient.simPlotLineStrip(points = [Vector3r(x,y,-5) for x, y in zip(np.linspace(0,-10,10), np.linspace(0,-20,10))], color_rgba=[1.0, 0.0, 0.0, 1.0], thickness = 5, duration = 30.0, is_persistent = False)\n# plot line list. 0-1, 2-3, 4-5. Must be even. \nclient.simPlotLineList(points = [Vector3r(x,y,-7) for x, y in zip(np.linspace(0,-10,10), np.linspace(0,-20,10))], color_rgba=[1.0, 0.0, 0.0, 1.0], thickness = 5, duration = 30.0, is_persistent = False)\n# plot transforms \nclient.simPlotStrings(strings = [\"Microsoft AirSim\" for i in range(5)], positions = [Vector3r(x,y,-1) for x, y in zip(np.linspace(0,5,5), np.linspace(0,0,5))], \n                        scale = 1, color_rgba=[1.0, 1.0, 1.0, 1.0], duration = 1200.0)",
        "detail": "demos.demos_from_airsim.multirotor.plot_markers",
        "documentation": {}
    },
    {
        "label": "client.simPlotPoints(points",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.plot_markers",
        "description": "demos.demos_from_airsim.multirotor.plot_markers",
        "peekOfCode": "client.simPlotPoints(points = [Vector3r(x,y,z) for x, y, z in zip(np.linspace(0,-10,20), np.linspace(0,-20,20), np.linspace(0,-5,20))], color_rgba=[0.0, 0.0, 1.0, 1.0], size = 10, duration = 20.0, is_persistent = False)\nclient.simPlotPoints(points = [Vector3r(x,y,z) for x, y, z in zip(np.linspace(0,10,20), np.linspace(0,-20,20), np.linspace(0,-7,20))], color_rgba=[1.0, 0.0, 1.0, 1.0], size = 15, duration = 20.0, is_persistent = False)\n# plot line strip. 0-1, 1-2, 2-3\nclient.simPlotLineStrip(points = [Vector3r(x,y,-5) for x, y in zip(np.linspace(0,-10,10), np.linspace(0,-20,10))], color_rgba=[1.0, 0.0, 0.0, 1.0], thickness = 5, duration = 30.0, is_persistent = False)\n# plot line list. 0-1, 2-3, 4-5. Must be even. \nclient.simPlotLineList(points = [Vector3r(x,y,-7) for x, y in zip(np.linspace(0,-10,10), np.linspace(0,-20,10))], color_rgba=[1.0, 0.0, 0.0, 1.0], thickness = 5, duration = 30.0, is_persistent = False)\n# plot transforms \nclient.simPlotStrings(strings = [\"Microsoft AirSim\" for i in range(5)], positions = [Vector3r(x,y,-1) for x, y in zip(np.linspace(0,5,5), np.linspace(0,0,5))], \n                        scale = 1, color_rgba=[1.0, 1.0, 1.0, 1.0], duration = 1200.0)\n# client.simPlotTransforms(poses = [Pose(position_val=Vector3r(x,y,0), orientation_val=to_quaternion(pitch=0.0, roll=0.0, yaw=yaw)) for x, y, yaw in zip(np.linspace(0,10,10), np.linspace(0,0,10), np.linspace(0,np.pi,10))], ",
        "detail": "demos.demos_from_airsim.multirotor.plot_markers",
        "documentation": {}
    },
    {
        "label": "client.simPlotPoints(points",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.plot_markers",
        "description": "demos.demos_from_airsim.multirotor.plot_markers",
        "peekOfCode": "client.simPlotPoints(points = [Vector3r(x,y,z) for x, y, z in zip(np.linspace(0,10,20), np.linspace(0,-20,20), np.linspace(0,-7,20))], color_rgba=[1.0, 0.0, 1.0, 1.0], size = 15, duration = 20.0, is_persistent = False)\n# plot line strip. 0-1, 1-2, 2-3\nclient.simPlotLineStrip(points = [Vector3r(x,y,-5) for x, y in zip(np.linspace(0,-10,10), np.linspace(0,-20,10))], color_rgba=[1.0, 0.0, 0.0, 1.0], thickness = 5, duration = 30.0, is_persistent = False)\n# plot line list. 0-1, 2-3, 4-5. Must be even. \nclient.simPlotLineList(points = [Vector3r(x,y,-7) for x, y in zip(np.linspace(0,-10,10), np.linspace(0,-20,10))], color_rgba=[1.0, 0.0, 0.0, 1.0], thickness = 5, duration = 30.0, is_persistent = False)\n# plot transforms \nclient.simPlotStrings(strings = [\"Microsoft AirSim\" for i in range(5)], positions = [Vector3r(x,y,-1) for x, y in zip(np.linspace(0,5,5), np.linspace(0,0,5))], \n                        scale = 1, color_rgba=[1.0, 1.0, 1.0, 1.0], duration = 1200.0)\n# client.simPlotTransforms(poses = [Pose(position_val=Vector3r(x,y,0), orientation_val=to_quaternion(pitch=0.0, roll=0.0, yaw=yaw)) for x, y, yaw in zip(np.linspace(0,10,10), np.linspace(0,0,10), np.linspace(0,np.pi,10))], \n#                         scale = 35, thickness = 5, duration = 1200.0, is_persistent = False)",
        "detail": "demos.demos_from_airsim.multirotor.plot_markers",
        "documentation": {}
    },
    {
        "label": "client.simPlotLineStrip(points",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.plot_markers",
        "description": "demos.demos_from_airsim.multirotor.plot_markers",
        "peekOfCode": "client.simPlotLineStrip(points = [Vector3r(x,y,-5) for x, y in zip(np.linspace(0,-10,10), np.linspace(0,-20,10))], color_rgba=[1.0, 0.0, 0.0, 1.0], thickness = 5, duration = 30.0, is_persistent = False)\n# plot line list. 0-1, 2-3, 4-5. Must be even. \nclient.simPlotLineList(points = [Vector3r(x,y,-7) for x, y in zip(np.linspace(0,-10,10), np.linspace(0,-20,10))], color_rgba=[1.0, 0.0, 0.0, 1.0], thickness = 5, duration = 30.0, is_persistent = False)\n# plot transforms \nclient.simPlotStrings(strings = [\"Microsoft AirSim\" for i in range(5)], positions = [Vector3r(x,y,-1) for x, y in zip(np.linspace(0,5,5), np.linspace(0,0,5))], \n                        scale = 1, color_rgba=[1.0, 1.0, 1.0, 1.0], duration = 1200.0)\n# client.simPlotTransforms(poses = [Pose(position_val=Vector3r(x,y,0), orientation_val=to_quaternion(pitch=0.0, roll=0.0, yaw=yaw)) for x, y, yaw in zip(np.linspace(0,10,10), np.linspace(0,0,10), np.linspace(0,np.pi,10))], \n#                         scale = 35, thickness = 5, duration = 1200.0, is_persistent = False)\n# client.simPlotTransforms(poses = [Pose(position_val=Vector3r(x,y,0), orientation_val=to_quaternion(pitch=0.0, roll=roll, yaw=0.0)) for x, y, roll in zip(np.linspace(0,10,10), np.linspace(1,1,10), np.linspace(0,np.pi,10))], \n#                         scale = 35, thickness = 5, duration = 1200.0, is_persistent = False)",
        "detail": "demos.demos_from_airsim.multirotor.plot_markers",
        "documentation": {}
    },
    {
        "label": "client.simPlotLineList(points",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.plot_markers",
        "description": "demos.demos_from_airsim.multirotor.plot_markers",
        "peekOfCode": "client.simPlotLineList(points = [Vector3r(x,y,-7) for x, y in zip(np.linspace(0,-10,10), np.linspace(0,-20,10))], color_rgba=[1.0, 0.0, 0.0, 1.0], thickness = 5, duration = 30.0, is_persistent = False)\n# plot transforms \nclient.simPlotStrings(strings = [\"Microsoft AirSim\" for i in range(5)], positions = [Vector3r(x,y,-1) for x, y in zip(np.linspace(0,5,5), np.linspace(0,0,5))], \n                        scale = 1, color_rgba=[1.0, 1.0, 1.0, 1.0], duration = 1200.0)\n# client.simPlotTransforms(poses = [Pose(position_val=Vector3r(x,y,0), orientation_val=to_quaternion(pitch=0.0, roll=0.0, yaw=yaw)) for x, y, yaw in zip(np.linspace(0,10,10), np.linspace(0,0,10), np.linspace(0,np.pi,10))], \n#                         scale = 35, thickness = 5, duration = 1200.0, is_persistent = False)\n# client.simPlotTransforms(poses = [Pose(position_val=Vector3r(x,y,0), orientation_val=to_quaternion(pitch=0.0, roll=roll, yaw=0.0)) for x, y, roll in zip(np.linspace(0,10,10), np.linspace(1,1,10), np.linspace(0,np.pi,10))], \n#                         scale = 35, thickness = 5, duration = 1200.0, is_persistent = False)\nclient.simPlotTransformsWithNames(poses = [Pose(position_val=Vector3r(x,y,0), orientation_val=to_quaternion(pitch=0.0, roll=0.0, yaw=yaw)) for x, y, yaw in zip(np.linspace(0,10,10), np.linspace(0,0,10), np.linspace(0,np.pi,10))], \n                                  names=[\"tf_yaw_\" + str(idx) for idx in range(10)], tf_scale = 35, tf_thickness = 5, text_scale = 1, text_color_rgba = [1.0, 1.0, 1.0, 1.0], duration = 1200.0)",
        "detail": "demos.demos_from_airsim.multirotor.plot_markers",
        "documentation": {}
    },
    {
        "label": "client.simPlotStrings(strings",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.plot_markers",
        "description": "demos.demos_from_airsim.multirotor.plot_markers",
        "peekOfCode": "client.simPlotStrings(strings = [\"Microsoft AirSim\" for i in range(5)], positions = [Vector3r(x,y,-1) for x, y in zip(np.linspace(0,5,5), np.linspace(0,0,5))], \n                        scale = 1, color_rgba=[1.0, 1.0, 1.0, 1.0], duration = 1200.0)\n# client.simPlotTransforms(poses = [Pose(position_val=Vector3r(x,y,0), orientation_val=to_quaternion(pitch=0.0, roll=0.0, yaw=yaw)) for x, y, yaw in zip(np.linspace(0,10,10), np.linspace(0,0,10), np.linspace(0,np.pi,10))], \n#                         scale = 35, thickness = 5, duration = 1200.0, is_persistent = False)\n# client.simPlotTransforms(poses = [Pose(position_val=Vector3r(x,y,0), orientation_val=to_quaternion(pitch=0.0, roll=roll, yaw=0.0)) for x, y, roll in zip(np.linspace(0,10,10), np.linspace(1,1,10), np.linspace(0,np.pi,10))], \n#                         scale = 35, thickness = 5, duration = 1200.0, is_persistent = False)\nclient.simPlotTransformsWithNames(poses = [Pose(position_val=Vector3r(x,y,0), orientation_val=to_quaternion(pitch=0.0, roll=0.0, yaw=yaw)) for x, y, yaw in zip(np.linspace(0,10,10), np.linspace(0,0,10), np.linspace(0,np.pi,10))], \n                                  names=[\"tf_yaw_\" + str(idx) for idx in range(10)], tf_scale = 35, tf_thickness = 5, text_scale = 1, text_color_rgba = [1.0, 1.0, 1.0, 1.0], duration = 1200.0)\nclient.simPlotTransformsWithNames(poses = [Pose(position_val=Vector3r(x,y,0), orientation_val=to_quaternion(pitch=0.0, roll=roll, yaw=0.0)) for x, y, roll in zip(np.linspace(0,10,10), np.linspace(1,1,10), np.linspace(0,np.pi,10))], \n                                  names=[\"tf_roll_\" + str(idx) for idx in range(10)], tf_scale = 35, tf_thickness = 5, text_scale = 1, text_color_rgba = [1.0, 1.0, 1.0, 1.0], duration = 1200.0)",
        "detail": "demos.demos_from_airsim.multirotor.plot_markers",
        "documentation": {}
    },
    {
        "label": "client.simPlotTransformsWithNames(poses",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.plot_markers",
        "description": "demos.demos_from_airsim.multirotor.plot_markers",
        "peekOfCode": "client.simPlotTransformsWithNames(poses = [Pose(position_val=Vector3r(x,y,0), orientation_val=to_quaternion(pitch=0.0, roll=0.0, yaw=yaw)) for x, y, yaw in zip(np.linspace(0,10,10), np.linspace(0,0,10), np.linspace(0,np.pi,10))], \n                                  names=[\"tf_yaw_\" + str(idx) for idx in range(10)], tf_scale = 35, tf_thickness = 5, text_scale = 1, text_color_rgba = [1.0, 1.0, 1.0, 1.0], duration = 1200.0)\nclient.simPlotTransformsWithNames(poses = [Pose(position_val=Vector3r(x,y,0), orientation_val=to_quaternion(pitch=0.0, roll=roll, yaw=0.0)) for x, y, roll in zip(np.linspace(0,10,10), np.linspace(1,1,10), np.linspace(0,np.pi,10))], \n                                  names=[\"tf_roll_\" + str(idx) for idx in range(10)], tf_scale = 35, tf_thickness = 5, text_scale = 1, text_color_rgba = [1.0, 1.0, 1.0, 1.0], duration = 1200.0)\nclient.simPlotTransformsWithNames(poses = [Pose(position_val=Vector3r(x,y,0), orientation_val=to_quaternion(pitch=pitch, roll=0.0, yaw=0.0)) for x, y, pitch in zip(np.linspace(0,10,10), np.linspace(-1,-1,10), np.linspace(0,np.pi,10))],\n                                  names=[\"tf_pitch_\" + str(idx) for idx in range(10)], tf_scale = 35, tf_thickness = 5, text_scale = 1, text_color_rgba = [1.0, 1.0, 1.0, 1.0], duration = 1200.0)\ntime.sleep(20.0)\nclient.simFlushPersistentMarkers()",
        "detail": "demos.demos_from_airsim.multirotor.plot_markers",
        "documentation": {}
    },
    {
        "label": "client.simPlotTransformsWithNames(poses",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.plot_markers",
        "description": "demos.demos_from_airsim.multirotor.plot_markers",
        "peekOfCode": "client.simPlotTransformsWithNames(poses = [Pose(position_val=Vector3r(x,y,0), orientation_val=to_quaternion(pitch=0.0, roll=roll, yaw=0.0)) for x, y, roll in zip(np.linspace(0,10,10), np.linspace(1,1,10), np.linspace(0,np.pi,10))], \n                                  names=[\"tf_roll_\" + str(idx) for idx in range(10)], tf_scale = 35, tf_thickness = 5, text_scale = 1, text_color_rgba = [1.0, 1.0, 1.0, 1.0], duration = 1200.0)\nclient.simPlotTransformsWithNames(poses = [Pose(position_val=Vector3r(x,y,0), orientation_val=to_quaternion(pitch=pitch, roll=0.0, yaw=0.0)) for x, y, pitch in zip(np.linspace(0,10,10), np.linspace(-1,-1,10), np.linspace(0,np.pi,10))],\n                                  names=[\"tf_pitch_\" + str(idx) for idx in range(10)], tf_scale = 35, tf_thickness = 5, text_scale = 1, text_color_rgba = [1.0, 1.0, 1.0, 1.0], duration = 1200.0)\ntime.sleep(20.0)\nclient.simFlushPersistentMarkers()",
        "detail": "demos.demos_from_airsim.multirotor.plot_markers",
        "documentation": {}
    },
    {
        "label": "client.simPlotTransformsWithNames(poses",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.plot_markers",
        "description": "demos.demos_from_airsim.multirotor.plot_markers",
        "peekOfCode": "client.simPlotTransformsWithNames(poses = [Pose(position_val=Vector3r(x,y,0), orientation_val=to_quaternion(pitch=pitch, roll=0.0, yaw=0.0)) for x, y, pitch in zip(np.linspace(0,10,10), np.linspace(-1,-1,10), np.linspace(0,np.pi,10))],\n                                  names=[\"tf_pitch_\" + str(idx) for idx in range(10)], tf_scale = 35, tf_thickness = 5, text_scale = 1, text_color_rgba = [1.0, 1.0, 1.0, 1.0], duration = 1200.0)\ntime.sleep(20.0)\nclient.simFlushPersistentMarkers()",
        "detail": "demos.demos_from_airsim.multirotor.plot_markers",
        "documentation": {}
    },
    {
        "label": "printUsage",
        "kind": 2,
        "importPath": "demos.demos_from_airsim.multirotor.point_cloud",
        "description": "demos.demos_from_airsim.multirotor.point_cloud",
        "peekOfCode": "def printUsage():\n   print(\"Usage: python point_cloud.py [cloud.txt]\")\ndef savePointCloud(image, fileName):\n   f = open(fileName, \"w\")\n   for x in range(image.shape[0]):\n     for y in range(image.shape[1]):\n        pt = image[x,y]\n        if (math.isinf(pt[0]) or math.isnan(pt[0])):\n          # skip it\n          None",
        "detail": "demos.demos_from_airsim.multirotor.point_cloud",
        "documentation": {}
    },
    {
        "label": "savePointCloud",
        "kind": 2,
        "importPath": "demos.demos_from_airsim.multirotor.point_cloud",
        "description": "demos.demos_from_airsim.multirotor.point_cloud",
        "peekOfCode": "def savePointCloud(image, fileName):\n   f = open(fileName, \"w\")\n   for x in range(image.shape[0]):\n     for y in range(image.shape[1]):\n        pt = image[x,y]\n        if (math.isinf(pt[0]) or math.isnan(pt[0])):\n          # skip it\n          None\n        else: \n          f.write(\"%f %f %f %s\\n\" % (pt[0], pt[1], pt[2]-1, rgb))",
        "detail": "demos.demos_from_airsim.multirotor.point_cloud",
        "documentation": {}
    },
    {
        "label": "outputFile",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.point_cloud",
        "description": "demos.demos_from_airsim.multirotor.point_cloud",
        "peekOfCode": "outputFile = \"cloud.asc\" \ncolor = (0,255,0)\nrgb = \"%d %d %d\" % color\nprojectionMatrix = np.array([[-0.501202762, 0.000000000, 0.000000000, 0.000000000],\n                              [0.000000000, -0.501202762, 0.000000000, 0.000000000],\n                              [0.000000000, 0.000000000, 10.00000000, 100.00000000],\n                              [0.000000000, 0.000000000, -10.0000000, 0.000000000]])\ndef printUsage():\n   print(\"Usage: python point_cloud.py [cloud.txt]\")\ndef savePointCloud(image, fileName):",
        "detail": "demos.demos_from_airsim.multirotor.point_cloud",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.point_cloud",
        "description": "demos.demos_from_airsim.multirotor.point_cloud",
        "peekOfCode": "color = (0,255,0)\nrgb = \"%d %d %d\" % color\nprojectionMatrix = np.array([[-0.501202762, 0.000000000, 0.000000000, 0.000000000],\n                              [0.000000000, -0.501202762, 0.000000000, 0.000000000],\n                              [0.000000000, 0.000000000, 10.00000000, 100.00000000],\n                              [0.000000000, 0.000000000, -10.0000000, 0.000000000]])\ndef printUsage():\n   print(\"Usage: python point_cloud.py [cloud.txt]\")\ndef savePointCloud(image, fileName):\n   f = open(fileName, \"w\")",
        "detail": "demos.demos_from_airsim.multirotor.point_cloud",
        "documentation": {}
    },
    {
        "label": "rgb",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.point_cloud",
        "description": "demos.demos_from_airsim.multirotor.point_cloud",
        "peekOfCode": "rgb = \"%d %d %d\" % color\nprojectionMatrix = np.array([[-0.501202762, 0.000000000, 0.000000000, 0.000000000],\n                              [0.000000000, -0.501202762, 0.000000000, 0.000000000],\n                              [0.000000000, 0.000000000, 10.00000000, 100.00000000],\n                              [0.000000000, 0.000000000, -10.0000000, 0.000000000]])\ndef printUsage():\n   print(\"Usage: python point_cloud.py [cloud.txt]\")\ndef savePointCloud(image, fileName):\n   f = open(fileName, \"w\")\n   for x in range(image.shape[0]):",
        "detail": "demos.demos_from_airsim.multirotor.point_cloud",
        "documentation": {}
    },
    {
        "label": "projectionMatrix",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.point_cloud",
        "description": "demos.demos_from_airsim.multirotor.point_cloud",
        "peekOfCode": "projectionMatrix = np.array([[-0.501202762, 0.000000000, 0.000000000, 0.000000000],\n                              [0.000000000, -0.501202762, 0.000000000, 0.000000000],\n                              [0.000000000, 0.000000000, 10.00000000, 100.00000000],\n                              [0.000000000, 0.000000000, -10.0000000, 0.000000000]])\ndef printUsage():\n   print(\"Usage: python point_cloud.py [cloud.txt]\")\ndef savePointCloud(image, fileName):\n   f = open(fileName, \"w\")\n   for x in range(image.shape[0]):\n     for y in range(image.shape[1]):",
        "detail": "demos.demos_from_airsim.multirotor.point_cloud",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.point_cloud",
        "description": "demos.demos_from_airsim.multirotor.point_cloud",
        "peekOfCode": "client = airsim.MultirotorClient()\nwhile True:\n    rawImage = client.simGetImage(\"0\", airsim.ImageType.DepthPerspective)\n    if (rawImage is None):\n        print(\"Camera is not returning image, please check airsim for error messages\")\n        airsim.wait_key(\"Press any key to exit\")\n        sys.exit(0)\n    else:\n        png = cv2.imdecode(np.frombuffer(rawImage, np.uint8) , cv2.IMREAD_UNCHANGED)\n        gray = cv2.cvtColor(png, cv2.COLOR_BGR2GRAY)",
        "detail": "demos.demos_from_airsim.multirotor.point_cloud",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.reset_test_drone",
        "description": "demos.demos_from_airsim.multirotor.reset_test_drone",
        "peekOfCode": "client = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.enableApiControl(True)\nclient.armDisarm(True)\nprint(\"fly\")\nclient.moveToPositionAsync(0, 0, -10, 5).join()\nprint(\"reset\")\nclient.reset()\nclient.enableApiControl(True)\nclient.armDisarm(True)",
        "detail": "demos.demos_from_airsim.multirotor.reset_test_drone",
        "documentation": {}
    },
    {
        "label": "SetupPath",
        "kind": 6,
        "importPath": "demos.demos_from_airsim.multirotor.setup_path",
        "description": "demos.demos_from_airsim.multirotor.setup_path",
        "peekOfCode": "class SetupPath:\n    @staticmethod\n    def getDirLevels(path):\n        path_norm = os.path.normpath(path)\n        return len(path_norm.split(os.sep))\n    @staticmethod\n    def getCurrentPath():\n        cur_filepath = __file__\n        return os.path.dirname(cur_filepath)\n    @staticmethod",
        "detail": "demos.demos_from_airsim.multirotor.setup_path",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.set_trace_line",
        "description": "demos.demos_from_airsim.multirotor.set_trace_line",
        "peekOfCode": "client = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.enableApiControl(True)\nclient.armDisarm(True)\nclient.takeoffAsync().join()\nclient.hoverAsync().join()\nvehicleControl = client.moveByVelocityAsync(1, 1, 0, 12)\nclient.simSetTraceLine([1.0, 0.0, 0.0, 1.0], 5)\ntime.sleep(2)\nclient.simSetTraceLine([0.0, 1.0, 0.0, 0.8], 10)",
        "detail": "demos.demos_from_airsim.multirotor.set_trace_line",
        "documentation": {}
    },
    {
        "label": "vehicleControl",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.set_trace_line",
        "description": "demos.demos_from_airsim.multirotor.set_trace_line",
        "peekOfCode": "vehicleControl = client.moveByVelocityAsync(1, 1, 0, 12)\nclient.simSetTraceLine([1.0, 0.0, 0.0, 1.0], 5)\ntime.sleep(2)\nclient.simSetTraceLine([0.0, 1.0, 0.0, 0.8], 10)\ntime.sleep(2)\nclient.simSetTraceLine([0.0, 0.0, 1.0, 0.6], 20)\ntime.sleep(2)\nclient.simSetTraceLine([1.0, 1.0, 0.0, 0.4], 30)\ntime.sleep(2)\nclient.simSetTraceLine([0.0, 1.0, 1.0, 0.2], 40)",
        "detail": "demos.demos_from_airsim.multirotor.set_trace_line",
        "documentation": {}
    },
    {
        "label": "print_state",
        "kind": 2,
        "importPath": "demos.demos_from_airsim.multirotor.state",
        "description": "demos.demos_from_airsim.multirotor.state",
        "peekOfCode": "def print_state():\n    print(\"===============================================================\")\n    state = client.getMultirotorState()\n    print(\"state: %s\" % pprint.pformat(state))\n    return state\nclient = airsim.MultirotorClient()\nstate = print_state()\nif state.ready:\n    print(\"drone is ready!\")\nelse:",
        "detail": "demos.demos_from_airsim.multirotor.state",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.state",
        "description": "demos.demos_from_airsim.multirotor.state",
        "peekOfCode": "client = airsim.MultirotorClient()\nstate = print_state()\nif state.ready:\n    print(\"drone is ready!\")\nelse:\n    print(\"drone is not ready!\")\nif state.ready_message:\n    print(state.ready_message)",
        "detail": "demos.demos_from_airsim.multirotor.state",
        "documentation": {}
    },
    {
        "label": "state",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.state",
        "description": "demos.demos_from_airsim.multirotor.state",
        "peekOfCode": "state = print_state()\nif state.ready:\n    print(\"drone is ready!\")\nelse:\n    print(\"drone is not ready!\")\nif state.ready_message:\n    print(state.ready_message)",
        "detail": "demos.demos_from_airsim.multirotor.state",
        "documentation": {}
    },
    {
        "label": "SurveyNavigator",
        "kind": 6,
        "importPath": "demos.demos_from_airsim.multirotor.survey",
        "description": "demos.demos_from_airsim.multirotor.survey",
        "peekOfCode": "class SurveyNavigator:\n    def __init__(self, args):\n        self.boxsize = args.size\n        self.stripewidth = args.stripewidth\n        self.altitude = args.altitude\n        self.velocity = args.speed\n        self.client = airsim.MultirotorClient()\n        self.client.confirmConnection()\n        self.client.enableApiControl(True)\n    def start(self):",
        "detail": "demos.demos_from_airsim.multirotor.survey",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.takeoff",
        "description": "demos.demos_from_airsim.multirotor.takeoff",
        "peekOfCode": "client = airsim.MultirotorClient()\nclient.confirmConnection()\nclient.enableApiControl(True)\nclient.armDisarm(True)\nlanded = client.getMultirotorState().landed_state\nif landed == airsim.LandedState.Landed:\n    print(\"taking off...\")\n    client.takeoffAsync().join()\nelse:\n    print(\"already flying...\")",
        "detail": "demos.demos_from_airsim.multirotor.takeoff",
        "documentation": {}
    },
    {
        "label": "landed",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.takeoff",
        "description": "demos.demos_from_airsim.multirotor.takeoff",
        "peekOfCode": "landed = client.getMultirotorState().landed_state\nif landed == airsim.LandedState.Landed:\n    print(\"taking off...\")\n    client.takeoffAsync().join()\nelse:\n    print(\"already flying...\")\n    client.hoverAsync().join()",
        "detail": "demos.demos_from_airsim.multirotor.takeoff",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.teleport",
        "description": "demos.demos_from_airsim.multirotor.teleport",
        "peekOfCode": "client = airsim.MultirotorClient()\nclient.confirmConnection()\npose = client.simGetVehiclePose()\n# teleport the drone + 10 meters in x-direction\npose.position.x_val += 10\nclient.simSetVehiclePose(pose, True, \"Drone1\")\ntime.sleep(2)\n# teleport the drone back\npose.position.x_val -= 10\nclient.simSetVehiclePose(pose, True, \"Drone1\")",
        "detail": "demos.demos_from_airsim.multirotor.teleport",
        "documentation": {}
    },
    {
        "label": "pose",
        "kind": 5,
        "importPath": "demos.demos_from_airsim.multirotor.teleport",
        "description": "demos.demos_from_airsim.multirotor.teleport",
        "peekOfCode": "pose = client.simGetVehiclePose()\n# teleport the drone + 10 meters in x-direction\npose.position.x_val += 10\nclient.simSetVehiclePose(pose, True, \"Drone1\")\ntime.sleep(2)\n# teleport the drone back\npose.position.x_val -= 10\nclient.simSetVehiclePose(pose, True, \"Drone1\")",
        "detail": "demos.demos_from_airsim.multirotor.teleport",
        "documentation": {}
    },
    {
        "label": "check_pos",
        "kind": 2,
        "importPath": "demos.multirotor.check_trajectory",
        "description": "demos.multirotor.check_trajectory",
        "peekOfCode": "def check_pos():\n    p = client.simGetGroundTruthKinematics().position\n    print((p.x_val,p.y_val,p.z_val) )\nclient = airsim.MultirotorClient()\n# connect to the AirSim simulator\nprint(client.confirmConnection() )\nwhile(True):\n    check_pos()\n    time.sleep(timestep)\n# while(True):",
        "detail": "demos.multirotor.check_trajectory",
        "documentation": {}
    },
    {
        "label": "timestep",
        "kind": 5,
        "importPath": "demos.multirotor.check_trajectory",
        "description": "demos.multirotor.check_trajectory",
        "peekOfCode": "timestep = 0.1\ndef check_pos():\n    p = client.simGetGroundTruthKinematics().position\n    print((p.x_val,p.y_val,p.z_val) )\nclient = airsim.MultirotorClient()\n# connect to the AirSim simulator\nprint(client.confirmConnection() )\nwhile(True):\n    check_pos()\n    time.sleep(timestep)",
        "detail": "demos.multirotor.check_trajectory",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.multirotor.check_trajectory",
        "description": "demos.multirotor.check_trajectory",
        "peekOfCode": "client = airsim.MultirotorClient()\n# connect to the AirSim simulator\nprint(client.confirmConnection() )\nwhile(True):\n    check_pos()\n    time.sleep(timestep)\n# while(True):\n#     print(\"Main execution flow\")\n#     time.sleep(1)",
        "detail": "demos.multirotor.check_trajectory",
        "documentation": {}
    },
    {
        "label": "Job",
        "kind": 6,
        "importPath": "demos.multirotor.check_trajectory_threaded",
        "description": "demos.multirotor.check_trajectory_threaded",
        "peekOfCode": "class Job(threading.Thread):\n    def __init__(self):\n        threading.Thread.__init__(self)\n        # The shutdown_flag is a threading.Event object that\n        # indicates whether the thread should be terminated.\n        self.shutdown_flag = threading.Event()\n        # ... Other thread setup code here ...\n    def run(self):\n        print('Thread #%s started' % self.ident)\n        while not self.shutdown_flag.is_set():",
        "detail": "demos.multirotor.check_trajectory_threaded",
        "documentation": {}
    },
    {
        "label": "ServiceExit",
        "kind": 6,
        "importPath": "demos.multirotor.check_trajectory_threaded",
        "description": "demos.multirotor.check_trajectory_threaded",
        "peekOfCode": "class ServiceExit(Exception):\n    \"\"\"\n    Custom exception which is used to trigger the clean exit\n    of all running threads and the main program.\n    \"\"\"\n    pass\ndef service_shutdown(signum, frame):\n    print('Caught signal %d' % signum)\n    raise ServiceExit",
        "detail": "demos.multirotor.check_trajectory_threaded",
        "documentation": {}
    },
    {
        "label": "check_pos",
        "kind": 2,
        "importPath": "demos.multirotor.check_trajectory_threaded",
        "description": "demos.multirotor.check_trajectory_threaded",
        "peekOfCode": "def check_pos():\n    p = client.simGetGroundTruthKinematics().position\n    print((p.x_val,p.y_val,p.z_val) )\nclass Job(threading.Thread):\n    def __init__(self):\n        threading.Thread.__init__(self)\n        # The shutdown_flag is a threading.Event object that\n        # indicates whether the thread should be terminated.\n        self.shutdown_flag = threading.Event()\n        # ... Other thread setup code here ...",
        "detail": "demos.multirotor.check_trajectory_threaded",
        "documentation": {}
    },
    {
        "label": "service_shutdown",
        "kind": 2,
        "importPath": "demos.multirotor.check_trajectory_threaded",
        "description": "demos.multirotor.check_trajectory_threaded",
        "peekOfCode": "def service_shutdown(signum, frame):\n    print('Caught signal %d' % signum)\n    raise ServiceExit\n# -------------------------------------   # ------------------------------------------\n# Register the signal handlers\nsignal.signal(signal.SIGTERM, service_shutdown)\nsignal.signal(signal.SIGINT, service_shutdown)\nclient = airsim.MultirotorClient()\nj1 = Job()",
        "detail": "demos.multirotor.check_trajectory_threaded",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "demos.multirotor.check_trajectory_threaded",
        "description": "demos.multirotor.check_trajectory_threaded",
        "peekOfCode": "client = airsim.MultirotorClient()\nj1 = Job()\ntry:\n    # connect to the AirSim simulator\n    client.confirmConnection()\n    client.enableApiControl(True)\n    client.armDisarm(True)\n    client.takeoffAsync().join()\n    client.hoverAsync().join()\n    client.simSetTraceLine([1.0, 0.0, 0.0, 1.0], 5)",
        "detail": "demos.multirotor.check_trajectory_threaded",
        "documentation": {}
    },
    {
        "label": "j1",
        "kind": 5,
        "importPath": "demos.multirotor.check_trajectory_threaded",
        "description": "demos.multirotor.check_trajectory_threaded",
        "peekOfCode": "j1 = Job()\ntry:\n    # connect to the AirSim simulator\n    client.confirmConnection()\n    client.enableApiControl(True)\n    client.armDisarm(True)\n    client.takeoffAsync().join()\n    client.hoverAsync().join()\n    client.simSetTraceLine([1.0, 0.0, 0.0, 1.0], 5)\n    vehicleControl = client.moveByVelocityAsync(1, 4, 0, 50)",
        "detail": "demos.multirotor.check_trajectory_threaded",
        "documentation": {}
    },
    {
        "label": "DrivetrainType",
        "kind": 6,
        "importPath": "src.airsimgeo.newMyAirSimClient",
        "description": "src.airsimgeo.newMyAirSimClient",
        "peekOfCode": "class DrivetrainType:\n    MaxDegreeOfFreedom = 0\n    ForwardOnly = 1\nclass AirSimImageType:    \n    Scene = 0\n    DepthPlanner = 1\n    DepthPerspective = 2\n    DepthVis = 3\n    DisparityNormalized = 4\n    Segmentation = 5",
        "detail": "src.airsimgeo.newMyAirSimClient",
        "documentation": {}
    },
    {
        "label": "AirSimImageType",
        "kind": 6,
        "importPath": "src.airsimgeo.newMyAirSimClient",
        "description": "src.airsimgeo.newMyAirSimClient",
        "peekOfCode": "class AirSimImageType:    \n    Scene = 0\n    DepthPlanner = 1\n    DepthPerspective = 2\n    DepthVis = 3\n    DisparityNormalized = 4\n    Segmentation = 5\n    SurfaceNormals = 6\nlock = threading.Lock()\nclass NewMyAirSimClient(MultirotorClient):",
        "detail": "src.airsimgeo.newMyAirSimClient",
        "documentation": {}
    },
    {
        "label": "NewMyAirSimClient",
        "kind": 6,
        "importPath": "src.airsimgeo.newMyAirSimClient",
        "description": "src.airsimgeo.newMyAirSimClient",
        "peekOfCode": "class NewMyAirSimClient(MultirotorClient):\n    deg_to_rad = lambda d_angle: d_angle * math.pi / 180.0\n    def __init__(self,trajColFlag,canDrawTrajectories,crabMode,thickness,trajs2draw,traj2follow):        \n        MultirotorClient.__init__(self)\n        MultirotorClient.confirmConnection(self)\n        self.drones_names = [ v for v in utils.g_airsim_settings[\"Vehicles\"] ]\n        for i,dn in enumerate( self.drones_names ):\n            self.enableApiControl(True,vehicle_name=dn)\n            self.armDisarm(True,vehicle_name=dn)\n        self.trajColFlag = trajColFlag",
        "detail": "src.airsimgeo.newMyAirSimClient",
        "documentation": {}
    },
    {
        "label": "lock",
        "kind": 5,
        "importPath": "src.airsimgeo.newMyAirSimClient",
        "description": "src.airsimgeo.newMyAirSimClient",
        "peekOfCode": "lock = threading.Lock()\nclass NewMyAirSimClient(MultirotorClient):\n    deg_to_rad = lambda d_angle: d_angle * math.pi / 180.0\n    def __init__(self,trajColFlag,canDrawTrajectories,crabMode,thickness,trajs2draw,traj2follow):        \n        MultirotorClient.__init__(self)\n        MultirotorClient.confirmConnection(self)\n        self.drones_names = [ v for v in utils.g_airsim_settings[\"Vehicles\"] ]\n        for i,dn in enumerate( self.drones_names ):\n            self.enableApiControl(True,vehicle_name=dn)\n            self.armDisarm(True,vehicle_name=dn)",
        "detail": "src.airsimgeo.newMyAirSimClient",
        "documentation": {}
    },
    {
        "label": "MazeEnv",
        "kind": 6,
        "importPath": "src.gym_maze.envs.maze_env",
        "description": "src.gym_maze.envs.maze_env",
        "peekOfCode": "class MazeEnv(gym.Env):\n    ACTION = [\"N\",\"S\", \"E\", \"W\"]\n    VISITED_TO_IDX = {\"visited\":16}\n    def __init__(self, maze_file=None, maze_size=None, mode=None, enable_render=True,num_goals = 1,verbose = True,human_mode=False, \n        n_trajs = None,random_pos = False,seed_num = None,\n        fixed_goals = None, fixed_init_pos = None,visited_cells = []):\n        self.visited_cells = visited_cells\n        self.verbose = verbose\n        self.viewer = None\n        self.enable_render = enable_render",
        "detail": "src.gym_maze.envs.maze_env",
        "documentation": {}
    },
    {
        "label": "MazeView2D",
        "kind": 6,
        "importPath": "src.gym_maze.envs.maze_view_2d",
        "description": "src.gym_maze.envs.maze_view_2d",
        "peekOfCode": "class MazeView2D:\n    def __init__(self, maze_name=\"Maze2D\", maze_file_path=None,\n                 maze_size=(30, 30), screen_size=(600, 600),\n                 has_loops=False, num_portals=0, enable_render=True,num_goals = 1,verbose = True,\n                 random_pos=False,np_random=None,n_trajs=None, fixed_goals = None,\n                 fixed_init_pos = None):\n        # if(num_goals<=0 ):\n        #     raise ValueError(\"Error in num_goals parameter\")\n        self.random_pos = random_pos\n        self.fixed_goals = fixed_goals ",
        "detail": "src.gym_maze.envs.maze_view_2d",
        "documentation": {}
    },
    {
        "label": "Maze",
        "kind": 6,
        "importPath": "src.gym_maze.envs.maze_view_2d",
        "description": "src.gym_maze.envs.maze_view_2d",
        "peekOfCode": "class Maze:\n    COMPASS = {\n        \"N\": (0, -1),\n        \"E\": (1, 0),\n        \"S\": (0, 1),\n        \"W\": (-1, 0)\n    }\n    def __init__(self, maze_cells=None, maze_size=(10,10), has_loops=True, num_portals=0,verbose = True):\n        # maze member variables\n        self.maze_cells = maze_cells",
        "detail": "src.gym_maze.envs.maze_view_2d",
        "documentation": {}
    },
    {
        "label": "Portal",
        "kind": 6,
        "importPath": "src.gym_maze.envs.maze_view_2d",
        "description": "src.gym_maze.envs.maze_view_2d",
        "peekOfCode": "class Portal:\n    def __init__(self, *locations):\n        self.__locations = []\n        for location in locations:\n            if isinstance(location, (tuple, list)):\n                self.__locations.append(tuple(location))\n            else:\n                raise ValueError(\"location must be a list or a tuple.\")\n    def teleport(self, cell):\n        if cell in self.locations:",
        "detail": "src.gym_maze.envs.maze_view_2d",
        "documentation": {}
    },
    {
        "label": "actions_to_value",
        "kind": 2,
        "importPath": "src.gym_maze.envs.my_maze_generator",
        "description": "src.gym_maze.envs.my_maze_generator",
        "peekOfCode": "def actions_to_value(actions = None):\n    value = 0x0\n    if not actions:\n        return value \n    if \"N\" in actions:\n        value |= 0x1\n    if \"E\" in actions:\n        value |= 0x2\n    if \"S\" in actions:\n        value |= 0x4",
        "detail": "src.gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "add_action",
        "kind": 2,
        "importPath": "src.gym_maze.envs.my_maze_generator",
        "description": "src.gym_maze.envs.my_maze_generator",
        "peekOfCode": "def add_action(value,action):\n    if \"N\" in action:\n        value |= 0x1\n    if \"E\" in action:\n        value |= 0x2\n    if \"S\" in action:\n        value |= 0x4\n    if \"W\" in action:\n        value |= 0x8\n    return value",
        "detail": "src.gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "remove_action",
        "kind": 2,
        "importPath": "src.gym_maze.envs.my_maze_generator",
        "description": "src.gym_maze.envs.my_maze_generator",
        "peekOfCode": "def remove_action(value,action):\n    if \"N\" in action:\n        value &= ~ 0x1\n    if \"E\" in action:\n        value &= ~ 0x2\n    if \"S\" in action:\n        value &= ~ 0x4\n    if \"W\" in action:\n        value &= ~ 0x8\n    return value",
        "detail": "src.gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "cell_value",
        "kind": 2,
        "importPath": "src.gym_maze.envs.my_maze_generator",
        "description": "src.gym_maze.envs.my_maze_generator",
        "peekOfCode": "def cell_value(r,c,obs_blocks=1,street_blocks=1):\n    if(obs_blocks ==1):\n        if r %2 ==0 or c %2 ==0:\n            return 15\n        elif r != 0 and c !=0 and r != NROWS -1 and c != NCOLS -1 :\n            return 0\n        else:\n            return 15\n    else:\n        if(r % ( obs_blocks+1)==0 or c % (obs_blocks +1 ) == 0 ):",
        "detail": "src.gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "src.gym_maze.envs.my_maze_generator",
        "description": "src.gym_maze.envs.my_maze_generator",
        "peekOfCode": "a = np.load(\"gym_maze/envs/maze_samples/maze2d_001.npy\")\nprint(\"BEFORE\")\nprint(a)\ndef actions_to_value(actions = None):\n    value = 0x0\n    if not actions:\n        return value \n    if \"N\" in actions:\n        value |= 0x1\n    if \"E\" in actions:",
        "detail": "src.gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "a[1,1]",
        "kind": 5,
        "importPath": "src.gym_maze.envs.my_maze_generator",
        "description": "src.gym_maze.envs.my_maze_generator",
        "peekOfCode": "a[1,1] = 0\na[3,3] = 0\na[1,3] = 0\na[3,1] = 0\nav = actions_to_value\na = [\n    [av(\"ES\"),av(\"WE\"),av(\"WES\"),av(\"WE\"),av(\"WS\")],\n    [av(\"NS\"),av(\"\"),    av(\"NS\"),  av(\"\"), av(\"NS\")],\n    [av(\"NES\"),av(\"WE\"),av(\"NEWS\"),av(\"WE\"),av(\"NWS\")],\n    [av(\"NS\"),av(\"\"),av(\"NS\"),av(\"\"),av(\"NS\")],",
        "detail": "src.gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "a[3,3]",
        "kind": 5,
        "importPath": "src.gym_maze.envs.my_maze_generator",
        "description": "src.gym_maze.envs.my_maze_generator",
        "peekOfCode": "a[3,3] = 0\na[1,3] = 0\na[3,1] = 0\nav = actions_to_value\na = [\n    [av(\"ES\"),av(\"WE\"),av(\"WES\"),av(\"WE\"),av(\"WS\")],\n    [av(\"NS\"),av(\"\"),    av(\"NS\"),  av(\"\"), av(\"NS\")],\n    [av(\"NES\"),av(\"WE\"),av(\"NEWS\"),av(\"WE\"),av(\"NWS\")],\n    [av(\"NS\"),av(\"\"),av(\"NS\"),av(\"\"),av(\"NS\")],\n    [av(\"NE\"),av(\"WE\"),av(\"WEN\"),av(\"WE\"),av(\"WN\")],",
        "detail": "src.gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "a[1,3]",
        "kind": 5,
        "importPath": "src.gym_maze.envs.my_maze_generator",
        "description": "src.gym_maze.envs.my_maze_generator",
        "peekOfCode": "a[1,3] = 0\na[3,1] = 0\nav = actions_to_value\na = [\n    [av(\"ES\"),av(\"WE\"),av(\"WES\"),av(\"WE\"),av(\"WS\")],\n    [av(\"NS\"),av(\"\"),    av(\"NS\"),  av(\"\"), av(\"NS\")],\n    [av(\"NES\"),av(\"WE\"),av(\"NEWS\"),av(\"WE\"),av(\"NWS\")],\n    [av(\"NS\"),av(\"\"),av(\"NS\"),av(\"\"),av(\"NS\")],\n    [av(\"NE\"),av(\"WE\"),av(\"WEN\"),av(\"WE\"),av(\"WN\")],\n]",
        "detail": "src.gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "a[3,1]",
        "kind": 5,
        "importPath": "src.gym_maze.envs.my_maze_generator",
        "description": "src.gym_maze.envs.my_maze_generator",
        "peekOfCode": "a[3,1] = 0\nav = actions_to_value\na = [\n    [av(\"ES\"),av(\"WE\"),av(\"WES\"),av(\"WE\"),av(\"WS\")],\n    [av(\"NS\"),av(\"\"),    av(\"NS\"),  av(\"\"), av(\"NS\")],\n    [av(\"NES\"),av(\"WE\"),av(\"NEWS\"),av(\"WE\"),av(\"NWS\")],\n    [av(\"NS\"),av(\"\"),av(\"NS\"),av(\"\"),av(\"NS\")],\n    [av(\"NE\"),av(\"WE\"),av(\"WEN\"),av(\"WE\"),av(\"WN\")],\n]\na = np.array(a)",
        "detail": "src.gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "av",
        "kind": 5,
        "importPath": "src.gym_maze.envs.my_maze_generator",
        "description": "src.gym_maze.envs.my_maze_generator",
        "peekOfCode": "av = actions_to_value\na = [\n    [av(\"ES\"),av(\"WE\"),av(\"WES\"),av(\"WE\"),av(\"WS\")],\n    [av(\"NS\"),av(\"\"),    av(\"NS\"),  av(\"\"), av(\"NS\")],\n    [av(\"NES\"),av(\"WE\"),av(\"NEWS\"),av(\"WE\"),av(\"NWS\")],\n    [av(\"NS\"),av(\"\"),av(\"NS\"),av(\"\"),av(\"NS\")],\n    [av(\"NE\"),av(\"WE\"),av(\"WEN\"),av(\"WE\"),av(\"WN\")],\n]\na = np.array(a)\nprint(\"AFTER\")",
        "detail": "src.gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "src.gym_maze.envs.my_maze_generator",
        "description": "src.gym_maze.envs.my_maze_generator",
        "peekOfCode": "a = [\n    [av(\"ES\"),av(\"WE\"),av(\"WES\"),av(\"WE\"),av(\"WS\")],\n    [av(\"NS\"),av(\"\"),    av(\"NS\"),  av(\"\"), av(\"NS\")],\n    [av(\"NES\"),av(\"WE\"),av(\"NEWS\"),av(\"WE\"),av(\"NWS\")],\n    [av(\"NS\"),av(\"\"),av(\"NS\"),av(\"\"),av(\"NS\")],\n    [av(\"NE\"),av(\"WE\"),av(\"WEN\"),av(\"WE\"),av(\"WN\")],\n]\na = np.array(a)\nprint(\"AFTER\")\nprint(a)",
        "detail": "src.gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "src.gym_maze.envs.my_maze_generator",
        "description": "src.gym_maze.envs.my_maze_generator",
        "peekOfCode": "a = np.array(a)\nprint(\"AFTER\")\nprint(a)\nprint(actions_to_value(\"NEWS\"),actions_to_value(\"\"))\nnp.save(\"gym_maze/envs/maze_samples/maze2d_001.npy\",a)\nNROWS = 43\nNCOLS = 43\nOBS_BLOCKS = 6\n# Each block can be considered 20m x 20m \ndef cell_value(r,c,obs_blocks=1,street_blocks=1):",
        "detail": "src.gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "NROWS",
        "kind": 5,
        "importPath": "src.gym_maze.envs.my_maze_generator",
        "description": "src.gym_maze.envs.my_maze_generator",
        "peekOfCode": "NROWS = 43\nNCOLS = 43\nOBS_BLOCKS = 6\n# Each block can be considered 20m x 20m \ndef cell_value(r,c,obs_blocks=1,street_blocks=1):\n    if(obs_blocks ==1):\n        if r %2 ==0 or c %2 ==0:\n            return 15\n        elif r != 0 and c !=0 and r != NROWS -1 and c != NCOLS -1 :\n            return 0",
        "detail": "src.gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "NCOLS",
        "kind": 5,
        "importPath": "src.gym_maze.envs.my_maze_generator",
        "description": "src.gym_maze.envs.my_maze_generator",
        "peekOfCode": "NCOLS = 43\nOBS_BLOCKS = 6\n# Each block can be considered 20m x 20m \ndef cell_value(r,c,obs_blocks=1,street_blocks=1):\n    if(obs_blocks ==1):\n        if r %2 ==0 or c %2 ==0:\n            return 15\n        elif r != 0 and c !=0 and r != NROWS -1 and c != NCOLS -1 :\n            return 0\n        else:",
        "detail": "src.gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "OBS_BLOCKS",
        "kind": 5,
        "importPath": "src.gym_maze.envs.my_maze_generator",
        "description": "src.gym_maze.envs.my_maze_generator",
        "peekOfCode": "OBS_BLOCKS = 6\n# Each block can be considered 20m x 20m \ndef cell_value(r,c,obs_blocks=1,street_blocks=1):\n    if(obs_blocks ==1):\n        if r %2 ==0 or c %2 ==0:\n            return 15\n        elif r != 0 and c !=0 and r != NROWS -1 and c != NCOLS -1 :\n            return 0\n        else:\n            return 15",
        "detail": "src.gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "aa",
        "kind": 5,
        "importPath": "src.gym_maze.envs.my_maze_generator",
        "description": "src.gym_maze.envs.my_maze_generator",
        "peekOfCode": "aa = [ [cell_value(r,c,obs_blocks=OBS_BLOCKS) for c in range(NCOLS) ] for r in range(NROWS)]\naa = np.array(aa)\nprint('aa BEF: \\n', aa)  \nfor r in range(len(aa)):\n    for c in range( len(aa[0] )):\n        cell = aa[r,c]\n        if r -1 < 0 or  aa[r-1,c] == 0:\n            cell = remove_action( cell,\"N\") \n        if r+1 >= len(aa) or aa[r+1,c] == 0:\n            cell = remove_action( cell,\"S\") ",
        "detail": "src.gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "aa",
        "kind": 5,
        "importPath": "src.gym_maze.envs.my_maze_generator",
        "description": "src.gym_maze.envs.my_maze_generator",
        "peekOfCode": "aa = np.array(aa)\nprint('aa BEF: \\n', aa)  \nfor r in range(len(aa)):\n    for c in range( len(aa[0] )):\n        cell = aa[r,c]\n        if r -1 < 0 or  aa[r-1,c] == 0:\n            cell = remove_action( cell,\"N\") \n        if r+1 >= len(aa) or aa[r+1,c] == 0:\n            cell = remove_action( cell,\"S\") \n        if c -1 < 0 or  aa[r,c-1] == 0:",
        "detail": "src.gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "src.Other.InterpolateCompare",
        "description": "src.Other.InterpolateCompare",
        "peekOfCode": "df = pd.read_csv( \"C:/Users/gioca/Desktop/Repos/AirSim-PredictiveManteinance/src/final/generatedData/2dL1/qTrajs2D-D-10-01-2021-H-11-44-22-/traj2d_0.csv\" ,\ndelimiter=\",\",index_col=\"index\")\n            # print(df)\nt=df.to_numpy() \ntt=t.tolist()\ntrajs_utils.plot_xy([ [ [p[0],p[1],10]for p in tt] ],cell_size=1,doScatter=True,isCell=True)\ntt2=trajs_utils.fix_traj([tt])\nprint('tt2: ', tt2)\ntrajs_utils.plot_xy([     [ [p[0],p[1],10] for p in tt2[0]] ] ,cell_size=1,doScatter=True  ,isCell=True )\n# 2d int",
        "detail": "src.Other.InterpolateCompare",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "src.Other.InterpolateCompare",
        "description": "src.Other.InterpolateCompare",
        "peekOfCode": "df = pd.read_csv( \"generatedData/3dL2/csv/trajs3D-D-10-01-2021-H-11-44-22-/3dtraj0.csv\" ,\ndelimiter=\",\",index_col=\"index\")\n            # print(df)\nt=df.to_numpy() \ntt=t.tolist()\ntrajs_utils.plot_xy([tt],cell_size=20,dotSize=0.5,doScatter=True)\n# trajs_utils.plot_3d([ [ [p[0],p[1],10]for p in tt] ])",
        "detail": "src.Other.InterpolateCompare",
        "documentation": {}
    },
    {
        "label": "strDate",
        "kind": 2,
        "importPath": "src.Other.randomGenerator",
        "description": "src.Other.randomGenerator",
        "peekOfCode": "def strDate():\n    return str(datetime.datetime.now().strftime('-D-%d-%m-%Y-H-%H-%M-%S-') )\nEXPERIMENT_DATE =  strDate()\na_logger.debug(\n   \"\\nRUNNING EXP at: \" + EXPERIMENT_DATE +\"\\n\"\n)\n# RANDOM SEED\n# a_logger.debug(\"SEED: \"+ str(trajs_utils.setRandomSeed())  )\na_logger.debug(\"SEED: \"+ str(trajs_utils.setSeed(999))  )\nNUM_TESTS = 1",
        "detail": "src.Other.randomGenerator",
        "documentation": {}
    },
    {
        "label": "a_logger",
        "kind": 5,
        "importPath": "src.Other.randomGenerator",
        "description": "src.Other.randomGenerator",
        "peekOfCode": "a_logger = logging.getLogger(\"collisionTesterLog\")\na_logger.setLevel(logging.DEBUG)\noutput_file_handler = logging.FileHandler(\"RandomGeneration.log\")\nstdout_handler = logging.StreamHandler(sys.stdout)\na_logger.addHandler(output_file_handler)\na_logger.addHandler(stdout_handler)\ndef strDate():\n    return str(datetime.datetime.now().strftime('-D-%d-%m-%Y-H-%H-%M-%S-') )\nEXPERIMENT_DATE =  strDate()\na_logger.debug(",
        "detail": "src.Other.randomGenerator",
        "documentation": {}
    },
    {
        "label": "output_file_handler",
        "kind": 5,
        "importPath": "src.Other.randomGenerator",
        "description": "src.Other.randomGenerator",
        "peekOfCode": "output_file_handler = logging.FileHandler(\"RandomGeneration.log\")\nstdout_handler = logging.StreamHandler(sys.stdout)\na_logger.addHandler(output_file_handler)\na_logger.addHandler(stdout_handler)\ndef strDate():\n    return str(datetime.datetime.now().strftime('-D-%d-%m-%Y-H-%H-%M-%S-') )\nEXPERIMENT_DATE =  strDate()\na_logger.debug(\n   \"\\nRUNNING EXP at: \" + EXPERIMENT_DATE +\"\\n\"\n)",
        "detail": "src.Other.randomGenerator",
        "documentation": {}
    },
    {
        "label": "stdout_handler",
        "kind": 5,
        "importPath": "src.Other.randomGenerator",
        "description": "src.Other.randomGenerator",
        "peekOfCode": "stdout_handler = logging.StreamHandler(sys.stdout)\na_logger.addHandler(output_file_handler)\na_logger.addHandler(stdout_handler)\ndef strDate():\n    return str(datetime.datetime.now().strftime('-D-%d-%m-%Y-H-%H-%M-%S-') )\nEXPERIMENT_DATE =  strDate()\na_logger.debug(\n   \"\\nRUNNING EXP at: \" + EXPERIMENT_DATE +\"\\n\"\n)\n# RANDOM SEED",
        "detail": "src.Other.randomGenerator",
        "documentation": {}
    },
    {
        "label": "EXPERIMENT_DATE",
        "kind": 5,
        "importPath": "src.Other.randomGenerator",
        "description": "src.Other.randomGenerator",
        "peekOfCode": "EXPERIMENT_DATE =  strDate()\na_logger.debug(\n   \"\\nRUNNING EXP at: \" + EXPERIMENT_DATE +\"\\n\"\n)\n# RANDOM SEED\n# a_logger.debug(\"SEED: \"+ str(trajs_utils.setRandomSeed())  )\na_logger.debug(\"SEED: \"+ str(trajs_utils.setSeed(999))  )\nNUM_TESTS = 1\nBUFFER_SIZE=3\nOUT_FOLDER = \"generatedData/randTrajs/\"",
        "detail": "src.Other.randomGenerator",
        "documentation": {}
    },
    {
        "label": "NUM_TESTS",
        "kind": 5,
        "importPath": "src.Other.randomGenerator",
        "description": "src.Other.randomGenerator",
        "peekOfCode": "NUM_TESTS = 1\nBUFFER_SIZE=3\nOUT_FOLDER = \"generatedData/randTrajs/\"\nTOLERANCES = [0,0.0] # Vertical separation tolearance value\nNUM_TRAJECTORIES = [30,300,10,10,50,50,100,100] # numbers of trajectories (multiple for multiple tests)\nexp_path = OUT_FOLDER + \"rand\"+EXPERIMENT_DATE\ncreated = False\n\"\"\" Prepare directories \"\"\"\ni=1\nwhile(not created ):",
        "detail": "src.Other.randomGenerator",
        "documentation": {}
    },
    {
        "label": "OUT_FOLDER",
        "kind": 5,
        "importPath": "src.Other.randomGenerator",
        "description": "src.Other.randomGenerator",
        "peekOfCode": "OUT_FOLDER = \"generatedData/randTrajs/\"\nTOLERANCES = [0,0.0] # Vertical separation tolearance value\nNUM_TRAJECTORIES = [30,300,10,10,50,50,100,100] # numbers of trajectories (multiple for multiple tests)\nexp_path = OUT_FOLDER + \"rand\"+EXPERIMENT_DATE\ncreated = False\n\"\"\" Prepare directories \"\"\"\ni=1\nwhile(not created ):\n   try:\n      exp_path = exp_path[:-1]+ str(i) +\"/\"",
        "detail": "src.Other.randomGenerator",
        "documentation": {}
    },
    {
        "label": "TOLERANCES",
        "kind": 5,
        "importPath": "src.Other.randomGenerator",
        "description": "src.Other.randomGenerator",
        "peekOfCode": "TOLERANCES = [0,0.0] # Vertical separation tolearance value\nNUM_TRAJECTORIES = [30,300,10,10,50,50,100,100] # numbers of trajectories (multiple for multiple tests)\nexp_path = OUT_FOLDER + \"rand\"+EXPERIMENT_DATE\ncreated = False\n\"\"\" Prepare directories \"\"\"\ni=1\nwhile(not created ):\n   try:\n      exp_path = exp_path[:-1]+ str(i) +\"/\"\n      os.mkdir(exp_path)",
        "detail": "src.Other.randomGenerator",
        "documentation": {}
    },
    {
        "label": "NUM_TRAJECTORIES",
        "kind": 5,
        "importPath": "src.Other.randomGenerator",
        "description": "src.Other.randomGenerator",
        "peekOfCode": "NUM_TRAJECTORIES = [30,300,10,10,50,50,100,100] # numbers of trajectories (multiple for multiple tests)\nexp_path = OUT_FOLDER + \"rand\"+EXPERIMENT_DATE\ncreated = False\n\"\"\" Prepare directories \"\"\"\ni=1\nwhile(not created ):\n   try:\n      exp_path = exp_path[:-1]+ str(i) +\"/\"\n      os.mkdir(exp_path)\n      print (\"Successfully created the directory %s \" % exp_path)",
        "detail": "src.Other.randomGenerator",
        "documentation": {}
    },
    {
        "label": "exp_path",
        "kind": 5,
        "importPath": "src.Other.randomGenerator",
        "description": "src.Other.randomGenerator",
        "peekOfCode": "exp_path = OUT_FOLDER + \"rand\"+EXPERIMENT_DATE\ncreated = False\n\"\"\" Prepare directories \"\"\"\ni=1\nwhile(not created ):\n   try:\n      exp_path = exp_path[:-1]+ str(i) +\"/\"\n      os.mkdir(exp_path)\n      print (\"Successfully created the directory %s \" % exp_path)\n      created = True",
        "detail": "src.Other.randomGenerator",
        "documentation": {}
    },
    {
        "label": "created",
        "kind": 5,
        "importPath": "src.Other.randomGenerator",
        "description": "src.Other.randomGenerator",
        "peekOfCode": "created = False\n\"\"\" Prepare directories \"\"\"\ni=1\nwhile(not created ):\n   try:\n      exp_path = exp_path[:-1]+ str(i) +\"/\"\n      os.mkdir(exp_path)\n      print (\"Successfully created the directory %s \" % exp_path)\n      created = True\n   except OSError:",
        "detail": "src.Other.randomGenerator",
        "documentation": {}
    },
    {
        "label": "generate_flight_id",
        "kind": 2,
        "importPath": "src.eurocontrolConverter",
        "description": "src.eurocontrolConverter",
        "peekOfCode": "def generate_flight_id():\n    # Generate a unique ID for a flight.\n    id = uuid.uuid1()\n    flight_id = id.fields[0]\n    return flight_id\ndef flights_points( data, file_name):\n    # 'data' is an ordered list represented in this way --> [ [flights_IDs], [number_waypoints_sequence], \n    #    [crossingg_waypoints_times], [flights_levels], [Latitudes], [Longitutes] ].\n    # This method take 'data' as input and put it into a .csv file (by creating it) according to the Eurocontrol standard template.\n    header = True",
        "detail": "src.eurocontrolConverter",
        "documentation": {}
    },
    {
        "label": "flights_points",
        "kind": 2,
        "importPath": "src.eurocontrolConverter",
        "description": "src.eurocontrolConverter",
        "peekOfCode": "def flights_points( data, file_name):\n    # 'data' is an ordered list represented in this way --> [ [flights_IDs], [number_waypoints_sequence], \n    #    [crossingg_waypoints_times], [flights_levels], [Latitudes], [Longitutes] ].\n    # This method take 'data' as input and put it into a .csv file (by creating it) according to the Eurocontrol standard template.\n    header = True\n    d = {}\n    fields = len(COLUMNS_NAMES)\n    for flight in data:\n        for field in range(fields):\n            d[COLUMNS_NAMES[field]] = flight[field]",
        "detail": "src.eurocontrolConverter",
        "documentation": {}
    },
    {
        "label": "data_to_csv",
        "kind": 2,
        "importPath": "src.eurocontrolConverter",
        "description": "src.eurocontrolConverter",
        "peekOfCode": "def data_to_csv(data,filename,header=True):\n   d={}\n   fields = len(COLUMNS_NAMES)\n   for row in data:\n        for field in range(fields):\n            if COLUMNS_NAMES[field] not in d:\n               d[COLUMNS_NAMES[field]] = [row[field]]\n            else:\n               d[COLUMNS_NAMES[field]].append( row[field])\n   df = pd.DataFrame.from_dict(d)",
        "detail": "src.eurocontrolConverter",
        "documentation": {}
    },
    {
        "label": "extract_waypoints_from_flights_points_csv",
        "kind": 2,
        "importPath": "src.eurocontrolConverter",
        "description": "src.eurocontrolConverter",
        "peekOfCode": "def extract_waypoints_from_flights_points_csv( file_name):\n    # Read a .csv file (according to the Eurocontrol standard template) and return a dictionary in which each key is a flight ID and\n    # the corresponding values are the Z,Y,X coordinates of the crossed waypoints for that considered flight. \n    n_names = len(COLUMNS_NAMES)\n    file = pd.read_csv(file_name, header=0)\n    flights_and_coords = [[] for i in range(4)] # 4 = flightID + Z + Y + X\n    flights_and_coords[0] = file[COLUMNS_NAMES[0]].values\n    flights_and_coords[1] = file[COLUMNS_NAMES[3]].values\n    flights_and_coords[2] = file[COLUMNS_NAMES[4]].values\n    flights_and_coords[3] = file[COLUMNS_NAMES[5]].values",
        "detail": "src.eurocontrolConverter",
        "documentation": {}
    },
    {
        "label": "create_eurocontrol_file",
        "kind": 2,
        "importPath": "src.eurocontrolConverter",
        "description": "src.eurocontrolConverter",
        "peekOfCode": "def create_eurocontrol_file(trajs,filename,header = True):\n   if(trajs is None): raise Exception(\"Invalid input (None)\")\n   if( trajs == [] or trajs[0] is None or \n      trajs[0] == []  or trajs[0][0] is None or \n      trajs[0][0] == [] ): \n      raise Exception(\"Invalid input (No input)\")\n   dimensions = len(trajs[0][0])\n   if(dimensions <2 or dimensions >3): raise Exception(\"Only 2D or 3D, received\", dimensions)\n   offset=3\n   print(\"Found\",len(trajs),\"trajectories with dimensions of num.:\", dimensions)",
        "detail": "src.eurocontrolConverter",
        "documentation": {}
    },
    {
        "label": "FINAL_COLUMNS_NAMES",
        "kind": 5,
        "importPath": "src.eurocontrolConverter",
        "description": "src.eurocontrolConverter",
        "peekOfCode": "FINAL_COLUMNS_NAMES = ['UAS id', \n   'UAS Relative time',\n   'x',\n   'y', \n   'target angle',\n   'linear velocity', \n   'angular velocity']\nCOLUMNS_NAMES = ['ECTRL ID',\n                'Sequence Number',\n                'Time Over',",
        "detail": "src.eurocontrolConverter",
        "documentation": {}
    },
    {
        "label": "COLUMNS_NAMES",
        "kind": 5,
        "importPath": "src.eurocontrolConverter",
        "description": "src.eurocontrolConverter",
        "peekOfCode": "COLUMNS_NAMES = ['ECTRL ID',\n                'Sequence Number',\n                'Time Over',\n                'Flight Level', # Actually is Z coordinate\n                'Latitude',     # Actually is Y coordinate\n                'Longitude']    # Actually is X coordinate\n\"\"\"   OLD version\nCOLUMNS_NAMES2 = ['id',\n                'time',\n                'x',",
        "detail": "src.eurocontrolConverter",
        "documentation": {}
    },
    {
        "label": "COLUMNS_NAMES2",
        "kind": 5,
        "importPath": "src.eurocontrolConverter",
        "description": "src.eurocontrolConverter",
        "peekOfCode": "COLUMNS_NAMES2 = ['id',\n                'time',\n                'x',\n                'y', \n                'z',     \n               #  'th', #NA\n               #  \"tv\", #NA\n               #  \"rv\", #NA\n               ] \n\"\"\"",
        "detail": "src.eurocontrolConverter",
        "documentation": {}
    },
    {
        "label": "FILE_DIR",
        "kind": 5,
        "importPath": "src.eurocontrolConverter",
        "description": "src.eurocontrolConverter",
        "peekOfCode": "FILE_DIR = \"eurocontrol/\"\ndef generate_flight_id():\n    # Generate a unique ID for a flight.\n    id = uuid.uuid1()\n    flight_id = id.fields[0]\n    return flight_id\ndef flights_points( data, file_name):\n    # 'data' is an ordered list represented in this way --> [ [flights_IDs], [number_waypoints_sequence], \n    #    [crossingg_waypoints_times], [flights_levels], [Latitudes], [Longitutes] ].\n    # This method take 'data' as input and put it into a .csv file (by creating it) according to the Eurocontrol standard template.",
        "detail": "src.eurocontrolConverter",
        "documentation": {}
    },
    {
        "label": "getNotWallsCells",
        "kind": 2,
        "importPath": "src.layer1",
        "description": "src.layer1",
        "peekOfCode": "def getNotWallsCells():\n    goodCells = []\n    for r in range(c_settings[\"NROWS\"]):\n        for c in range(c_settings[\"NCOLS\"]):\n            if( r % 7==0 or c % 7==0):\n                goodCells.append([r,c])\n    return goodCells\ndef select_action(state, explore_rate):\n   # Select a random action\n   if random.random() < explore_rate:",
        "detail": "src.layer1",
        "documentation": {}
    },
    {
        "label": "select_action",
        "kind": 2,
        "importPath": "src.layer1",
        "description": "src.layer1",
        "peekOfCode": "def select_action(state, explore_rate):\n   # Select a random action\n   if random.random() < explore_rate:\n         action = env.action_space.sample()\n   # Select the action with the highest q\n   else:\n         action = int(np.argmax(q_table[state]))\n   return action\ndef get_explore_rate(t):\n   return max(c_settings[\"MIN_EXPLORE_RATE\"], min(0.8, 1.0 - math.log10((t+1)/DECAY_FACTOR)))",
        "detail": "src.layer1",
        "documentation": {}
    },
    {
        "label": "get_explore_rate",
        "kind": 2,
        "importPath": "src.layer1",
        "description": "src.layer1",
        "peekOfCode": "def get_explore_rate(t):\n   return max(c_settings[\"MIN_EXPLORE_RATE\"], min(0.8, 1.0 - math.log10((t+1)/DECAY_FACTOR)))\ndef get_learning_rate(t):\n   return max(c_settings[\"MIN_LEARNING_RATE\"], min(0.8, 1.0 - math.log10((t+1)/DECAY_FACTOR)))\ndef state_to_bucket(state):\n   bucket_indice = []\n   for i in range(len(state)):\n         if state[i] <= STATE_BOUNDS[i][0]:\n            bucket_index = 0\n         elif state[i] >= STATE_BOUNDS[i][1]:",
        "detail": "src.layer1",
        "documentation": {}
    },
    {
        "label": "get_learning_rate",
        "kind": 2,
        "importPath": "src.layer1",
        "description": "src.layer1",
        "peekOfCode": "def get_learning_rate(t):\n   return max(c_settings[\"MIN_LEARNING_RATE\"], min(0.8, 1.0 - math.log10((t+1)/DECAY_FACTOR)))\ndef state_to_bucket(state):\n   bucket_indice = []\n   for i in range(len(state)):\n         if state[i] <= STATE_BOUNDS[i][0]:\n            bucket_index = 0\n         elif state[i] >= STATE_BOUNDS[i][1]:\n            bucket_index = NUM_BUCKETS[i] - 1\n         else:",
        "detail": "src.layer1",
        "documentation": {}
    },
    {
        "label": "state_to_bucket",
        "kind": 2,
        "importPath": "src.layer1",
        "description": "src.layer1",
        "peekOfCode": "def state_to_bucket(state):\n   bucket_indice = []\n   for i in range(len(state)):\n         if state[i] <= STATE_BOUNDS[i][0]:\n            bucket_index = 0\n         elif state[i] >= STATE_BOUNDS[i][1]:\n            bucket_index = NUM_BUCKETS[i] - 1\n         else:\n            # Mapping the state bounds to the bucket array\n            bound_width = STATE_BOUNDS[i][1] - STATE_BOUNDS[i][0]",
        "detail": "src.layer1",
        "documentation": {}
    },
    {
        "label": "signal_handler",
        "kind": 2,
        "importPath": "src.layer1",
        "description": "src.layer1",
        "peekOfCode": "def signal_handler(sig, frame):\n   print('You pressed Ctrl+C!\\nSaving...')\n   if(not args.load_qtable):\n         print(\"ENDING OF TRAIN\")\n         np.save(\"generatedData/qTable/q_table_\"+EXPERIMENT_DATE, q_table )\n         print(\"Table saved\")\n   sys.exit(0)\nif __name__ == \"__main__\":\n   parser = argparse.ArgumentParser(description='Layer 1')\n   parser.add_argument('--nepisodes', type=int, default=100,",
        "detail": "src.layer1",
        "documentation": {}
    },
    {
        "label": "configYml",
        "kind": 5,
        "importPath": "src.layer1",
        "description": "src.layer1",
        "peekOfCode": "configYml = utils.read_yaml(\"inputData/config.yaml\")\nc_paths = configYml[\"layer1\"][\"paths\"]\nc_settings = configYml[\"layer1\"][\"settings\"]\nIDX_TO_ACTION =  {0:\"LEFT\", 1:\"FRONT\", 2:\"RIGHT\", 3:\"BACK\"}\nSEED = random.randint(0,int(10e6))\nEXPERIMENT_DATE =  str(datetime.datetime.now().strftime('-D-%d-%m-%Y-H-%H-%M-%S-') ) # To be used in log and prints\ndef getNotWallsCells():\n    goodCells = []\n    for r in range(c_settings[\"NROWS\"]):\n        for c in range(c_settings[\"NCOLS\"]):",
        "detail": "src.layer1",
        "documentation": {}
    },
    {
        "label": "c_paths",
        "kind": 5,
        "importPath": "src.layer1",
        "description": "src.layer1",
        "peekOfCode": "c_paths = configYml[\"layer1\"][\"paths\"]\nc_settings = configYml[\"layer1\"][\"settings\"]\nIDX_TO_ACTION =  {0:\"LEFT\", 1:\"FRONT\", 2:\"RIGHT\", 3:\"BACK\"}\nSEED = random.randint(0,int(10e6))\nEXPERIMENT_DATE =  str(datetime.datetime.now().strftime('-D-%d-%m-%Y-H-%H-%M-%S-') ) # To be used in log and prints\ndef getNotWallsCells():\n    goodCells = []\n    for r in range(c_settings[\"NROWS\"]):\n        for c in range(c_settings[\"NCOLS\"]):\n            if( r % 7==0 or c % 7==0):",
        "detail": "src.layer1",
        "documentation": {}
    },
    {
        "label": "c_settings",
        "kind": 5,
        "importPath": "src.layer1",
        "description": "src.layer1",
        "peekOfCode": "c_settings = configYml[\"layer1\"][\"settings\"]\nIDX_TO_ACTION =  {0:\"LEFT\", 1:\"FRONT\", 2:\"RIGHT\", 3:\"BACK\"}\nSEED = random.randint(0,int(10e6))\nEXPERIMENT_DATE =  str(datetime.datetime.now().strftime('-D-%d-%m-%Y-H-%H-%M-%S-') ) # To be used in log and prints\ndef getNotWallsCells():\n    goodCells = []\n    for r in range(c_settings[\"NROWS\"]):\n        for c in range(c_settings[\"NCOLS\"]):\n            if( r % 7==0 or c % 7==0):\n                goodCells.append([r,c])",
        "detail": "src.layer1",
        "documentation": {}
    },
    {
        "label": "IDX_TO_ACTION",
        "kind": 5,
        "importPath": "src.layer1",
        "description": "src.layer1",
        "peekOfCode": "IDX_TO_ACTION =  {0:\"LEFT\", 1:\"FRONT\", 2:\"RIGHT\", 3:\"BACK\"}\nSEED = random.randint(0,int(10e6))\nEXPERIMENT_DATE =  str(datetime.datetime.now().strftime('-D-%d-%m-%Y-H-%H-%M-%S-') ) # To be used in log and prints\ndef getNotWallsCells():\n    goodCells = []\n    for r in range(c_settings[\"NROWS\"]):\n        for c in range(c_settings[\"NCOLS\"]):\n            if( r % 7==0 or c % 7==0):\n                goodCells.append([r,c])\n    return goodCells",
        "detail": "src.layer1",
        "documentation": {}
    },
    {
        "label": "SEED",
        "kind": 5,
        "importPath": "src.layer1",
        "description": "src.layer1",
        "peekOfCode": "SEED = random.randint(0,int(10e6))\nEXPERIMENT_DATE =  str(datetime.datetime.now().strftime('-D-%d-%m-%Y-H-%H-%M-%S-') ) # To be used in log and prints\ndef getNotWallsCells():\n    goodCells = []\n    for r in range(c_settings[\"NROWS\"]):\n        for c in range(c_settings[\"NCOLS\"]):\n            if( r % 7==0 or c % 7==0):\n                goodCells.append([r,c])\n    return goodCells\ndef select_action(state, explore_rate):",
        "detail": "src.layer1",
        "documentation": {}
    },
    {
        "label": "EXPERIMENT_DATE",
        "kind": 5,
        "importPath": "src.layer1",
        "description": "src.layer1",
        "peekOfCode": "EXPERIMENT_DATE =  str(datetime.datetime.now().strftime('-D-%d-%m-%Y-H-%H-%M-%S-') ) # To be used in log and prints\ndef getNotWallsCells():\n    goodCells = []\n    for r in range(c_settings[\"NROWS\"]):\n        for c in range(c_settings[\"NCOLS\"]):\n            if( r % 7==0 or c % 7==0):\n                goodCells.append([r,c])\n    return goodCells\ndef select_action(state, explore_rate):\n   # Select a random action",
        "detail": "src.layer1",
        "documentation": {}
    },
    {
        "label": "TRAJECTORIES_3D_FOLDER",
        "kind": 5,
        "importPath": "src.layer2",
        "description": "src.layer2",
        "peekOfCode": "TRAJECTORIES_3D_FOLDER = \"generatedData/3dL2/csv/\"\n# if(args.debug):\nlogging.basicConfig(filename=utils.LOG_FOLDER+\"L2log(AIRSIM)\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M'))+\".txt\",\n                        filemode='w',\n                        format='%(asctime)s,%(msecs)d %(name)s %(levelname)s %(message)s',\n                        datefmt='%H:%M:%S',\n                        level=logging.INFO)\nlogger = logging.getLogger('RL Layer2')\nlogger.info('Experiment Date: {}'.format(datetime.datetime.now().strftime('%Y-%m-%d  %H:%M') ) )\nif __name__ == \"__main__\":",
        "detail": "src.layer2",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.layer2",
        "description": "src.layer2",
        "peekOfCode": "logger = logging.getLogger('RL Layer2')\nlogger.info('Experiment Date: {}'.format(datetime.datetime.now().strftime('%Y-%m-%d  %H:%M') ) )\nif __name__ == \"__main__\":\n   parser = argparse.ArgumentParser(description='Layer 2')\n   parser.add_argument(\"-i\", type=str,required=False,\n                     help='input folder of trajs 3d')\n   # parser.add_argument('-sx', type=int,required=True,\n   #                   help='Starting x coordinate of agent to choose correct trajectory to follow')\n   # parser.add_argument('-sy', type=int,required=True,\n   #                   help='Starting y coordinate of agent to choose correct trajectory to follow')",
        "detail": "src.layer2",
        "documentation": {}
    },
    {
        "label": "TRAJECTORIES_3D_FOLDER",
        "kind": 5,
        "importPath": "src.layer3",
        "description": "src.layer3",
        "peekOfCode": "TRAJECTORIES_3D_FOLDER = \"generatedData/3dL3/csv/\"\n# if(args.debug):\nlogging.basicConfig(filename=utils.LOG_FOLDER+\"L3log(AIRSIM)\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M'))+\".txt\",\n                        filemode='w',\n                        format='%(asctime)s,%(msecs)d %(name)s %(levelname)s %(message)s',\n                        datefmt='%H:%M:%S',\n                        level=logging.INFO)\nlogger = logging.getLogger('RL Layer3')\nlogger.info('Experiment Date: {}'.format(datetime.datetime.now().strftime('%Y-%m-%d  %H:%M') ) )\nif __name__ == \"__main__\":",
        "detail": "src.layer3",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.layer3",
        "description": "src.layer3",
        "peekOfCode": "logger = logging.getLogger('RL Layer3')\nlogger.info('Experiment Date: {}'.format(datetime.datetime.now().strftime('%Y-%m-%d  %H:%M') ) )\nif __name__ == \"__main__\":\n   parser = argparse.ArgumentParser(description='Layer 3')\n   parser.add_argument(\"-i\", type=str,required=True,\n                     help='input folder of trajs 3d')\n   # parser.add_argument('-sx', type=int,required=True,\n   #                   help='Starting x coordinate of agent to choose correct trajectory to follow')\n   # parser.add_argument('-sy', type=int,required=True,\n   #                   help='Starting y coordinate of agent to choose correct trajectory to follow')",
        "detail": "src.layer3",
        "documentation": {}
    },
    {
        "label": "setSeed",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def setSeed(seed):\n   global SEED\n   SEED=seed\n   random.seed(SEED)\n   np.random.seed(seed=SEED)\ndef setRandomSeed():\n    s = random.randint(0,int(10e8))\n    setSeed(s)\n    return SEED\ndef checkTrajsCorrectness(trajs,dimensions=2):",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "setRandomSeed",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def setRandomSeed():\n    s = random.randint(0,int(10e8))\n    setSeed(s)\n    return SEED\ndef checkTrajsCorrectness(trajs,dimensions=2):\n    assert(trajs); assert(trajs[0]); assert(trajs[0][0]); \n    for t in trajs:\n        for p in t: \n            assert(len(p)==2) \ndef fromCellsToMeters(trajs,scale_factor):",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "checkTrajsCorrectness",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def checkTrajsCorrectness(trajs,dimensions=2):\n    assert(trajs); assert(trajs[0]); assert(trajs[0][0]); \n    for t in trajs:\n        for p in t: \n            assert(len(p)==2) \ndef fromCellsToMeters(trajs,scale_factor):\n    assert(trajs); assert(trajs[0]); assert(trajs[0][0]); assert(len(trajs[0][0])==2) \n    return [ [ [ scale_factor/2+ p[0]*scale_factor, scale_factor/2+ p[1]*scale_factor] for p in traj] for traj in trajs]\ndef myInterpolate2D(trajs,step_size=20 ):\n    n_collisions = []",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "fromCellsToMeters",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def fromCellsToMeters(trajs,scale_factor):\n    assert(trajs); assert(trajs[0]); assert(trajs[0][0]); assert(len(trajs[0][0])==2) \n    return [ [ [ scale_factor/2+ p[0]*scale_factor, scale_factor/2+ p[1]*scale_factor] for p in traj] for traj in trajs]\ndef myInterpolate2D(trajs,step_size=20 ):\n    n_collisions = []\n    for arr in trajs:\n        res_t = []\n        for i,p in enumerate(arr):\n            if(i+1 >= len(arr)):\n                break",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "myInterpolate2D",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def myInterpolate2D(trajs,step_size=20 ):\n    n_collisions = []\n    for arr in trajs:\n        res_t = []\n        for i,p in enumerate(arr):\n            if(i+1 >= len(arr)):\n                break\n            x1,y1 = p[0], p[1]\n            x2,y2 = arr[i+1][0], arr[i+1][1] \n            # if(i==0):",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "build_trees",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def build_trees(trajectories):\n    _trees = []\n    for traj in trajectories:\n        _trees.append(KDTree(np.array(traj)))\n    return _trees\ndef build_tree_dict(trajectories,fixed_h = None):\n    if(trajectories is None or trajectories==[]):\n        return {},{}\n    _trees = dict()\n    _tree_by_id = dict()",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "build_tree_dict",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def build_tree_dict(trajectories,fixed_h = None):\n    if(trajectories is None or trajectories==[]):\n        return {},{}\n    _trees = dict()\n    _tree_by_id = dict()\n    dimensions = len(trajectories[0][0])\n    for idx,traj in enumerate(trajectories):\n        arr2d = np.array( traj )\n        if(dimensions==3):\n            arr2d = np.delete( arr2d ,np.s_[2:3], axis=1)",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "check_trees_collision",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def check_trees_collision(fId,point,trees,radius):\n    n_collisions = 0\n    for idx,_tree in enumerate(trees): \n        if(idx == fId):\n            # E' quella attuale\n            continue\n        n_collisions = _tree.query_radius( [point],r=radius,count_only = True )\n        if(n_collisions > 0):\n            return n_collisions\n    return n_collisions",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "complex_avoid_collision_in_busy_space",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def complex_avoid_collision_in_busy_space(trajs_2d,assigned_trajs,min_height,max_height,\n    sep_h,min_safe_points,radius=30,simpleMode=True):\n    print(\"Started col avoidance in busy space...\")\n    # First remove the points not interesting by height constraints\n    assigned_points = []\n    for traj in assigned_trajs:\n        for p in traj:\n            if min_height<=p[2]<=max_height : assigned_points.append(p)\n    zs = [[] for t in range(len(trajs_2d))]\n    trajs_3d =   []",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "avoid_collision_in_busy_space",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def avoid_collision_in_busy_space(trajs_2d,assigned_trajs,min_height,max_height,\n    sep_h,min_safe_points,radius=30,simpleMode=True,n_pool_traj=3):\n    '''\n    - trajectories are [[p11,p12,...],[p21,p22,...],...]\n      pij is a point j-th in 2d: [x,y]  for i-th flight\n    - read only assigned_trajs are [[p11,p12,...],[p21,p22,...],...]\n      pij is a point j-th in 3d: [x,y,z]  for i-th flight (they are assumed to be generated compatible with this algo)\n    - trees are built using build_trees function, they are k-d trees \n    - max_height,min_height are bounds for allocation, it starts from max and allocates towards min\n    - sep_h is the amount of height separating two trajectories with same x,y",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "vertical_separate",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def vertical_separate(new_trajs_2d,fids,min_height,max_height,\n    sep_h,assigned_trajs=[],radius=10, n_new_trajs_2d=None,seed=None,\n    tolerance = 0):\n    \"\"\"\n    ASSUMPTIONS\n    - assigned_trajs follows this convention\n    - threshold value is the max value of problematic points before traj\n    is considered colliding \n    \"\"\"\n    print(\"Loaded\" ,len(assigned_trajs),\"fixed trajectories\")",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "print_z_head",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def print_z_head(arr):\n    print(\"heights are:\")\n    for idx,t in enumerate(arr):\n        print(\"\\t id:\",idx,\"z\",t[0][2])\nfrom scipy.stats import poisson\ndef random_gen_2d(xmin,xmax,ymin,ymax,zmin=None,zmax=None,step=120,n_points=None,n_trajs=5):\n    \"\"\"\n    normal to choose action with (mean=0,std=1)\n    \"\"\"\n    n_drones = n_trajs",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "random_gen_2d",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def random_gen_2d(xmin,xmax,ymin,ymax,zmin=None,zmax=None,step=120,n_points=None,n_trajs=5):\n    \"\"\"\n    normal to choose action with (mean=0,std=1)\n    \"\"\"\n    n_drones = n_trajs\n    trajs = [[] for i in range(n_drones)]\n    if( n_points is None):\n        n_constant = False\n    else:\n        n_constant = True",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "umb_random_gen2d",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def umb_random_gen2d(xmin,xmax,ymin,ymax,zmin=None,zmax=None,step=120,n_points=100,n_trajs=5):\n    n_drones = n_trajs\n    trajs = [[] for i in range(n_drones)]\n    for i in range(n_drones):\n        if(n_points==None):\n            n_points = random.randrange(xmin, xmax+1,1 )\n        xs = []\n        ys = []\n        if(zmin is not None and zmax is not None):\n            z_value = random.randrange(zmin, zmax+1,1 )",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "interpolate_trajs",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def interpolate_trajs(trajs,doPlot=False):\n    trajs = myInterpolate2D(trajs,step_size=STEP_SIZE)\n    if(doPlot):\n        fig = plt.figure()\n        for i in range(len(trajs)):\n            plt.plot(*zip(*trajs[i]),\"-o\")\n        plt.title(\"interpolated\" )\n        plt.show()\n    return trajs\n# def height_algo(trajs):",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "get_action",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def get_action(s0,s1):\n    x0,y0 = s0[0],s0[1]\n    x1,y1 = s1[0],s1[1]\n    if(x1 > x0): return AINDEX[\"E\"]\n    elif(x0 > x1): return AINDEX[\"W\"]\n    elif(y1 > y0): return AINDEX[\"N\"]\n    elif(y0 > y1): return AINDEX[\"S\"]\n    # else: raise Exception(\"NOT MOVED NOT ACCEPTABLE\")\n    else: return -1\ndef are_opposite_actions(a1,a2):",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "are_opposite_actions",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def are_opposite_actions(a1,a2):\n    return a1!=a2 \\\n        and ( (ACTION[a1]==\"N\" and ACTION[a2] ==\"S\") or  \n            (ACTION[a1]==\"S\" and ACTION[a2] ==\"N\") or \n            (ACTION[a1]==\"E\" and ACTION[a2] ==\"W\") or  \n            (ACTION[a1]==\"W\" and ACTION[a2] ==\"E\") )  \ndef fix_traj(trajs):\n    \"\"\"\n        Remove states going back (indecisions in agent)\n    \"\"\"",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "fix_traj",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def fix_traj(trajs):\n    \"\"\"\n        Remove states going back (indecisions in agent)\n    \"\"\"\n    for i in range(len(trajs)):\n        last_action = None\n        last_state = None\n        history = dict()\n        j=0\n        while(j < len(trajs[i]) ):",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "convert2airsim",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def convert2airsim(trajs):\n    return     [ [    [ p[0],p[1],-p[2] ]    for p in t]  for t in trajs]\n# TODO use cell_size to underestand if its  acell or not?\ndef plot_xy(trajs,cell_size,dotSize=3,fids=None,doScatter=False,doSave=False,date=\"\",isCell=False, name = None):\n    \"\"\" 2D plot of trajectories trajs = [t1,...,tn] \"\"\"\n    # Assegno altitude se 2d\n    fPerHeights = dict()\n    for i in range(len(trajs)):\n        if(len(trajs[i][0]) == 2):\n            hp=9 #dummy value",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "plot_xy",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def plot_xy(trajs,cell_size,dotSize=3,fids=None,doScatter=False,doSave=False,date=\"\",isCell=False, name = None):\n    \"\"\" 2D plot of trajectories trajs = [t1,...,tn] \"\"\"\n    # Assegno altitude se 2d\n    fPerHeights = dict()\n    for i in range(len(trajs)):\n        if(len(trajs[i][0]) == 2):\n            hp=9 #dummy value\n        else:\n            hp=trajs[i][0][2]\n        if(fids is None):",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "rotate_point_2d",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def rotate_point_2d(theta,x,y):\n    return x*math.cos(theta) - y * math.sin(theta),  x * math.sin(theta) + y * math.cos(theta)\ndef assign_dummy_z(traj,dummyZ=50):\n    return [[p[0],p[1],dummyZ] for p in traj]\ndef plot_3d(trajs,ids,also2d=False,doSave=False,name=\"\",exploded=False,date=\"\",isCell=False): \n    \"\"\" 3D plot of trajectories trajs = [t1,...,tn] \"\"\"\n    fig = plt.figure(figsize=(20,10))\n    ax = fig.gca(projection='3d')\n    ax.invert_yaxis()\n    # fig = matplotlib.pyplot.gcf()",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "assign_dummy_z",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def assign_dummy_z(traj,dummyZ=50):\n    return [[p[0],p[1],dummyZ] for p in traj]\ndef plot_3d(trajs,ids,also2d=False,doSave=False,name=\"\",exploded=False,date=\"\",isCell=False): \n    \"\"\" 3D plot of trajectories trajs = [t1,...,tn] \"\"\"\n    fig = plt.figure(figsize=(20,10))\n    ax = fig.gca(projection='3d')\n    ax.invert_yaxis()\n    # fig = matplotlib.pyplot.gcf()\n    # fig.set_size_inches(18.5, 10.5)\n    altitudes = dict()",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "plot_3d",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def plot_3d(trajs,ids,also2d=False,doSave=False,name=\"\",exploded=False,date=\"\",isCell=False): \n    \"\"\" 3D plot of trajectories trajs = [t1,...,tn] \"\"\"\n    fig = plt.figure(figsize=(20,10))\n    ax = fig.gca(projection='3d')\n    ax.invert_yaxis()\n    # fig = matplotlib.pyplot.gcf()\n    # fig.set_size_inches(18.5, 10.5)\n    altitudes = dict()\n    for i in range(len(trajs)):\n        # print(\"xs\",xs[-10:],\"ys\",ys[-10:],\"zs\",zs[-10:])",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "plot_z",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def plot_z(trajs,fids, second_axis,doSave=False,name=\"\"):\n    \"\"\" 2D plot of zs depending second_axis (z = f(second_axis)) \"\"\"\n    if not (0 <= second_axis <= 1 ): raise Exception(\"Invalid axis\")\n    fig = plt.figure(figsize=(20,10))\n    ax = fig.add_subplot(111)\n    plt.grid()\n    for i,t in enumerate( trajs ):\n        t = [ [p[second_axis],p[2]] for p in t]\n        plt.plot(*zip(* t ),\"-o\")\n        ax.text(t[0][0], t[0][1], str(fids[i]), style='italic')",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "plot_z_id",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def plot_z_id(zs):\n    \"\"\" 2D plot of zs depending on fligth id \"\"\"\n    fig = plt.figure()\n    for i in range(len(zs)):\n        z_t = [ [t,z] for t,z in enumerate(zs[i])]\n        print(z_t)\n        plt.plot(*zip(*z_t),\"-o\")\n    plt.title(\"height\" )\n    plt.show()\ndef np_remove_z(arr):",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "np_remove_z",
        "kind": 2,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "def np_remove_z(arr):\n    return np.delete( np.array( arr ),np.s_[2:3], axis=1)\nif __name__ == \"__main__\":\n    d1 = [[0,0],[1,0],[2,0],[1,0],[2,0],[1,0],[0,0],[0,1],[0,2],[0,1],[0,0],[0,1],[0,2],[0,3],[0,4]]\n    d2 = [[1,0],[2,0],[2,1],[2,2],[2,3],[1,3],[0,3],[0,4]]\n    d3 = [[4,0,1],[4,1,1],[4,2,1],[4,3,1],[3,3,1],[2,3,1],[1,3,1],[0,3,1]]\n    d4 = [[5,0,1],[5,1,1],[5,2,1],[5,3,1],[4,3,1],[3,3,1],[3,2,1],[3,1,1],[3,0,1]]\n    trajectories = [d1,d2]\n    d3 = np.array(d3)\n    d3[:,1] += 3",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "N_POINTS",
        "kind": 5,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "N_POINTS = 100\nSTEP_SIZE = 20\nACTION = [\"N\",\"S\", \"E\", \"W\"]\nAINDEX = {\"N\":0,\"S\":1, \"E\":2, \"W\":3}\nFIGS_FOLDER = \"generatedFigs\"\n# random.seed(SEED)\n# np.random.seed(seed=SEED)\ndef setSeed(seed):\n   global SEED\n   SEED=seed",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "STEP_SIZE",
        "kind": 5,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "STEP_SIZE = 20\nACTION = [\"N\",\"S\", \"E\", \"W\"]\nAINDEX = {\"N\":0,\"S\":1, \"E\":2, \"W\":3}\nFIGS_FOLDER = \"generatedFigs\"\n# random.seed(SEED)\n# np.random.seed(seed=SEED)\ndef setSeed(seed):\n   global SEED\n   SEED=seed\n   random.seed(SEED)",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "ACTION",
        "kind": 5,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "ACTION = [\"N\",\"S\", \"E\", \"W\"]\nAINDEX = {\"N\":0,\"S\":1, \"E\":2, \"W\":3}\nFIGS_FOLDER = \"generatedFigs\"\n# random.seed(SEED)\n# np.random.seed(seed=SEED)\ndef setSeed(seed):\n   global SEED\n   SEED=seed\n   random.seed(SEED)\n   np.random.seed(seed=SEED)",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "AINDEX",
        "kind": 5,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "AINDEX = {\"N\":0,\"S\":1, \"E\":2, \"W\":3}\nFIGS_FOLDER = \"generatedFigs\"\n# random.seed(SEED)\n# np.random.seed(seed=SEED)\ndef setSeed(seed):\n   global SEED\n   SEED=seed\n   random.seed(SEED)\n   np.random.seed(seed=SEED)\ndef setRandomSeed():",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "FIGS_FOLDER",
        "kind": 5,
        "importPath": "src.trajs_utils",
        "description": "src.trajs_utils",
        "peekOfCode": "FIGS_FOLDER = \"generatedFigs\"\n# random.seed(SEED)\n# np.random.seed(seed=SEED)\ndef setSeed(seed):\n   global SEED\n   SEED=seed\n   random.seed(SEED)\n   np.random.seed(seed=SEED)\ndef setRandomSeed():\n    s = random.randint(0,int(10e8))",
        "detail": "src.trajs_utils",
        "documentation": {}
    },
    {
        "label": "read_yaml",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def read_yaml(file_path):\n    with open(file_path, \"r\") as f:\n        return yaml.safe_load(f)\ndef play_audio_notification(n_beeps=3,frequency=2000,beep_duration=250):\n    for _ in range(n_beeps):\n        winsound.Beep(frequency, beep_duration)\n        time.sleep(0.1)\ndef initiate_logger():\n    logging.basicConfig(filename=LOG_FOLDER+\"log\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M'))+\".txt\",\n                                filemode='w',",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "play_audio_notification",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def play_audio_notification(n_beeps=3,frequency=2000,beep_duration=250):\n    for _ in range(n_beeps):\n        winsound.Beep(frequency, beep_duration)\n        time.sleep(0.1)\ndef initiate_logger():\n    logging.basicConfig(filename=LOG_FOLDER+\"log\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M'))+\".txt\",\n                                filemode='w',\n                                format='%(asctime)s,%(msecs)d %(name)s %(levelname)s %(message)s',\n                                datefmt='%H:%M:%S',\n                                level=logging.DEBUG)",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "initiate_logger",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def initiate_logger():\n    logging.basicConfig(filename=LOG_FOLDER+\"log\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M'))+\".txt\",\n                                filemode='w',\n                                format='%(asctime)s,%(msecs)d %(name)s %(levelname)s %(message)s',\n                                datefmt='%H:%M:%S',\n                                level=logging.DEBUG)\n    logger = logging.getLogger('multiAirGym')\n    logger.debug('Experiment Date: {}'.format(datetime.datetime.now().strftime('%Y-%m-%d  %H:%M') ) )\n    return logger\ndef ConvertIfStringIsInt(input_string):",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "ConvertIfStringIsInt",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def ConvertIfStringIsInt(input_string):\n    try:\n        float(input_string)\n        try:\n            if int(input_string) == float(input_string):\n                return int(input_string)\n            else:\n                return float(input_string)\n        except ValueError:\n            return float(input_string)",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "read_cfg",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def read_cfg(config_filename='configs/map_config.cfg', verbose=False):\n    parser = ConfigParser()\n    parser.optionxform = str\n    parser.read(config_filename)\n    cfg = DotMap()\n    if verbose:\n        hyphens = '-' * int((80 - len(config_filename))/2)\n        print(hyphens + ' ' + config_filename + ' ' + hyphens)\n    for section_name in parser.sections():\n        if verbose:",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "dronePrint",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def dronePrint(idx,s):\n    print(\"[Drone\"+str(idx)+\"]\",s)\ndef addToDict(d: dict,k,v):\n    if k not in d:\n        d[k] = []\n    d[k].append(v)\ndef pkl_save_obj(obj, name,file_timestamp ):\n    with open(TRAJECTORIES_FOLDER + name + file_timestamp + '.pkl', 'wb') as f:\n        pickle.dump(obj, f, pickle.HIGHEST_PROTOCOL)\ndef pkl_load_obj(name=None,file_timestamp=None,filename=None):",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "addToDict",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def addToDict(d: dict,k,v):\n    if k not in d:\n        d[k] = []\n    d[k].append(v)\ndef pkl_save_obj(obj, name,file_timestamp ):\n    with open(TRAJECTORIES_FOLDER + name + file_timestamp + '.pkl', 'wb') as f:\n        pickle.dump(obj, f, pickle.HIGHEST_PROTOCOL)\ndef pkl_load_obj(name=None,file_timestamp=None,filename=None):\n    if filename:\n        with open(TRAJECTORIES_FOLDER +filename, 'rb') as f:",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "pkl_save_obj",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def pkl_save_obj(obj, name,file_timestamp ):\n    with open(TRAJECTORIES_FOLDER + name + file_timestamp + '.pkl', 'wb') as f:\n        pickle.dump(obj, f, pickle.HIGHEST_PROTOCOL)\ndef pkl_load_obj(name=None,file_timestamp=None,filename=None):\n    if filename:\n        with open(TRAJECTORIES_FOLDER +filename, 'rb') as f:\n            return pickle.load(f)\n    elif name and file_timestamp:\n        with open(TRAJECTORIES_FOLDER + name + file_timestamp+ '.pkl', 'rb') as f:\n            return pickle.load(f)",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "pkl_load_obj",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def pkl_load_obj(name=None,file_timestamp=None,filename=None):\n    if filename:\n        with open(TRAJECTORIES_FOLDER +filename, 'rb') as f:\n            return pickle.load(f)\n    elif name and file_timestamp:\n        with open(TRAJECTORIES_FOLDER + name + file_timestamp+ '.pkl', 'rb') as f:\n            return pickle.load(f)\n    else:\n        raise Exception(\"Specify file name\")\ndef numpy_save(arr,folder_timestamp,filename):",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "numpy_save",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def numpy_save(arr,folder_timestamp,filename):\n    file_path = TRAJECTORIES_FOLDER+\"trajectories_\"+folder_timestamp\n    if not os.path.exists(file_path):\n        os.makedirs(file_path)\n    data = np.asarray(arr)\n    # save to npy file\n    print(\"Saving\",os.path.join(file_path, filename))\n    np.save(os.path.join(file_path, filename) , data)\ndef position_to_list(position_vector) -> list:\n    return [position_vector.x_val, position_vector.y_val, position_vector.z_val]",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "position_to_list",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def position_to_list(position_vector) -> list:\n    return [position_vector.x_val, position_vector.y_val, position_vector.z_val]\ndef list_to_position(l,wcell_in_meters=2,hcell_in_meters=2) -> Vector3r:\n    # x = int(l[0]*wcell_in_meters)\n    # y = int(l[1]*hcell_in_meters)\n    x = int(l[0]*wcell_in_meters)\n    y = int(l[1]*hcell_in_meters)\n    if(len(l)>2):\n        z = int(l[2])\n    else:",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "list_to_position",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def list_to_position(l,wcell_in_meters=2,hcell_in_meters=2) -> Vector3r:\n    # x = int(l[0]*wcell_in_meters)\n    # y = int(l[1]*hcell_in_meters)\n    x = int(l[0]*wcell_in_meters)\n    y = int(l[1]*hcell_in_meters)\n    if(len(l)>2):\n        z = int(l[2])\n    else:\n        z = -50\n    # if len(l) != 3:",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "l3_list_to_position",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def l3_list_to_position(l,wcell_in_meters=20,hcell_in_meters=20) -> Vector3r:\n    # x = int(l[0]*wcell_in_meters)\n    # y = int(l[1]*hcell_in_meters)\n    x = int(l[0])\n    y = int(l[1])\n    z = int(l[2])\n    if len(l) != 3:\n        raise Exception(\"REQUIRED EXACTLY 3 elements\")\n    return Vector3r(x,y,z)\ndef set_offset_position(pos):",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "set_offset_position",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def set_offset_position(pos):\n    _v = g_vehicles[\"Drone0\"]\n    _offset_x = _v[\"X\"] \n    _offset_y = _v[\"Y\"]\n    _offset_z = _v[\"Z\"]\n    pos.x_val += _offset_x\n    pos.y_val += _offset_y\n    pos.z_val += _offset_z\ndef _colorize(idx): \n    if idx == 0:",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "xy_distance",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def xy_distance(point1, point2):\n    if type(point1) == Vector3r:\n        point1 = [point1.x_val,point1.y_val] \n    if type(point2) == Vector3r:\n        point2 = [point2.x_val,point2.y_val] \n    return   np.linalg.norm(point1 - point2) \ndef myInterpolate(arr, n_samples=10 ):\n    res = []\n    for i,p in enumerate(arr):\n        if(i+1 >= len(arr)):",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "myInterpolate",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def myInterpolate(arr, n_samples=10 ):\n    res = []\n    for i,p in enumerate(arr):\n        if(i+1 >= len(arr)):\n            break\n        x1,y1,z1 = p[0], p[1], p[2]\n        x2,y2,z2 = arr[i+1][0], arr[i+1][1], arr[i+1][2] \n        step_length = max(abs(x2-x1),abs(y2-y1)) / n_samples\n        for i in range(n_samples):\n            if(x2 > x1):",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "myInterpolate2D",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def myInterpolate2D(trajs, n_samples=10,step_size=20 ):\n    res = []\n    for arr in trajs:\n        res_t = []\n        for i,p in enumerate(arr):\n            if(i+1 >= len(arr)):\n                break\n            x1,y1 = p[0], p[1]\n            x2,y2 = arr[i+1][0], arr[i+1][1] \n            # if(i==0):",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "build_trees",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def build_trees(trajectories):\n    _trees = []\n    for traj in trajectories:\n        _trees.append(KDTree(np.array(traj)))\n    return _trees\ndef avoid_collision(trajectories,trees,min_height,max_height,\n    sep_h,min_safe_points,radius=30,simpleMode=True):\n    Tmax = max([len(traj) for traj in trajectories])\n    drones = range(len(trajectories))\n    points = {}",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "avoid_collision",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def avoid_collision(trajectories,trees,min_height,max_height,\n    sep_h,min_safe_points,radius=30,simpleMode=True):\n    Tmax = max([len(traj) for traj in trajectories])\n    drones = range(len(trajectories))\n    points = {}\n    zs=[[] for d in drones] \n    trajs_3d =[[] for d in drones] \n    colliding_trajs = dict()\n    for d in drones:\n        for t in range(len(trajectories[d])):",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "lonLatFromRotation",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def lonLatFromRotation(theta,phi,r_lon,r_lat):\n    lon = math.atan2( math.sin(r_lon), math.tan(r_lat)* math.sin(theta) + math.cos(r_lon)* math.cos(theta)) - phi\n    lat = math.asin( math.cos(theta) * math.sin(r_lat) - math.cos(r_lon) * math.sin(theta) * math.cos(r_lat) )\n    return lon,lat\nif __name__==\"__main__\":\n    lon,lat=2.1833298597595303, 41.409602234016496\n    print(lonLatFromRotation(-5.41052,0,lon,lat))    \n    res1,res2 = 2.179982, 41.403179",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "AIRSIM_SETTINGS_FOLDER",
        "kind": 5,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "AIRSIM_SETTINGS_FOLDER = 'C:/Users/gioca/OneDrive/Documents/Airsim/'\nCONFIGS_FOLDER = \"./configs/\"\nLOG_FOLDER = \"./generatedData/logs/\"\nTRAJECTORIES_FOLDER = \"./qtrajectories/\"\nwith open(AIRSIM_SETTINGS_FOLDER + 'settings.json', 'r') as jsonFile:\n    g_airsim_settings = json.load(jsonFile)\ng_vehicles = g_airsim_settings[\"Vehicles\"]\ng_config = ConfigParser()\ng_config.read(CONFIGS_FOLDER + 'config.ini')\n\"\"\"",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "CONFIGS_FOLDER",
        "kind": 5,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "CONFIGS_FOLDER = \"./configs/\"\nLOG_FOLDER = \"./generatedData/logs/\"\nTRAJECTORIES_FOLDER = \"./qtrajectories/\"\nwith open(AIRSIM_SETTINGS_FOLDER + 'settings.json', 'r') as jsonFile:\n    g_airsim_settings = json.load(jsonFile)\ng_vehicles = g_airsim_settings[\"Vehicles\"]\ng_config = ConfigParser()\ng_config.read(CONFIGS_FOLDER + 'config.ini')\n\"\"\"\n       Assumes that the simulation environment (unreal) is in the coordinate system specified",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "LOG_FOLDER",
        "kind": 5,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "LOG_FOLDER = \"./generatedData/logs/\"\nTRAJECTORIES_FOLDER = \"./qtrajectories/\"\nwith open(AIRSIM_SETTINGS_FOLDER + 'settings.json', 'r') as jsonFile:\n    g_airsim_settings = json.load(jsonFile)\ng_vehicles = g_airsim_settings[\"Vehicles\"]\ng_config = ConfigParser()\ng_config.read(CONFIGS_FOLDER + 'config.ini')\n\"\"\"\n       Assumes that the simulation environment (unreal) is in the coordinate system specified\n        by the srid but offset by the origin specified.",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "TRAJECTORIES_FOLDER",
        "kind": 5,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "TRAJECTORIES_FOLDER = \"./qtrajectories/\"\nwith open(AIRSIM_SETTINGS_FOLDER + 'settings.json', 'r') as jsonFile:\n    g_airsim_settings = json.load(jsonFile)\ng_vehicles = g_airsim_settings[\"Vehicles\"]\ng_config = ConfigParser()\ng_config.read(CONFIGS_FOLDER + 'config.ini')\n\"\"\"\n       Assumes that the simulation environment (unreal) is in the coordinate system specified\n        by the srid but offset by the origin specified.\n        Arguments:",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "g_vehicles",
        "kind": 5,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "g_vehicles = g_airsim_settings[\"Vehicles\"]\ng_config = ConfigParser()\ng_config.read(CONFIGS_FOLDER + 'config.ini')\n\"\"\"\n       Assumes that the simulation environment (unreal) is in the coordinate system specified\n        by the srid but offset by the origin specified.\n        Arguments:\n            srid {str} -- EPSG SRID string. Example \"EPSG:3857\"\n            origin {list} -- [Longitude, Latitude, Height]\n            kwargs -- Any keyword arguments forwared to AirSim",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "g_config",
        "kind": 5,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "g_config = ConfigParser()\ng_config.read(CONFIGS_FOLDER + 'config.ini')\n\"\"\"\n       Assumes that the simulation environment (unreal) is in the coordinate system specified\n        by the srid but offset by the origin specified.\n        Arguments:\n            srid {str} -- EPSG SRID string. Example \"EPSG:3857\"\n            origin {list} -- [Longitude, Latitude, Height]\n            kwargs -- Any keyword arguments forwared to AirSim\n\"\"\"",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "map_filename",
        "kind": 5,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "map_filename = \"overlayMap.png\"\nSRID = \"EPSG:5555\"\n# ORIGIN = (\n# 2.178855691482311,\n# 41.411225748657294,\n# 0)\nORIGIN = (2.174432,41.404572,0)\nO_THETA = 0\nDEST = (\n    12.466382,",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "SRID",
        "kind": 5,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "SRID = \"EPSG:5555\"\n# ORIGIN = (\n# 2.178855691482311,\n# 41.411225748657294,\n# 0)\nORIGIN = (2.174432,41.404572,0)\nO_THETA = 0\nDEST = (\n    12.466382,\n    41.902491,",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "ORIGIN",
        "kind": 5,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "ORIGIN = (2.174432,41.404572,0)\nO_THETA = 0\nDEST = (\n    12.466382,\n    41.902491,\n    80) \nNEW_TRAJ_PENALTY = 25 # negative reward for collision points of a new trajectory\n# GPS init position of uavs\ninit_gps = [\n    (",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "O_THETA",
        "kind": 5,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "O_THETA = 0\nDEST = (\n    12.466382,\n    41.902491,\n    80) \nNEW_TRAJ_PENALTY = 25 # negative reward for collision points of a new trajectory\n# GPS init position of uavs\ninit_gps = [\n    (\n        12.45727300643921,",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "DEST",
        "kind": 5,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "DEST = (\n    12.466382,\n    41.902491,\n    80) \nNEW_TRAJ_PENALTY = 25 # negative reward for collision points of a new trajectory\n# GPS init position of uavs\ninit_gps = [\n    (\n        12.45727300643921,\n        41.90169011784915,",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "NEW_TRAJ_PENALTY",
        "kind": 5,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "NEW_TRAJ_PENALTY = 25 # negative reward for collision points of a new trajectory\n# GPS init position of uavs\ninit_gps = [\n    (\n        12.45727300643921,\n        41.90169011784915,\n        0\n    ),\n    (\n        12.457227408885958,",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "init_gps",
        "kind": 5,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "init_gps = [\n    (\n        12.45727300643921,\n        41.90169011784915,\n        0\n    ),\n    (\n        12.457227408885958,\n        41.90276414312537,\n        0",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "red_color",
        "kind": 5,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "red_color = [1.0,0.0,0.0]\ngreen_color = [0.0,0.5,0.0]\nblue_color = [0.0,0.0,1.0]\norange_color =[255/255, 102/255, 0]\ndef read_yaml(file_path):\n    with open(file_path, \"r\") as f:\n        return yaml.safe_load(f)\ndef play_audio_notification(n_beeps=3,frequency=2000,beep_duration=250):\n    for _ in range(n_beeps):\n        winsound.Beep(frequency, beep_duration)",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "green_color",
        "kind": 5,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "green_color = [0.0,0.5,0.0]\nblue_color = [0.0,0.0,1.0]\norange_color =[255/255, 102/255, 0]\ndef read_yaml(file_path):\n    with open(file_path, \"r\") as f:\n        return yaml.safe_load(f)\ndef play_audio_notification(n_beeps=3,frequency=2000,beep_duration=250):\n    for _ in range(n_beeps):\n        winsound.Beep(frequency, beep_duration)\n        time.sleep(0.1)",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "blue_color",
        "kind": 5,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "blue_color = [0.0,0.0,1.0]\norange_color =[255/255, 102/255, 0]\ndef read_yaml(file_path):\n    with open(file_path, \"r\") as f:\n        return yaml.safe_load(f)\ndef play_audio_notification(n_beeps=3,frequency=2000,beep_duration=250):\n    for _ in range(n_beeps):\n        winsound.Beep(frequency, beep_duration)\n        time.sleep(0.1)\ndef initiate_logger():",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "distance",
        "kind": 5,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "distance = lambda p1, p2: np.norm(p1-p2)\ndef xy_distance(point1, point2):\n    if type(point1) == Vector3r:\n        point1 = [point1.x_val,point1.y_val] \n    if type(point2) == Vector3r:\n        point2 = [point2.x_val,point2.y_val] \n    return   np.linalg.norm(point1 - point2) \ndef myInterpolate(arr, n_samples=10 ):\n    res = []\n    for i,p in enumerate(arr):",
        "detail": "src.utils",
        "documentation": {}
    }
]