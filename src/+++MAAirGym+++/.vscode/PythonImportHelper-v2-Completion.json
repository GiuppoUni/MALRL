[
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "msgpackrpc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "msgpackrpc",
        "description": "msgpackrpc",
        "detail": "msgpackrpc",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "msgpack",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "msgpack",
        "description": "msgpack",
        "detail": "msgpack",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "localtime",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "localtime",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "localtime",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "draw",
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "isExtraImport": true,
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "pdb",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pdb",
        "description": "pdb",
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "O_EXCL",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "types",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "types",
        "description": "types",
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "cv2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cv2",
        "description": "cv2",
        "detail": "cv2",
        "documentation": {}
    },
    {
        "label": "airsim",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "airsim",
        "description": "airsim",
        "detail": "airsim",
        "documentation": {}
    },
    {
        "label": "Vector3r",
        "importPath": "airsim",
        "description": "airsim",
        "isExtraImport": true,
        "detail": "airsim",
        "documentation": {}
    },
    {
        "label": "MultirotorClient",
        "importPath": "airsim",
        "description": "airsim",
        "isExtraImport": true,
        "detail": "airsim",
        "documentation": {}
    },
    {
        "label": "Vector3r",
        "importPath": "airsim",
        "description": "airsim",
        "isExtraImport": true,
        "detail": "airsim",
        "documentation": {}
    },
    {
        "label": "Pose",
        "importPath": "airsim",
        "description": "airsim",
        "isExtraImport": true,
        "detail": "airsim",
        "documentation": {}
    },
    {
        "label": "to_quaternion",
        "importPath": "airsim",
        "description": "airsim",
        "isExtraImport": true,
        "detail": "airsim",
        "documentation": {}
    },
    {
        "label": "Vector3r",
        "importPath": "airsim",
        "description": "airsim",
        "isExtraImport": true,
        "detail": "airsim",
        "documentation": {}
    },
    {
        "label": "Pose",
        "importPath": "airsim",
        "description": "airsim",
        "isExtraImport": true,
        "detail": "airsim",
        "documentation": {}
    },
    {
        "label": "to_quaternion",
        "importPath": "airsim",
        "description": "airsim",
        "isExtraImport": true,
        "detail": "airsim",
        "documentation": {}
    },
    {
        "label": "MultirotorClient",
        "importPath": "airsim",
        "description": "airsim",
        "isExtraImport": true,
        "detail": "airsim",
        "documentation": {}
    },
    {
        "label": "MultirotorClient",
        "importPath": "airsim",
        "description": "airsim",
        "isExtraImport": true,
        "detail": "airsim",
        "documentation": {}
    },
    {
        "label": "Proj",
        "importPath": "pyproj",
        "description": "pyproj",
        "isExtraImport": true,
        "detail": "pyproj",
        "documentation": {}
    },
    {
        "label": "Proj",
        "importPath": "pyproj",
        "description": "pyproj",
        "isExtraImport": true,
        "detail": "pyproj",
        "documentation": {}
    },
    {
        "label": "gym",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gym",
        "description": "gym",
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "error",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "gym",
        "description": "gym",
        "isExtraImport": true,
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "seeding",
        "importPath": "gym.utils",
        "description": "gym.utils",
        "isExtraImport": true,
        "detail": "gym.utils",
        "documentation": {}
    },
    {
        "label": "seeding",
        "importPath": "gym.utils",
        "description": "gym.utils",
        "isExtraImport": true,
        "detail": "gym.utils",
        "documentation": {}
    },
    {
        "label": "seeding",
        "importPath": "gym.utils",
        "description": "gym.utils",
        "isExtraImport": true,
        "detail": "gym.utils",
        "documentation": {}
    },
    {
        "label": "seeding",
        "importPath": "gym.utils",
        "description": "gym.utils",
        "isExtraImport": true,
        "detail": "gym.utils",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "MultiDiscrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "MultiDiscrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "MultiDiscrete",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gym.spaces",
        "description": "gym.spaces",
        "isExtraImport": true,
        "detail": "gym.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces.box",
        "description": "gym.spaces.box",
        "isExtraImport": true,
        "detail": "gym.spaces.box",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces.box",
        "description": "gym.spaces.box",
        "isExtraImport": true,
        "detail": "gym.spaces.box",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gym.spaces.box",
        "description": "gym.spaces.box",
        "isExtraImport": true,
        "detail": "gym.spaces.box",
        "documentation": {}
    },
    {
        "label": "NewMyAirSimClient",
        "importPath": "newMyAirSimClient",
        "description": "newMyAirSimClient",
        "isExtraImport": true,
        "detail": "newMyAirSimClient",
        "documentation": {}
    },
    {
        "label": "DrivetrainType",
        "importPath": "newMyAirSimClient",
        "description": "newMyAirSimClient",
        "isExtraImport": true,
        "detail": "newMyAirSimClient",
        "documentation": {}
    },
    {
        "label": "lock",
        "importPath": "newMyAirSimClient",
        "description": "newMyAirSimClient",
        "isExtraImport": true,
        "detail": "newMyAirSimClient",
        "documentation": {}
    },
    {
        "label": "NewMyAirSimClient",
        "importPath": "newMyAirSimClient",
        "description": "newMyAirSimClient",
        "isExtraImport": true,
        "detail": "newMyAirSimClient",
        "documentation": {}
    },
    {
        "label": "lock",
        "importPath": "newMyAirSimClient",
        "description": "newMyAirSimClient",
        "isExtraImport": true,
        "detail": "newMyAirSimClient",
        "documentation": {}
    },
    {
        "label": "NewMyAirSimClient",
        "importPath": "newMyAirSimClient",
        "description": "newMyAirSimClient",
        "isExtraImport": true,
        "detail": "newMyAirSimClient",
        "documentation": {}
    },
    {
        "label": "NewMyAirSimClient",
        "importPath": "newMyAirSimClient",
        "description": "newMyAirSimClient",
        "isExtraImport": true,
        "detail": "newMyAirSimClient",
        "documentation": {}
    },
    {
        "label": "NewMyAirSimClient",
        "importPath": "newMyAirSimClient",
        "description": "newMyAirSimClient",
        "isExtraImport": true,
        "detail": "newMyAirSimClient",
        "documentation": {}
    },
    {
        "label": "DrivetrainType",
        "importPath": "newMyAirSimClient",
        "description": "newMyAirSimClient",
        "isExtraImport": true,
        "detail": "newMyAirSimClient",
        "documentation": {}
    },
    {
        "label": "utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "utils",
        "description": "utils",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "concurrent.futures",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "eventlet",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "eventlet",
        "description": "eventlet",
        "detail": "eventlet",
        "documentation": {}
    },
    {
        "label": "Timeout",
        "importPath": "eventlet",
        "description": "eventlet",
        "isExtraImport": true,
        "detail": "eventlet",
        "documentation": {}
    },
    {
        "label": "Timeout",
        "importPath": "eventlet",
        "description": "eventlet",
        "isExtraImport": true,
        "detail": "eventlet",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "AirSimEnv",
        "importPath": "gym_airsim.envs.airSimEnv",
        "description": "gym_airsim.envs.airSimEnv",
        "isExtraImport": true,
        "detail": "gym_airsim.envs.airSimEnv",
        "documentation": {}
    },
    {
        "label": "register",
        "importPath": "gym.envs.registration",
        "description": "gym.envs.registration",
        "isExtraImport": true,
        "detail": "gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "register",
        "importPath": "gym.envs.registration",
        "description": "gym.envs.registration",
        "isExtraImport": true,
        "detail": "gym.envs.registration",
        "documentation": {}
    },
    {
        "label": "mul",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "Qr",
        "importPath": "tensorflow.python.ops.gen_linalg_ops",
        "description": "tensorflow.python.ops.gen_linalg_ops",
        "isExtraImport": true,
        "detail": "tensorflow.python.ops.gen_linalg_ops",
        "documentation": {}
    },
    {
        "label": "MazeView2D",
        "importPath": "gym_maze.envs.maze_view_2d",
        "description": "gym_maze.envs.maze_view_2d",
        "isExtraImport": true,
        "detail": "gym_maze.envs.maze_view_2d",
        "documentation": {}
    },
    {
        "label": "MazeView2D",
        "importPath": "gym_maze.envs.maze_view_2d",
        "description": "gym_maze.envs.maze_view_2d",
        "isExtraImport": true,
        "detail": "gym_maze.envs.maze_view_2d",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "KDTree",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "KDTree",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "KDTree",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "KDTree",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "KDTree",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "KDTree",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "KDTree",
        "importPath": "sklearn.neighbors",
        "description": "sklearn.neighbors",
        "isExtraImport": true,
        "detail": "sklearn.neighbors",
        "documentation": {}
    },
    {
        "label": "Maze",
        "importPath": "maze_view_2d",
        "description": "maze_view_2d",
        "isExtraImport": true,
        "detail": "maze_view_2d",
        "documentation": {}
    },
    {
        "label": "pygame",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygame",
        "description": "pygame",
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "fixed_init_pos_list",
        "importPath": "gym_maze.__init__",
        "description": "gym_maze.__init__",
        "isExtraImport": true,
        "detail": "gym_maze.__init__",
        "documentation": {}
    },
    {
        "label": "block",
        "importPath": "numpy.core.shape_base",
        "description": "numpy.core.shape_base",
        "isExtraImport": true,
        "detail": "numpy.core.shape_base",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "gym_maze.envs.maze_env",
        "description": "gym_maze.envs.maze_env",
        "isExtraImport": true,
        "detail": "gym_maze.envs.maze_env",
        "documentation": {}
    },
    {
        "label": "MazeEnv",
        "importPath": "gym_maze.envs.maze_env",
        "description": "gym_maze.envs.maze_env",
        "isExtraImport": true,
        "detail": "gym_maze.envs.maze_env",
        "documentation": {}
    },
    {
        "label": "MazeEnv",
        "importPath": "gym_maze.envs.maze_env",
        "description": "gym_maze.envs.maze_env",
        "isExtraImport": true,
        "detail": "gym_maze.envs.maze_env",
        "documentation": {}
    },
    {
        "label": "MazeEnv",
        "importPath": "gym_maze.envs.maze_env",
        "description": "gym_maze.envs.maze_env",
        "isExtraImport": true,
        "detail": "gym_maze.envs.maze_env",
        "documentation": {}
    },
    {
        "label": "MazeEnv",
        "importPath": "gym_maze.envs.maze_env",
        "description": "gym_maze.envs.maze_env",
        "isExtraImport": true,
        "detail": "gym_maze.envs.maze_env",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "scipy.interpolate",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "interp1d",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "interp1d",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "Vector3r",
        "importPath": "airsim.types",
        "description": "airsim.types",
        "isExtraImport": true,
        "detail": "airsim.types",
        "documentation": {}
    },
    {
        "label": "Vector3r",
        "importPath": "airsim.types",
        "description": "airsim.types",
        "isExtraImport": true,
        "detail": "airsim.types",
        "documentation": {}
    },
    {
        "label": "ImageRequest",
        "importPath": "airsim.types",
        "description": "airsim.types",
        "isExtraImport": true,
        "detail": "airsim.types",
        "documentation": {}
    },
    {
        "label": "Vector3r",
        "importPath": "airsim.types",
        "description": "airsim.types",
        "isExtraImport": true,
        "detail": "airsim.types",
        "documentation": {}
    },
    {
        "label": "ImageRequest",
        "importPath": "airsim.types",
        "description": "airsim.types",
        "isExtraImport": true,
        "detail": "airsim.types",
        "documentation": {}
    },
    {
        "label": "Vector3r",
        "importPath": "airsim.types",
        "description": "airsim.types",
        "isExtraImport": true,
        "detail": "airsim.types",
        "documentation": {}
    },
    {
        "label": "Vector3r",
        "importPath": "airsim.types",
        "description": "airsim.types",
        "isExtraImport": true,
        "detail": "airsim.types",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "CollectEnv",
        "importPath": "gym_airsim.envs.collectEnv",
        "description": "gym_airsim.envs.collectEnv",
        "isExtraImport": true,
        "detail": "gym_airsim.envs.collectEnv",
        "documentation": {}
    },
    {
        "label": "CollectEnv",
        "importPath": "gym_airsim.envs.collectEnv",
        "description": "gym_airsim.envs.collectEnv",
        "isExtraImport": true,
        "detail": "gym_airsim.envs.collectEnv",
        "documentation": {}
    },
    {
        "label": "CollectEnv",
        "importPath": "gym_airsim.envs.collectEnv",
        "description": "gym_airsim.envs.collectEnv",
        "isExtraImport": true,
        "detail": "gym_airsim.envs.collectEnv",
        "documentation": {}
    },
    {
        "label": "gym_airsim.envs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gym_airsim.envs",
        "description": "gym_airsim.envs",
        "detail": "gym_airsim.envs",
        "documentation": {}
    },
    {
        "label": "AirSimEnv",
        "importPath": "gym_airsim.envs",
        "description": "gym_airsim.envs",
        "isExtraImport": true,
        "detail": "gym_airsim.envs",
        "documentation": {}
    },
    {
        "label": "AirSimEnv",
        "importPath": "gym_airsim.envs",
        "description": "gym_airsim.envs",
        "isExtraImport": true,
        "detail": "gym_airsim.envs",
        "documentation": {}
    },
    {
        "label": "pylab",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pylab",
        "description": "pylab",
        "detail": "pylab",
        "documentation": {}
    },
    {
        "label": "array",
        "importPath": "pylab",
        "description": "pylab",
        "isExtraImport": true,
        "detail": "pylab",
        "documentation": {}
    },
    {
        "label": "arange",
        "importPath": "pylab",
        "description": "pylab",
        "isExtraImport": true,
        "detail": "pylab",
        "documentation": {}
    },
    {
        "label": "uint8",
        "importPath": "pylab",
        "description": "pylab",
        "isExtraImport": true,
        "detail": "pylab",
        "documentation": {}
    },
    {
        "label": "array",
        "importPath": "pylab",
        "description": "pylab",
        "isExtraImport": true,
        "detail": "pylab",
        "documentation": {}
    },
    {
        "label": "arange",
        "importPath": "pylab",
        "description": "pylab",
        "isExtraImport": true,
        "detail": "pylab",
        "documentation": {}
    },
    {
        "label": "uint8",
        "importPath": "pylab",
        "description": "pylab",
        "isExtraImport": true,
        "detail": "pylab",
        "documentation": {}
    },
    {
        "label": "trajs_utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "setSeed",
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "isExtraImport": true,
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "ActorCriticPolicy",
        "importPath": "stable_baselines.common.policies",
        "description": "stable_baselines.common.policies",
        "isExtraImport": true,
        "detail": "stable_baselines.common.policies",
        "documentation": {}
    },
    {
        "label": "MlpLnLstmPolicy",
        "importPath": "stable_baselines.common.policies",
        "description": "stable_baselines.common.policies",
        "isExtraImport": true,
        "detail": "stable_baselines.common.policies",
        "documentation": {}
    },
    {
        "label": "MlpLnLstmPolicy",
        "importPath": "stable_baselines.common.policies",
        "description": "stable_baselines.common.policies",
        "isExtraImport": true,
        "detail": "stable_baselines.common.policies",
        "documentation": {}
    },
    {
        "label": "gym_maze",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gym_maze",
        "description": "gym_maze",
        "detail": "gym_maze",
        "documentation": {}
    },
    {
        "label": "gym_airsim",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gym_airsim",
        "description": "gym_airsim",
        "detail": "gym_airsim",
        "documentation": {}
    },
    {
        "label": "check_env",
        "importPath": "stable_baselines.common.env_checker",
        "description": "stable_baselines.common.env_checker",
        "isExtraImport": true,
        "detail": "stable_baselines.common.env_checker",
        "documentation": {}
    },
    {
        "label": "MazeEnvCont",
        "importPath": "gym_maze.envs.maze_env_cont",
        "description": "gym_maze.envs.maze_env_cont",
        "isExtraImport": true,
        "detail": "gym_maze.envs.maze_env_cont",
        "documentation": {}
    },
    {
        "label": "MazeEnvCont",
        "importPath": "gym_maze.envs.maze_env_cont",
        "description": "gym_maze.envs.maze_env_cont",
        "isExtraImport": true,
        "detail": "gym_maze.envs.maze_env_cont",
        "documentation": {}
    },
    {
        "label": "DQN",
        "importPath": "stable_baselines",
        "description": "stable_baselines",
        "isExtraImport": true,
        "detail": "stable_baselines",
        "documentation": {}
    },
    {
        "label": "results_plotter",
        "importPath": "stable_baselines",
        "description": "stable_baselines",
        "isExtraImport": true,
        "detail": "stable_baselines",
        "documentation": {}
    },
    {
        "label": "DQN",
        "importPath": "stable_baselines",
        "description": "stable_baselines",
        "isExtraImport": true,
        "detail": "stable_baselines",
        "documentation": {}
    },
    {
        "label": "PPO2",
        "importPath": "stable_baselines",
        "description": "stable_baselines",
        "isExtraImport": true,
        "detail": "stable_baselines",
        "documentation": {}
    },
    {
        "label": "A2C",
        "importPath": "stable_baselines",
        "description": "stable_baselines",
        "isExtraImport": true,
        "detail": "stable_baselines",
        "documentation": {}
    },
    {
        "label": "ACKTR",
        "importPath": "stable_baselines",
        "description": "stable_baselines",
        "isExtraImport": true,
        "detail": "stable_baselines",
        "documentation": {}
    },
    {
        "label": "DQN",
        "importPath": "stable_baselines",
        "description": "stable_baselines",
        "isExtraImport": true,
        "detail": "stable_baselines",
        "documentation": {}
    },
    {
        "label": "results_plotter",
        "importPath": "stable_baselines",
        "description": "stable_baselines",
        "isExtraImport": true,
        "detail": "stable_baselines",
        "documentation": {}
    },
    {
        "label": "evaluate_policy",
        "importPath": "stable_baselines.common.evaluation",
        "description": "stable_baselines.common.evaluation",
        "isExtraImport": true,
        "detail": "stable_baselines.common.evaluation",
        "documentation": {}
    },
    {
        "label": "evaluate_policy",
        "importPath": "stable_baselines.common.evaluation",
        "description": "stable_baselines.common.evaluation",
        "isExtraImport": true,
        "detail": "stable_baselines.common.evaluation",
        "documentation": {}
    },
    {
        "label": "Monitor",
        "importPath": "stable_baselines.bench",
        "description": "stable_baselines.bench",
        "isExtraImport": true,
        "detail": "stable_baselines.bench",
        "documentation": {}
    },
    {
        "label": "Monitor",
        "importPath": "stable_baselines.bench",
        "description": "stable_baselines.bench",
        "isExtraImport": true,
        "detail": "stable_baselines.bench",
        "documentation": {}
    },
    {
        "label": "load_results",
        "importPath": "stable_baselines.results_plotter",
        "description": "stable_baselines.results_plotter",
        "isExtraImport": true,
        "detail": "stable_baselines.results_plotter",
        "documentation": {}
    },
    {
        "label": "ts2xy",
        "importPath": "stable_baselines.results_plotter",
        "description": "stable_baselines.results_plotter",
        "isExtraImport": true,
        "detail": "stable_baselines.results_plotter",
        "documentation": {}
    },
    {
        "label": "load_results",
        "importPath": "stable_baselines.results_plotter",
        "description": "stable_baselines.results_plotter",
        "isExtraImport": true,
        "detail": "stable_baselines.results_plotter",
        "documentation": {}
    },
    {
        "label": "ts2xy",
        "importPath": "stable_baselines.results_plotter",
        "description": "stable_baselines.results_plotter",
        "isExtraImport": true,
        "detail": "stable_baselines.results_plotter",
        "documentation": {}
    },
    {
        "label": "AdaptiveParamNoiseSpec",
        "importPath": "stable_baselines.common.noise",
        "description": "stable_baselines.common.noise",
        "isExtraImport": true,
        "detail": "stable_baselines.common.noise",
        "documentation": {}
    },
    {
        "label": "AdaptiveParamNoiseSpec",
        "importPath": "stable_baselines.common.noise",
        "description": "stable_baselines.common.noise",
        "isExtraImport": true,
        "detail": "stable_baselines.common.noise",
        "documentation": {}
    },
    {
        "label": "BaseCallback",
        "importPath": "stable_baselines.common.callbacks",
        "description": "stable_baselines.common.callbacks",
        "isExtraImport": true,
        "detail": "stable_baselines.common.callbacks",
        "documentation": {}
    },
    {
        "label": "BaseCallback",
        "importPath": "stable_baselines.common.callbacks",
        "description": "stable_baselines.common.callbacks",
        "isExtraImport": true,
        "detail": "stable_baselines.common.callbacks",
        "documentation": {}
    },
    {
        "label": "make_vec_env",
        "importPath": "stable_baselines.common.cmd_util",
        "description": "stable_baselines.common.cmd_util",
        "isExtraImport": true,
        "detail": "stable_baselines.common.cmd_util",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "TrajectoryTrackerClient",
        "importPath": "trajectoryTrackerClient",
        "description": "trajectoryTrackerClient",
        "isExtraImport": true,
        "detail": "trajectoryTrackerClient",
        "documentation": {}
    },
    {
        "label": "TrajectoryTrackerClient",
        "importPath": "trajectoryTrackerClient",
        "description": "trajectoryTrackerClient",
        "isExtraImport": true,
        "detail": "trajectoryTrackerClient",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "queue",
        "description": "queue",
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "matplotlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib",
        "description": "matplotlib",
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "mplot3d",
        "importPath": "mpl_toolkits",
        "description": "mpl_toolkits",
        "isExtraImport": true,
        "detail": "mpl_toolkits",
        "documentation": {}
    },
    {
        "label": "mplot3d",
        "importPath": "mpl_toolkits",
        "description": "mpl_toolkits",
        "isExtraImport": true,
        "detail": "mpl_toolkits",
        "documentation": {}
    },
    {
        "label": "mplot3d",
        "importPath": "mpl_toolkits",
        "description": "mpl_toolkits",
        "isExtraImport": true,
        "detail": "mpl_toolkits",
        "documentation": {}
    },
    {
        "label": "airsim,time,threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "airsim.time.threading",
        "description": "airsim.time.threading",
        "detail": "airsim.time.threading",
        "documentation": {}
    },
    {
        "label": "to_eularian_angles",
        "importPath": "airsim.utils",
        "description": "airsim.utils",
        "isExtraImport": true,
        "detail": "airsim.utils",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "gc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gc",
        "description": "gc",
        "detail": "gc",
        "documentation": {}
    },
    {
        "label": "AirSimGeoClient",
        "importPath": "airsimgeo",
        "description": "airsimgeo",
        "isExtraImport": true,
        "detail": "airsimgeo",
        "documentation": {}
    },
    {
        "label": "poisson",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "DotMap",
        "importPath": "dotmap",
        "description": "dotmap",
        "isExtraImport": true,
        "detail": "dotmap",
        "documentation": {}
    },
    {
        "label": "ConfigParser",
        "importPath": "configparser",
        "description": "configparser",
        "isExtraImport": true,
        "detail": "configparser",
        "documentation": {}
    },
    {
        "label": "winsound",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "winsound",
        "description": "winsound",
        "detail": "winsound",
        "documentation": {}
    },
    {
        "label": "VehicleClient",
        "kind": 6,
        "importPath": "airsim-.client",
        "description": "airsim-.client",
        "peekOfCode": "class VehicleClient:\n    def __init__(self, ip = \"\", port = 41451, timeout_value = 3600):\n        # print(\"Initing...\")\n        if (ip == \"\"):\n            ip = \"127.0.0.1\"\n        self.client = msgpackrpc.Client(msgpackrpc.Address(ip, port), timeout = timeout_value, pack_encoding = 'utf-8', unpack_encoding = 'utf-8')\n    # -----------------------------------  Common vehicle APIs ---------------------------------------------\n    def reset(self):\n        \"\"\"\n        Reset the vehicle to its original starting state",
        "detail": "airsim-.client",
        "documentation": {}
    },
    {
        "label": "MultirotorClient",
        "kind": 6,
        "importPath": "airsim-.client",
        "description": "airsim-.client",
        "peekOfCode": "class MultirotorClient(VehicleClient, object):\n    def __init__(self, ip = \"\", port = 41451, timeout_value = 3600):\n        super(MultirotorClient, self).__init__(ip, port, timeout_value)\n    def takeoffAsync(self, timeout_sec = 20, vehicle_name = ''):\n        \"\"\"\n        Takeoff vehicle to 3m above ground. Vehicle should not be moving when this API is used\n        Args:\n            timeout_sec (int, optional): Timeout for the vehicle to reach desired altitude\n            vehicle_name (str, optional): Name of the vehicle to send this command to\n        Returns:",
        "detail": "airsim-.client",
        "documentation": {}
    },
    {
        "label": "CarClient",
        "kind": 6,
        "importPath": "airsim-.client",
        "description": "airsim-.client",
        "peekOfCode": "class CarClient(VehicleClient, object):\n    def __init__(self, ip = \"\", port = 41451, timeout_value = 3600):\n        super(CarClient, self).__init__(ip, port, timeout_value)\n    def setCarControls(self, controls, vehicle_name = ''):\n        \"\"\"\n        Control the car using throttle, steering, brake, etc.\n        Args:\n            controls (CarControls): Struct containing control values\n            vehicle_name (str, optional): Name of vehicle to be controlled\n        \"\"\"",
        "detail": "airsim-.client",
        "documentation": {}
    },
    {
        "label": "read_pfm",
        "kind": 2,
        "importPath": "airsim-.pfm",
        "description": "airsim-.pfm",
        "peekOfCode": "def read_pfm(file):\n    \"\"\" Read a pfm file \"\"\"\n    file = open(file, 'rb')\n    color = None\n    width = None\n    height = None\n    scale = None\n    endian = None\n    header = file.readline().rstrip()\n    header = str(bytes.decode(header, encoding='utf-8'))",
        "detail": "airsim-.pfm",
        "documentation": {}
    },
    {
        "label": "write_pfm",
        "kind": 2,
        "importPath": "airsim-.pfm",
        "description": "airsim-.pfm",
        "peekOfCode": "def write_pfm(file, image, scale=1):\n    \"\"\" Write a pfm file \"\"\"\n    file = open(file, 'wb')\n    color = None\n    if image.dtype.name != 'float32':\n        raise Exception('Image dtype must be float32.')\n    if len(image.shape) == 3 and image.shape[2] == 3: # color image\n        color = True\n    elif len(image.shape) == 2 or len(image.shape) == 3 and image.shape[2] == 1: # greyscale\n        color = False",
        "detail": "airsim-.pfm",
        "documentation": {}
    },
    {
        "label": "MsgpackMixin",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class MsgpackMixin:\n    def __repr__(self):\n        from pprint import pformat\n        return \"<\" + type(self).__name__ + \"> \" + pformat(vars(self), indent=4, width=1)\n    def to_msgpack(self, *args, **kwargs):\n        return self.__dict__\n    @classmethod\n    def from_msgpack(cls, encoded):\n        obj = cls()\n        #obj.__dict__ = {k.decode('utf-8'): (from_msgpack(v.__class__, v) if hasattr(v, \"__dict__\") else v) for k, v in encoded.items()}",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "ImageType",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class ImageType:\n    Scene = 0\n    DepthPlanner = 1\n    DepthPerspective = 2\n    DepthVis = 3\n    DisparityNormalized = 4\n    Segmentation = 5\n    SurfaceNormals = 6\n    Infrared = 7\nclass DrivetrainType:",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "DrivetrainType",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class DrivetrainType:\n    MaxDegreeOfFreedom = 0\n    ForwardOnly = 1\nclass LandedState:\n    Landed = 0\n    Flying = 1\nclass WeatherParameter:\n    Rain = 0\n    Roadwetness = 1\n    Snow = 2",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "LandedState",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class LandedState:\n    Landed = 0\n    Flying = 1\nclass WeatherParameter:\n    Rain = 0\n    Roadwetness = 1\n    Snow = 2\n    RoadSnow = 3\n    MapleLeaf = 4\n    RoadLeaf = 5",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "WeatherParameter",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class WeatherParameter:\n    Rain = 0\n    Roadwetness = 1\n    Snow = 2\n    RoadSnow = 3\n    MapleLeaf = 4\n    RoadLeaf = 5\n    Dust = 6\n    Fog = 7\n    Enabled = 8",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "Vector3r",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class Vector3r(MsgpackMixin):\n    x_val = 0.0\n    y_val = 0.0\n    z_val = 0.0\n    def __init__(self, x_val = 0.0, y_val = 0.0, z_val = 0.0):\n        self.x_val = x_val\n        self.y_val = y_val\n        self.z_val = z_val\n    @staticmethod\n    def nanVector3r():",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "Quaternionr",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class Quaternionr(MsgpackMixin):\n    w_val = 0.0\n    x_val = 0.0\n    y_val = 0.0\n    z_val = 0.0\n    def __init__(self, x_val = 0.0, y_val = 0.0, z_val = 0.0, w_val = 1.0):\n        self.x_val = x_val\n        self.y_val = y_val\n        self.z_val = z_val\n        self.w_val = w_val",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "Pose",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class Pose(MsgpackMixin):\n    position = Vector3r()\n    orientation = Quaternionr()\n    def __init__(self, position_val = None, orientation_val = None):\n        position_val = position_val if position_val != None else Vector3r()\n        orientation_val = orientation_val if orientation_val != None else Quaternionr()\n        self.position = position_val\n        self.orientation = orientation_val\n    @staticmethod\n    def nanPose():",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "CollisionInfo",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class CollisionInfo(MsgpackMixin):\n    has_collided = False\n    normal = Vector3r()\n    impact_point = Vector3r()\n    position = Vector3r()\n    penetration_depth = 0.0\n    time_stamp = 0.0\n    object_name = \"\"\n    object_id = -1\nclass GeoPoint(MsgpackMixin):",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "GeoPoint",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class GeoPoint(MsgpackMixin):\n    latitude = 0.0\n    longitude = 0.0\n    altitude = 0.0\nclass YawMode(MsgpackMixin):\n    is_rate = True\n    yaw_or_rate = 0.0\n    def __init__(self, is_rate = True, yaw_or_rate = 0.0):\n        self.is_rate = is_rate\n        self.yaw_or_rate = yaw_or_rate",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "YawMode",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class YawMode(MsgpackMixin):\n    is_rate = True\n    yaw_or_rate = 0.0\n    def __init__(self, is_rate = True, yaw_or_rate = 0.0):\n        self.is_rate = is_rate\n        self.yaw_or_rate = yaw_or_rate\nclass RCData(MsgpackMixin):\n    timestamp = 0\n    pitch, roll, throttle, yaw = (0.0,)*4 #init 4 variable to 0.0\n    switch1, switch2, switch3, switch4 = (0,)*4",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "RCData",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class RCData(MsgpackMixin):\n    timestamp = 0\n    pitch, roll, throttle, yaw = (0.0,)*4 #init 4 variable to 0.0\n    switch1, switch2, switch3, switch4 = (0,)*4\n    switch5, switch6, switch7, switch8 = (0,)*4\n    is_initialized = False\n    is_valid = False\n    def __init__(self, timestamp = 0, pitch = 0.0, roll = 0.0, throttle = 0.0, yaw = 0.0, switch1 = 0,\n                 switch2 = 0, switch3 = 0, switch4 = 0, switch5 = 0, switch6 = 0, switch7 = 0, switch8 = 0, is_initialized = False, is_valid = False):\n        self.timestamp = timestamp",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "ImageRequest",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class ImageRequest(MsgpackMixin):\n    camera_name = '0'\n    image_type = ImageType.Scene\n    pixels_as_float = False\n    compress = False\n    def __init__(self, camera_name, image_type, pixels_as_float = False, compress = True):\n        # todo: in future remove str(), it's only for compatibility to pre v1.2\n        self.camera_name = str(camera_name)\n        self.image_type = image_type\n        self.pixels_as_float = pixels_as_float",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "ImageResponse",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class ImageResponse(MsgpackMixin):\n    image_data_uint8 = np.uint8(0)\n    image_data_float = 0.0\n    camera_position = Vector3r()\n    camera_orientation = Quaternionr()\n    time_stamp = np.uint64(0)\n    message = ''\n    pixels_as_float = 0.0\n    compress = True\n    width = 0",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "CarControls",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class CarControls(MsgpackMixin):\n    throttle = 0.0\n    steering = 0.0\n    brake = 0.0\n    handbrake = False\n    is_manual_gear = False\n    manual_gear = 0\n    gear_immediate = True\n    def __init__(self, throttle = 0, steering = 0, brake = 0,\n        handbrake = False, is_manual_gear = False, manual_gear = 0, gear_immediate = True):",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "KinematicsState",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class KinematicsState(MsgpackMixin):\n    position = Vector3r()\n    orientation = Quaternionr()\n    linear_velocity = Vector3r()\n    angular_velocity = Vector3r()\n    linear_acceleration = Vector3r()\n    angular_acceleration = Vector3r()\nclass EnvironmentState(MsgpackMixin):\n    position = Vector3r()\n    geo_point = GeoPoint()",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "EnvironmentState",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class EnvironmentState(MsgpackMixin):\n    position = Vector3r()\n    geo_point = GeoPoint()\n    gravity = Vector3r()\n    air_pressure = 0.0\n    temperature = 0.0\n    air_density = 0.0\nclass CarState(MsgpackMixin):\n    speed = 0.0\n    gear = 0",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "CarState",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class CarState(MsgpackMixin):\n    speed = 0.0\n    gear = 0\n    rpm = 0.0\n    maxrpm = 0.0\n    handbrake = False\n    collision = CollisionInfo()\n    kinematics_estimated = KinematicsState()\n    timestamp = np.uint64(0)\nclass MultirotorState(MsgpackMixin):",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "MultirotorState",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class MultirotorState(MsgpackMixin):\n    collision = CollisionInfo()\n    kinematics_estimated = KinematicsState()\n    gps_location = GeoPoint()\n    timestamp = np.uint64(0)\n    landed_state = LandedState.Landed\n    rc_data = RCData()\n    ready = False\n    ready_message = \"\"\n    can_arm = False",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "ProjectionMatrix",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class ProjectionMatrix(MsgpackMixin):\n    matrix = []\nclass CameraInfo(MsgpackMixin):\n    pose = Pose()\n    fov = -1\n    proj_mat = ProjectionMatrix()\nclass LidarData(MsgpackMixin):\n    point_cloud = 0.0\n    time_stamp = np.uint64(0)\n    pose = Pose()",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "CameraInfo",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class CameraInfo(MsgpackMixin):\n    pose = Pose()\n    fov = -1\n    proj_mat = ProjectionMatrix()\nclass LidarData(MsgpackMixin):\n    point_cloud = 0.0\n    time_stamp = np.uint64(0)\n    pose = Pose()\nclass ImuData(MsgpackMixin):\n    time_stamp = np.uint64(0)",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "LidarData",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class LidarData(MsgpackMixin):\n    point_cloud = 0.0\n    time_stamp = np.uint64(0)\n    pose = Pose()\nclass ImuData(MsgpackMixin):\n    time_stamp = np.uint64(0)\n    orientation = Quaternionr()\n    angular_velocity = Vector3r()\n    linear_acceleration = Vector3r()\nclass BarometerData(MsgpackMixin):",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "ImuData",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class ImuData(MsgpackMixin):\n    time_stamp = np.uint64(0)\n    orientation = Quaternionr()\n    angular_velocity = Vector3r()\n    linear_acceleration = Vector3r()\nclass BarometerData(MsgpackMixin):\n    time_stamp = np.uint64(0)\n    altitude = Quaternionr()\n    pressure = Vector3r()\n    qnh = Vector3r()",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "BarometerData",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class BarometerData(MsgpackMixin):\n    time_stamp = np.uint64(0)\n    altitude = Quaternionr()\n    pressure = Vector3r()\n    qnh = Vector3r()\nclass MagnetometerData(MsgpackMixin):\n    time_stamp = np.uint64(0)\n    magnetic_field_body = Vector3r()\n    magnetic_field_covariance = 0.0\nclass GnssFixType(MsgpackMixin):",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "MagnetometerData",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class MagnetometerData(MsgpackMixin):\n    time_stamp = np.uint64(0)\n    magnetic_field_body = Vector3r()\n    magnetic_field_covariance = 0.0\nclass GnssFixType(MsgpackMixin):\n    GNSS_FIX_NO_FIX = 0\n    GNSS_FIX_TIME_ONLY = 1\n    GNSS_FIX_2D_FIX = 2\n    GNSS_FIX_3D_FIX = 3\nclass GnssReport(MsgpackMixin):",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "GnssFixType",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class GnssFixType(MsgpackMixin):\n    GNSS_FIX_NO_FIX = 0\n    GNSS_FIX_TIME_ONLY = 1\n    GNSS_FIX_2D_FIX = 2\n    GNSS_FIX_3D_FIX = 3\nclass GnssReport(MsgpackMixin):\n    geo_point = GeoPoint()\n    eph = 0.0\n    epv = 0.0\n    velocity = Vector3r()",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "GnssReport",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class GnssReport(MsgpackMixin):\n    geo_point = GeoPoint()\n    eph = 0.0\n    epv = 0.0\n    velocity = Vector3r()\n    fix_type = GnssFixType()\n    time_utc = np.uint64(0)\nclass GpsData(MsgpackMixin):\n    time_stamp = np.uint64(0)\n    gnss = GnssReport()",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "GpsData",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class GpsData(MsgpackMixin):\n    time_stamp = np.uint64(0)\n    gnss = GnssReport()\n    is_valid = False\nclass DistanceSensorData(MsgpackMixin):\n    time_stamp = np.uint64(0)\n    distance = 0.0\n    min_distance = 0.0\n    max_distance = 0.0\n    relative_pose = Pose()",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "DistanceSensorData",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class DistanceSensorData(MsgpackMixin):\n    time_stamp = np.uint64(0)\n    distance = 0.0\n    min_distance = 0.0\n    max_distance = 0.0\n    relative_pose = Pose()\nclass PIDGains():\n    \"\"\"\n    Struct to store values of PID gains. Used to transmit controller gain values while instantiating\n    AngleLevel/AngleRate/Velocity/PositionControllerGains objects.",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "PIDGains",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class PIDGains():\n    \"\"\"\n    Struct to store values of PID gains. Used to transmit controller gain values while instantiating\n    AngleLevel/AngleRate/Velocity/PositionControllerGains objects.\n    Attributes:\n        kP (float): Proportional gain\n        kI (float): Integrator gain\n        kD (float): Derivative gain\n    \"\"\"\n    def __init__(self, kp, ki, kd):",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "AngleRateControllerGains",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class AngleRateControllerGains():\n    \"\"\"\n    Struct to contain controller gains used by angle level PID controller\n    Attributes:\n        roll_gains (PIDGains): kP, kI, kD for roll axis\n        pitch_gains (PIDGains): kP, kI, kD for pitch axis\n        yaw_gains (PIDGains): kP, kI, kD for yaw axis\n    \"\"\"\n    def __init__(self, roll_gains = PIDGains(0.25, 0, 0),\n                       pitch_gains = PIDGains(0.25, 0, 0),",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "AngleLevelControllerGains",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class AngleLevelControllerGains():\n    \"\"\"\n    Struct to contain controller gains used by angle rate PID controller\n    Attributes:\n        roll_gains (PIDGains): kP, kI, kD for roll axis\n        pitch_gains (PIDGains): kP, kI, kD for pitch axis\n        yaw_gains (PIDGains): kP, kI, kD for yaw axis\n    \"\"\"\n    def __init__(self, roll_gains = PIDGains(2.5, 0, 0),\n                       pitch_gains = PIDGains(2.5, 0, 0),",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "VelocityControllerGains",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class VelocityControllerGains():\n    \"\"\"\n    Struct to contain controller gains used by velocity PID controller\n    Attributes:\n        x_gains (PIDGains): kP, kI, kD for X axis\n        y_gains (PIDGains): kP, kI, kD for Y axis\n        z_gains (PIDGains): kP, kI, kD for Z axis\n    \"\"\"\n    def __init__(self, x_gains = PIDGains(0.2, 0, 0),\n                       y_gains = PIDGains(0.2, 0, 0),",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "PositionControllerGains",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class PositionControllerGains():\n    \"\"\"\n    Struct to contain controller gains used by position PID controller\n    Attributes:\n        x_gains (PIDGains): kP, kI, kD for X axis\n        y_gains (PIDGains): kP, kI, kD for Y axis\n        z_gains (PIDGains): kP, kI, kD for Z axis\n    \"\"\"\n    def __init__(self, x_gains = PIDGains(0.25, 0, 0),\n                       y_gains = PIDGains(0.25, 0, 0),",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "MeshPositionVertexBuffersResponse",
        "kind": 6,
        "importPath": "airsim-.types",
        "description": "airsim-.types",
        "peekOfCode": "class MeshPositionVertexBuffersResponse(MsgpackMixin):\n    position = Vector3r()\n    orientation = Quaternionr()\n    vertices = 0.0\n    indices = 0.0\n    name = ''",
        "detail": "airsim-.types",
        "documentation": {}
    },
    {
        "label": "string_to_uint8_array",
        "kind": 2,
        "importPath": "airsim-.utils",
        "description": "airsim-.utils",
        "peekOfCode": "def string_to_uint8_array(bstr):\n    return np.fromstring(bstr, np.uint8)\ndef string_to_float_array(bstr):\n    return np.fromstring(bstr, np.float32)\ndef list_to_2d_float_array(flst, width, height):\n    return np.reshape(np.asarray(flst, np.float32), (height, width))\ndef get_pfm_array(response):\n    return list_to_2d_float_array(response.image_data_float, response.width, response.height)\ndef get_public_fields(obj):\n    return [attr for attr in dir(obj)",
        "detail": "airsim-.utils",
        "documentation": {}
    },
    {
        "label": "string_to_float_array",
        "kind": 2,
        "importPath": "airsim-.utils",
        "description": "airsim-.utils",
        "peekOfCode": "def string_to_float_array(bstr):\n    return np.fromstring(bstr, np.float32)\ndef list_to_2d_float_array(flst, width, height):\n    return np.reshape(np.asarray(flst, np.float32), (height, width))\ndef get_pfm_array(response):\n    return list_to_2d_float_array(response.image_data_float, response.width, response.height)\ndef get_public_fields(obj):\n    return [attr for attr in dir(obj)\n                            if not (attr.startswith(\"_\") \n                            or inspect.isbuiltin(attr)",
        "detail": "airsim-.utils",
        "documentation": {}
    },
    {
        "label": "list_to_2d_float_array",
        "kind": 2,
        "importPath": "airsim-.utils",
        "description": "airsim-.utils",
        "peekOfCode": "def list_to_2d_float_array(flst, width, height):\n    return np.reshape(np.asarray(flst, np.float32), (height, width))\ndef get_pfm_array(response):\n    return list_to_2d_float_array(response.image_data_float, response.width, response.height)\ndef get_public_fields(obj):\n    return [attr for attr in dir(obj)\n                            if not (attr.startswith(\"_\") \n                            or inspect.isbuiltin(attr)\n                            or inspect.isfunction(attr)\n                            or inspect.ismethod(attr))]",
        "detail": "airsim-.utils",
        "documentation": {}
    },
    {
        "label": "get_pfm_array",
        "kind": 2,
        "importPath": "airsim-.utils",
        "description": "airsim-.utils",
        "peekOfCode": "def get_pfm_array(response):\n    return list_to_2d_float_array(response.image_data_float, response.width, response.height)\ndef get_public_fields(obj):\n    return [attr for attr in dir(obj)\n                            if not (attr.startswith(\"_\") \n                            or inspect.isbuiltin(attr)\n                            or inspect.isfunction(attr)\n                            or inspect.ismethod(attr))]\ndef to_dict(obj):\n    return dict([attr, getattr(obj, attr)] for attr in get_public_fields(obj))",
        "detail": "airsim-.utils",
        "documentation": {}
    },
    {
        "label": "get_public_fields",
        "kind": 2,
        "importPath": "airsim-.utils",
        "description": "airsim-.utils",
        "peekOfCode": "def get_public_fields(obj):\n    return [attr for attr in dir(obj)\n                            if not (attr.startswith(\"_\") \n                            or inspect.isbuiltin(attr)\n                            or inspect.isfunction(attr)\n                            or inspect.ismethod(attr))]\ndef to_dict(obj):\n    return dict([attr, getattr(obj, attr)] for attr in get_public_fields(obj))\ndef to_str(obj):\n    return str(to_dict(obj))",
        "detail": "airsim-.utils",
        "documentation": {}
    },
    {
        "label": "to_dict",
        "kind": 2,
        "importPath": "airsim-.utils",
        "description": "airsim-.utils",
        "peekOfCode": "def to_dict(obj):\n    return dict([attr, getattr(obj, attr)] for attr in get_public_fields(obj))\ndef to_str(obj):\n    return str(to_dict(obj))\ndef write_file(filename, bstr):\n    \"\"\"\n    Write binary data to file.\n    Used for writing compressed PNG images\n    \"\"\"\n    with open(filename, 'wb') as afile:",
        "detail": "airsim-.utils",
        "documentation": {}
    },
    {
        "label": "to_str",
        "kind": 2,
        "importPath": "airsim-.utils",
        "description": "airsim-.utils",
        "peekOfCode": "def to_str(obj):\n    return str(to_dict(obj))\ndef write_file(filename, bstr):\n    \"\"\"\n    Write binary data to file.\n    Used for writing compressed PNG images\n    \"\"\"\n    with open(filename, 'wb') as afile:\n        afile.write(bstr)\n# helper method for converting getOrientation to roll/pitch/yaw",
        "detail": "airsim-.utils",
        "documentation": {}
    },
    {
        "label": "write_file",
        "kind": 2,
        "importPath": "airsim-.utils",
        "description": "airsim-.utils",
        "peekOfCode": "def write_file(filename, bstr):\n    \"\"\"\n    Write binary data to file.\n    Used for writing compressed PNG images\n    \"\"\"\n    with open(filename, 'wb') as afile:\n        afile.write(bstr)\n# helper method for converting getOrientation to roll/pitch/yaw\n# https:#en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles\ndef to_eularian_angles(q):",
        "detail": "airsim-.utils",
        "documentation": {}
    },
    {
        "label": "to_eularian_angles",
        "kind": 2,
        "importPath": "airsim-.utils",
        "description": "airsim-.utils",
        "peekOfCode": "def to_eularian_angles(q):\n    z = q.z_val\n    y = q.y_val\n    x = q.x_val\n    w = q.w_val\n    ysqr = y * y\n    # roll (x-axis rotation)\n    t0 = +2.0 * (w*x + y*z)\n    t1 = +1.0 - 2.0*(x*x + ysqr)\n    roll = math.atan2(t0, t1)",
        "detail": "airsim-.utils",
        "documentation": {}
    },
    {
        "label": "to_quaternion",
        "kind": 2,
        "importPath": "airsim-.utils",
        "description": "airsim-.utils",
        "peekOfCode": "def to_quaternion(pitch, roll, yaw):\n    t0 = math.cos(yaw * 0.5)\n    t1 = math.sin(yaw * 0.5)\n    t2 = math.cos(roll * 0.5)\n    t3 = math.sin(roll * 0.5)\n    t4 = math.cos(pitch * 0.5)\n    t5 = math.sin(pitch * 0.5)\n    q = Quaternionr()\n    q.w_val = t0 * t2 * t4 + t1 * t3 * t5 #w\n    q.x_val = t0 * t3 * t4 - t1 * t2 * t5 #x",
        "detail": "airsim-.utils",
        "documentation": {}
    },
    {
        "label": "wait_key",
        "kind": 2,
        "importPath": "airsim-.utils",
        "description": "airsim-.utils",
        "peekOfCode": "def wait_key(message = ''):\n    ''' Wait for a key press on the console and return it. '''\n    if message != '':\n        print (message)\n    result = None\n    if os.name == 'nt':\n        import msvcrt\n        result = msvcrt.getch()\n    else:\n        import termios",
        "detail": "airsim-.utils",
        "documentation": {}
    },
    {
        "label": "read_pfm",
        "kind": 2,
        "importPath": "airsim-.utils",
        "description": "airsim-.utils",
        "peekOfCode": "def read_pfm(file):\n    \"\"\" Read a pfm file \"\"\"\n    file = open(file, 'rb')\n    color = None\n    width = None\n    height = None\n    scale = None\n    endian = None\n    header = file.readline().rstrip()\n    header = str(bytes.decode(header, encoding='utf-8'))",
        "detail": "airsim-.utils",
        "documentation": {}
    },
    {
        "label": "write_pfm",
        "kind": 2,
        "importPath": "airsim-.utils",
        "description": "airsim-.utils",
        "peekOfCode": "def write_pfm(file, image, scale=1):\n    \"\"\" Write a pfm file \"\"\"\n    file = open(file, 'wb')\n    color = None\n    if image.dtype.name != 'float32':\n        raise Exception('Image dtype must be float32.')\n    if len(image.shape) == 3 and image.shape[2] == 3: # color image\n        color = True\n    elif len(image.shape) == 2 or len(image.shape) == 3 and image.shape[2] == 1: # grayscale\n        color = False",
        "detail": "airsim-.utils",
        "documentation": {}
    },
    {
        "label": "write_png",
        "kind": 2,
        "importPath": "airsim-.utils",
        "description": "airsim-.utils",
        "peekOfCode": "def write_png(filename, image):\n    \"\"\" image must be numpy array H X W X channels\n    \"\"\"\n    ret = cv2.imwrite(filename, image)\n    if not ret:\n        logging.error(f\"Writing PNG file {filename} failed\")",
        "detail": "airsim-.utils",
        "documentation": {}
    },
    {
        "label": "AirSimGeoClient",
        "kind": 6,
        "importPath": "airsimgeo.__init__",
        "description": "airsimgeo.__init__",
        "peekOfCode": "class AirSimGeoClient(MultirotorClient):\n    def __init__(self, srid, origin, **kwargs):\n        \"\"\"AirSim client that understands arbitrary projection systems\n        Assumes that the simulation environment (unreal) is in the coordinate system specified\n        by the srid but offset by the origin specified.\n        Arguments:\n            srid {str} -- EPSG SRID string. Example \"EPSG:3857\"\n            origin {list} -- [Longitude, Latitude, Height]\n            kwargs -- Any keyword arguments forwared to AirSim\n        \"\"\"",
        "detail": "airsimgeo.__init__",
        "documentation": {}
    },
    {
        "label": "MultiAgentActionSpace",
        "kind": 6,
        "importPath": "gym_airsim.envs.gymUtils.action_space",
        "description": "gym_airsim.envs.gymUtils.action_space",
        "peekOfCode": "class MultiAgentActionSpace(list):\n    def __init__(self, agents_action_space):\n        for x in agents_action_space:\n            assert isinstance(x, gym.spaces.space.Space)\n        super(MultiAgentActionSpace, self).__init__(agents_action_space)\n        self._agents_action_space = agents_action_space\n    def sample(self):\n        \"\"\" samples action for each agent from uniform distribution\"\"\"\n        return [agent_action_space.sample() for agent_action_space in self._agents_action_space]",
        "detail": "gym_airsim.envs.gymUtils.action_space",
        "documentation": {}
    },
    {
        "label": "get_cell_sizes",
        "kind": 2,
        "importPath": "gym_airsim.envs.gymUtils.draw",
        "description": "gym_airsim.envs.gymUtils.draw",
        "peekOfCode": "def get_cell_sizes(cell_size: Union[int, list, tuple]):\n    \"\"\"Handle multiple type options of `cell_size`.\n    In order to keep the old API of following functions, as well as add\n    support for non-square grids we need to check cell_size type and\n    extend it appropriately.\n    Args:\n        cell_size: integer of tuple/list size of two with cell size \n            in horizontal and vertical direction.\n    Returns:\n        Horizontal and vertical cell size.",
        "detail": "gym_airsim.envs.gymUtils.draw",
        "documentation": {}
    },
    {
        "label": "draw_grid",
        "kind": 2,
        "importPath": "gym_airsim.envs.gymUtils.draw",
        "description": "gym_airsim.envs.gymUtils.draw",
        "peekOfCode": "def draw_grid(rows, cols, cell_size=50, fill='black', line_color='black'):\n    cell_size_x, cell_size_y = get_cell_sizes(cell_size)\n    width = cols * cell_size_x\n    height = rows * cell_size_y\n    image = Image.new(mode='RGB', size=(width, height), color=fill)\n    # Draw some lines\n    draw = ImageDraw.Draw(image)\n    y_start = 0\n    y_end = image.height\n    for x in range(0, image.width, cell_size_x):",
        "detail": "gym_airsim.envs.gymUtils.draw",
        "documentation": {}
    },
    {
        "label": "fill_cell",
        "kind": 2,
        "importPath": "gym_airsim.envs.gymUtils.draw",
        "description": "gym_airsim.envs.gymUtils.draw",
        "peekOfCode": "def fill_cell(image, pos, cell_size=None, fill='black', margin=0):\n    assert cell_size is not None and 0 <= margin <= 1\n    cell_size_x, cell_size_y = get_cell_sizes(cell_size)\n    col, row = pos\n    row, col = row * cell_size_x, col * cell_size_y\n    margin_x, margin_y = margin * cell_size_x, margin * cell_size_y\n    x, y, x_dash, y_dash = row + margin_x, col + margin_y, row + cell_size_x - margin_x, col + cell_size_y - margin_y\n    ImageDraw.Draw(image).rectangle([(x, y), (x_dash, y_dash)], fill=fill)\ndef write_cell_text(image, text, pos, cell_size=None, fill='black', margin=0):\n    assert cell_size is not None and 0 <= margin <= 1",
        "detail": "gym_airsim.envs.gymUtils.draw",
        "documentation": {}
    },
    {
        "label": "write_cell_text",
        "kind": 2,
        "importPath": "gym_airsim.envs.gymUtils.draw",
        "description": "gym_airsim.envs.gymUtils.draw",
        "peekOfCode": "def write_cell_text(image, text, pos, cell_size=None, fill='black', margin=0):\n    assert cell_size is not None and 0 <= margin <= 1\n    cell_size_x, cell_size_y = get_cell_sizes(cell_size)\n    col, row = pos\n    row, col = row * cell_size_x, col * cell_size_y\n    margin_x, margin_y = margin * cell_size_x, margin * cell_size_y\n    x, y = row + margin_x, col + margin_y\n    ImageDraw.Draw(image).text((x, y), text=text, fill=fill)\ndef draw_cell_outline(image, pos, cell_size=50, fill='black'):\n    cell_size_x, cell_size_y = get_cell_sizes(cell_size)",
        "detail": "gym_airsim.envs.gymUtils.draw",
        "documentation": {}
    },
    {
        "label": "draw_cell_outline",
        "kind": 2,
        "importPath": "gym_airsim.envs.gymUtils.draw",
        "description": "gym_airsim.envs.gymUtils.draw",
        "peekOfCode": "def draw_cell_outline(image, pos, cell_size=50, fill='black'):\n    cell_size_x, cell_size_y = get_cell_sizes(cell_size)\n    col, row = pos\n    row, col = row * cell_size_x, col * cell_size_y\n    ImageDraw.Draw(image).rectangle([(row, col), (row + cell_size_x, col + cell_size_y)], outline=fill, width=3)\ndef draw_circle(image, pos, cell_size=50, fill='black', radius=0.3):\n    cell_size_x, cell_size_y = get_cell_sizes(cell_size)\n    col, row = pos\n    row, col = row * cell_size_x, col * cell_size_y\n    gap_x, gap_y = cell_size_x * radius, cell_size_y * radius",
        "detail": "gym_airsim.envs.gymUtils.draw",
        "documentation": {}
    },
    {
        "label": "draw_circle",
        "kind": 2,
        "importPath": "gym_airsim.envs.gymUtils.draw",
        "description": "gym_airsim.envs.gymUtils.draw",
        "peekOfCode": "def draw_circle(image, pos, cell_size=50, fill='black', radius=0.3):\n    cell_size_x, cell_size_y = get_cell_sizes(cell_size)\n    col, row = pos\n    row, col = row * cell_size_x, col * cell_size_y\n    gap_x, gap_y = cell_size_x * radius, cell_size_y * radius\n    x, y = row + gap_x, col + gap_y\n    x_dash, y_dash = row + cell_size_x - gap_x, col + cell_size_y - gap_y\n    ImageDraw.Draw(image).ellipse([(x, y), (x_dash, y_dash)], outline=fill, fill=fill)\ndef draw_border(image, border_width=1, fill='black'):\n    width, height = image.size",
        "detail": "gym_airsim.envs.gymUtils.draw",
        "documentation": {}
    },
    {
        "label": "draw_border",
        "kind": 2,
        "importPath": "gym_airsim.envs.gymUtils.draw",
        "description": "gym_airsim.envs.gymUtils.draw",
        "peekOfCode": "def draw_border(image, border_width=1, fill='black'):\n    width, height = image.size\n    new_im = Image.new(\"RGB\", size=(width + 2 * border_width, height + 2 * border_width), color=fill)\n    new_im.paste(image, (border_width, border_width))\n    return new_im\ndef draw_score_board(image, score, board_height=30):\n    im_width, im_height = image.size\n    new_im = Image.new(\"RGB\", size=(im_width, im_height + board_height), color='#e1e4e8')\n    new_im.paste(image, (0, board_height))\n    _text = ', '.join([str(round(x, 2)) for x in score])",
        "detail": "gym_airsim.envs.gymUtils.draw",
        "documentation": {}
    },
    {
        "label": "draw_score_board",
        "kind": 2,
        "importPath": "gym_airsim.envs.gymUtils.draw",
        "description": "gym_airsim.envs.gymUtils.draw",
        "peekOfCode": "def draw_score_board(image, score, board_height=30):\n    im_width, im_height = image.size\n    new_im = Image.new(\"RGB\", size=(im_width, im_height + board_height), color='#e1e4e8')\n    new_im.paste(image, (0, board_height))\n    _text = ', '.join([str(round(x, 2)) for x in score])\n    ImageDraw.Draw(new_im).text((10, board_height // 3), text=_text, fill='black')\n    return new_im",
        "detail": "gym_airsim.envs.gymUtils.draw",
        "documentation": {}
    },
    {
        "label": "MultiAgentObservationSpace",
        "kind": 6,
        "importPath": "gym_airsim.envs.gymUtils.observation_space",
        "description": "gym_airsim.envs.gymUtils.observation_space",
        "peekOfCode": "class MultiAgentObservationSpace(list):\n    def __init__(self, agents_observation_space):\n        for x in agents_observation_space:\n            assert isinstance(x, gym.spaces.space.Space)\n        super().__init__(agents_observation_space)\n        self._agents_observation_space = agents_observation_space\n    def sample(self):\n        \"\"\" samples observations for each agent from uniform distribution\"\"\"\n        return [agent_observation_space.sample() for agent_observation_space in self._agents_observation_space]\n    def contains(self, obs):",
        "detail": "gym_airsim.envs.gymUtils.observation_space",
        "documentation": {}
    },
    {
        "label": "MultiAgentActionSpace",
        "kind": 6,
        "importPath": "gym_airsim.envs.airSimEnv",
        "description": "gym_airsim.envs.airSimEnv",
        "peekOfCode": "class MultiAgentActionSpace(list):\n    def __init__(self, agents_action_space):\n        for x in agents_action_space:\n            assert isinstance(x, gym.spaces.space.Space)\n        super(MultiAgentActionSpace, self).__init__(agents_action_space)\n        self._agents_action_space = agents_action_space\n    def sample(self):\n        \"\"\" samples action for each agent from uniform distribution\"\"\"\n        return [agent_action_space.sample() for agent_action_space in self._agents_action_space]\nclass AirSimEnv(gym.Env):",
        "detail": "gym_airsim.envs.airSimEnv",
        "documentation": {}
    },
    {
        "label": "AirSimEnv",
        "kind": 6,
        "importPath": "gym_airsim.envs.airSimEnv",
        "description": "gym_airsim.envs.airSimEnv",
        "peekOfCode": "class AirSimEnv(gym.Env):\n    def __init__(self,n_agents = 3,n_actions = 3, step_cost = -1):\n        self.n_agents = n_agents\n        # left depth, center depth, right depth, yaw\n        self.observation_space = spaces.Box(low=0, high=255, shape=(30, 100))\n        self.states = [np.zeros((30, 100), dtype=np.uint8) for _ in range(n_agents)] \n        self.n_actions = n_actions\n        self.action_space = MultiAgentActionSpace([spaces.Discrete(n_actions) for _ in range(n_agents)])\n        self.agent_names = [v for v in utils.g_airsim_settings[\"Vehicles\"] ]\n        self.episodeN = 0",
        "detail": "gym_airsim.envs.airSimEnv",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "gym_airsim.envs.airSimEnv",
        "description": "gym_airsim.envs.airSimEnv",
        "peekOfCode": "logger = logging.getLogger(__name__)\nimport utils\nimport sys\nimport concurrent.futures\n# print = main.logger.info\n# All coords\n# this format -> (lon,lat,height)\nclass MultiAgentActionSpace(list):\n    def __init__(self, agents_action_space):\n        for x in agents_action_space:",
        "detail": "gym_airsim.envs.airSimEnv",
        "documentation": {}
    },
    {
        "label": "MultiAgentActionSpace",
        "kind": 6,
        "importPath": "gym_airsim.envs.collectEnv",
        "description": "gym_airsim.envs.collectEnv",
        "peekOfCode": "class MultiAgentActionSpace(list):\n    def __init__(self, agents_action_space):\n        for x in agents_action_space:\n            assert isinstance(x, gym.spaces.space.Space)\n        super(MultiAgentActionSpace, self).__init__(agents_action_space)\n        self._agents_action_space = agents_action_space\n    def sample(self):\n        \"\"\" samples action for each agent from uniform distribution\"\"\"\n        return [agent_action_space.sample() for agent_action_space in self._agents_action_space]\nclass ServiceExit(Exception):",
        "detail": "gym_airsim.envs.collectEnv",
        "documentation": {}
    },
    {
        "label": "ServiceExit",
        "kind": 6,
        "importPath": "gym_airsim.envs.collectEnv",
        "description": "gym_airsim.envs.collectEnv",
        "peekOfCode": "class ServiceExit(Exception):\n    \"\"\"\n    Custom exception which is used to trigger the clean exit\n    of all running threads and the main program.\n    \"\"\"\n    pass\ndef service_shutdown(signum, frame):\n    print('Caught signal %d' % signum)\n    raise ServiceExit\nclass CollectEnv(gym.Env):",
        "detail": "gym_airsim.envs.collectEnv",
        "documentation": {}
    },
    {
        "label": "CollectEnv",
        "kind": 6,
        "importPath": "gym_airsim.envs.collectEnv",
        "description": "gym_airsim.envs.collectEnv",
        "peekOfCode": "class CollectEnv(gym.Env):\n    \"\"\"\n    Environment in which the agents have to collect the balls\n    \"\"\"\n    ACTION = [\"LEFT\",\"FRONT\",\"RIGHT\",\"BACK\",]\n    def __init__(\n        self,\n        trajColFlag,\n        size=10,\n        width=None,",
        "detail": "gym_airsim.envs.collectEnv",
        "documentation": {}
    },
    {
        "label": "service_shutdown",
        "kind": 2,
        "importPath": "gym_airsim.envs.collectEnv",
        "description": "gym_airsim.envs.collectEnv",
        "peekOfCode": "def service_shutdown(signum, frame):\n    print('Caught signal %d' % signum)\n    raise ServiceExit\nclass CollectEnv(gym.Env):\n    \"\"\"\n    Environment in which the agents have to collect the balls\n    \"\"\"\n    ACTION = [\"LEFT\",\"FRONT\",\"RIGHT\",\"BACK\",]\n    def __init__(\n        self,",
        "detail": "gym_airsim.envs.collectEnv",
        "documentation": {}
    },
    {
        "label": "MultiAgentActionSpace",
        "kind": 6,
        "importPath": "gym_airsim.envs.collectMTEnv",
        "description": "gym_airsim.envs.collectMTEnv",
        "peekOfCode": "class MultiAgentActionSpace(list):\n    def __init__(self, agents_action_space):\n        for x in agents_action_space:\n            assert isinstance(x, gym.spaces.space.Space)\n        super(MultiAgentActionSpace, self).__init__(agents_action_space)\n        self._agents_action_space = agents_action_space\n    def sample(self):\n        \"\"\" samples action for each agent from uniform distribution\"\"\"\n        return [agent_action_space.sample() for agent_action_space in self._agents_action_space]\nclass Job(threading.Thread):",
        "detail": "gym_airsim.envs.collectMTEnv",
        "documentation": {}
    },
    {
        "label": "Job",
        "kind": 6,
        "importPath": "gym_airsim.envs.collectMTEnv",
        "description": "gym_airsim.envs.collectMTEnv",
        "peekOfCode": "class Job(threading.Thread):\n    def __init__(self,timer = 0.5,callback = None, **kwargs):\n        threading.Thread.__init__(self)\n        self.callback = callback\n        self.timer = timer\n        self.args_dict = kwargs\n        # The shutdown_flag is a threading.Event object that\n        # indicates whether the thread should be terminated.\n        self.shutdown_flag = threading.Event()\n        # ... Other thread setup code here ...",
        "detail": "gym_airsim.envs.collectMTEnv",
        "documentation": {}
    },
    {
        "label": "ServiceExit",
        "kind": 6,
        "importPath": "gym_airsim.envs.collectMTEnv",
        "description": "gym_airsim.envs.collectMTEnv",
        "peekOfCode": "class ServiceExit(Exception):\n    \"\"\"\n    Custom exception which is used to trigger the clean exit\n    of all running threads and the main program.\n    \"\"\"\n    pass\ndef service_shutdown(signum, frame):\n    print('Caught signal %d' % signum)\n    raise ServiceExit\nclass CollectMTEnv(gym.Env):",
        "detail": "gym_airsim.envs.collectMTEnv",
        "documentation": {}
    },
    {
        "label": "CollectMTEnv",
        "kind": 6,
        "importPath": "gym_airsim.envs.collectMTEnv",
        "description": "gym_airsim.envs.collectMTEnv",
        "peekOfCode": "class CollectMTEnv(gym.Env):\n    \"\"\"\n    Environment in which the agents have to collect the balls\n    \"\"\"\n    def __init__(\n        self,\n        trajColFlag,\n        size=10,\n        width=None,\n        height=None,",
        "detail": "gym_airsim.envs.collectMTEnv",
        "documentation": {}
    },
    {
        "label": "service_shutdown",
        "kind": 2,
        "importPath": "gym_airsim.envs.collectMTEnv",
        "description": "gym_airsim.envs.collectMTEnv",
        "peekOfCode": "def service_shutdown(signum, frame):\n    print('Caught signal %d' % signum)\n    raise ServiceExit\nclass CollectMTEnv(gym.Env):\n    \"\"\"\n    Environment in which the agents have to collect the balls\n    \"\"\"\n    def __init__(\n        self,\n        trajColFlag,",
        "detail": "gym_airsim.envs.collectMTEnv",
        "documentation": {}
    },
    {
        "label": "Target",
        "kind": 6,
        "importPath": "gym_airsim.envs.Target",
        "description": "gym_airsim.envs.Target",
        "peekOfCode": "class Target:\n    def __init__(self,id,lat,lon,z=0):\n        self.id = id\n        self.name = \"Target_\" + str(id)\n        self.lat = lat \n        self.lon = lon\n        self.z = z\n        self.x_val , self.y_val , self.z_val  = utils.lonlatToAirSim(lon,lat,z,\n                                # utils.env_cfg.o_x,utils.env_cfg.o_y,utils.env_cfg.o_z)\n                                    0,0,0)",
        "detail": "gym_airsim.envs.Target",
        "documentation": {}
    },
    {
        "label": "TargetManager",
        "kind": 6,
        "importPath": "gym_airsim.envs.Target",
        "description": "gym_airsim.envs.Target",
        "peekOfCode": "class TargetManager:\n    def __init__(self, n_targets):\n        self.targets = {}\n        self.num_targets = n_targets\n        self.ts_allocated = {}\n        self.ts_unallocated = {}\n        self.resetTargets()\n    def getGPSCoo(self,i):\n        if i == 0:\n            return 12.459601163864138, 41.902277040963696",
        "detail": "gym_airsim.envs.Target",
        "documentation": {}
    },
    {
        "label": "MazeEnv",
        "kind": 6,
        "importPath": "gym_maze.envs.maze_env",
        "description": "gym_maze.envs.maze_env",
        "peekOfCode": "class MazeEnv(gym.Env):\n    metadata = {\n        \"render.modes\": [\"human\", \"rgb_array\"],\n    }\n    ACTION = [\"N\",\"S\", \"E\", \"W\"]\n    VISTED_TO_IDX = {\"visited\":16}\n    def __init__(self, maze_file=None, maze_size=None, mode=None, enable_render=True,\n        do_track_trajectories=False,num_goals = 1,verbose = True,human_mode=False, \n        measure_distance = False,n_trajs = None,random_pos = False,seed_num = None,\n        fixed_goals = None, fixed_init_pos = None,visited_cells = []):",
        "detail": "gym_maze.envs.maze_env",
        "documentation": {}
    },
    {
        "label": "MazeView2D",
        "kind": 6,
        "importPath": "gym_maze.envs.maze_view_2d",
        "description": "gym_maze.envs.maze_view_2d",
        "peekOfCode": "class MazeView2D:\n    def __init__(self, maze_name=\"Maze2D\", maze_file_path=None,\n                 maze_size=(30, 30), screen_size=(600, 600),\n                 has_loops=False, num_portals=0, enable_render=True,num_goals = 1,verbose = True,\n                 random_pos=False,np_random=None,n_trajs=None, fixed_goals = None,\n                 fixed_init_pos = None):\n        # if(num_goals<=0 ):\n        #     raise ValueError(\"Error in num_goals parameter\")\n        self.random_pos = random_pos\n        self.fixed_goals = fixed_goals ",
        "detail": "gym_maze.envs.maze_view_2d",
        "documentation": {}
    },
    {
        "label": "Maze",
        "kind": 6,
        "importPath": "gym_maze.envs.maze_view_2d",
        "description": "gym_maze.envs.maze_view_2d",
        "peekOfCode": "class Maze:\n    COMPASS = {\n        \"N\": (0, -1),\n        \"E\": (1, 0),\n        \"S\": (0, 1),\n        \"W\": (-1, 0)\n    }\n    def __init__(self, maze_cells=None, maze_size=(10,10), has_loops=True, num_portals=0,verbose = True):\n        # maze member variables\n        self.maze_cells = maze_cells",
        "detail": "gym_maze.envs.maze_view_2d",
        "documentation": {}
    },
    {
        "label": "Portal",
        "kind": 6,
        "importPath": "gym_maze.envs.maze_view_2d",
        "description": "gym_maze.envs.maze_view_2d",
        "peekOfCode": "class Portal:\n    def __init__(self, *locations):\n        self.__locations = []\n        for location in locations:\n            if isinstance(location, (tuple, list)):\n                self.__locations.append(tuple(location))\n            else:\n                raise ValueError(\"location must be a list or a tuple.\")\n    def teleport(self, cell):\n        if cell in self.locations:",
        "detail": "gym_maze.envs.maze_view_2d",
        "documentation": {}
    },
    {
        "label": "actions_to_value",
        "kind": 2,
        "importPath": "gym_maze.envs.my_maze_generator",
        "description": "gym_maze.envs.my_maze_generator",
        "peekOfCode": "def actions_to_value(actions = None):\n    value = 0x0\n    if not actions:\n        return value \n    if \"N\" in actions:\n        value |= 0x1\n    if \"E\" in actions:\n        value |= 0x2\n    if \"S\" in actions:\n        value |= 0x4",
        "detail": "gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "add_action",
        "kind": 2,
        "importPath": "gym_maze.envs.my_maze_generator",
        "description": "gym_maze.envs.my_maze_generator",
        "peekOfCode": "def add_action(value,action):\n    if \"N\" in action:\n        value |= 0x1\n    if \"E\" in action:\n        value |= 0x2\n    if \"S\" in action:\n        value |= 0x4\n    if \"W\" in action:\n        value |= 0x8\n    return value",
        "detail": "gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "remove_action",
        "kind": 2,
        "importPath": "gym_maze.envs.my_maze_generator",
        "description": "gym_maze.envs.my_maze_generator",
        "peekOfCode": "def remove_action(value,action):\n    if \"N\" in action:\n        value &= ~ 0x1\n    if \"E\" in action:\n        value &= ~ 0x2\n    if \"S\" in action:\n        value &= ~ 0x4\n    if \"W\" in action:\n        value &= ~ 0x8\n    return value",
        "detail": "gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "cell_value",
        "kind": 2,
        "importPath": "gym_maze.envs.my_maze_generator",
        "description": "gym_maze.envs.my_maze_generator",
        "peekOfCode": "def cell_value(r,c,obs_blocks=1,street_blocks=1):\n    if(obs_blocks ==1):\n        if r %2 ==0 or c %2 ==0:\n            return 15\n        elif r != 0 and c !=0 and r != NROWS -1 and c != NCOLS -1 :\n            return 0\n        else:\n            return 15\n    else:\n        if(r % ( obs_blocks+1)==0 or c % (obs_blocks +1 ) == 0 ):",
        "detail": "gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "gym_maze.envs.my_maze_generator",
        "description": "gym_maze.envs.my_maze_generator",
        "peekOfCode": "a = np.load(\"gym_maze/envs/maze_samples/maze2d_001.npy\")\nprint(\"BEFORE\")\nprint(a)\ndef actions_to_value(actions = None):\n    value = 0x0\n    if not actions:\n        return value \n    if \"N\" in actions:\n        value |= 0x1\n    if \"E\" in actions:",
        "detail": "gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "a[1,1]",
        "kind": 5,
        "importPath": "gym_maze.envs.my_maze_generator",
        "description": "gym_maze.envs.my_maze_generator",
        "peekOfCode": "a[1,1] = 0\na[3,3] = 0\na[1,3] = 0\na[3,1] = 0\nav = actions_to_value\na = [\n    [av(\"ES\"),av(\"WE\"),av(\"WES\"),av(\"WE\"),av(\"WS\")],\n    [av(\"NS\"),av(\"\"),    av(\"NS\"),  av(\"\"), av(\"NS\")],\n    [av(\"NES\"),av(\"WE\"),av(\"NEWS\"),av(\"WE\"),av(\"NWS\")],\n    [av(\"NS\"),av(\"\"),av(\"NS\"),av(\"\"),av(\"NS\")],",
        "detail": "gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "a[3,3]",
        "kind": 5,
        "importPath": "gym_maze.envs.my_maze_generator",
        "description": "gym_maze.envs.my_maze_generator",
        "peekOfCode": "a[3,3] = 0\na[1,3] = 0\na[3,1] = 0\nav = actions_to_value\na = [\n    [av(\"ES\"),av(\"WE\"),av(\"WES\"),av(\"WE\"),av(\"WS\")],\n    [av(\"NS\"),av(\"\"),    av(\"NS\"),  av(\"\"), av(\"NS\")],\n    [av(\"NES\"),av(\"WE\"),av(\"NEWS\"),av(\"WE\"),av(\"NWS\")],\n    [av(\"NS\"),av(\"\"),av(\"NS\"),av(\"\"),av(\"NS\")],\n    [av(\"NE\"),av(\"WE\"),av(\"WEN\"),av(\"WE\"),av(\"WN\")],",
        "detail": "gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "a[1,3]",
        "kind": 5,
        "importPath": "gym_maze.envs.my_maze_generator",
        "description": "gym_maze.envs.my_maze_generator",
        "peekOfCode": "a[1,3] = 0\na[3,1] = 0\nav = actions_to_value\na = [\n    [av(\"ES\"),av(\"WE\"),av(\"WES\"),av(\"WE\"),av(\"WS\")],\n    [av(\"NS\"),av(\"\"),    av(\"NS\"),  av(\"\"), av(\"NS\")],\n    [av(\"NES\"),av(\"WE\"),av(\"NEWS\"),av(\"WE\"),av(\"NWS\")],\n    [av(\"NS\"),av(\"\"),av(\"NS\"),av(\"\"),av(\"NS\")],\n    [av(\"NE\"),av(\"WE\"),av(\"WEN\"),av(\"WE\"),av(\"WN\")],\n]",
        "detail": "gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "a[3,1]",
        "kind": 5,
        "importPath": "gym_maze.envs.my_maze_generator",
        "description": "gym_maze.envs.my_maze_generator",
        "peekOfCode": "a[3,1] = 0\nav = actions_to_value\na = [\n    [av(\"ES\"),av(\"WE\"),av(\"WES\"),av(\"WE\"),av(\"WS\")],\n    [av(\"NS\"),av(\"\"),    av(\"NS\"),  av(\"\"), av(\"NS\")],\n    [av(\"NES\"),av(\"WE\"),av(\"NEWS\"),av(\"WE\"),av(\"NWS\")],\n    [av(\"NS\"),av(\"\"),av(\"NS\"),av(\"\"),av(\"NS\")],\n    [av(\"NE\"),av(\"WE\"),av(\"WEN\"),av(\"WE\"),av(\"WN\")],\n]\na = np.array(a)",
        "detail": "gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "av",
        "kind": 5,
        "importPath": "gym_maze.envs.my_maze_generator",
        "description": "gym_maze.envs.my_maze_generator",
        "peekOfCode": "av = actions_to_value\na = [\n    [av(\"ES\"),av(\"WE\"),av(\"WES\"),av(\"WE\"),av(\"WS\")],\n    [av(\"NS\"),av(\"\"),    av(\"NS\"),  av(\"\"), av(\"NS\")],\n    [av(\"NES\"),av(\"WE\"),av(\"NEWS\"),av(\"WE\"),av(\"NWS\")],\n    [av(\"NS\"),av(\"\"),av(\"NS\"),av(\"\"),av(\"NS\")],\n    [av(\"NE\"),av(\"WE\"),av(\"WEN\"),av(\"WE\"),av(\"WN\")],\n]\na = np.array(a)\nprint(\"AFTER\")",
        "detail": "gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "gym_maze.envs.my_maze_generator",
        "description": "gym_maze.envs.my_maze_generator",
        "peekOfCode": "a = [\n    [av(\"ES\"),av(\"WE\"),av(\"WES\"),av(\"WE\"),av(\"WS\")],\n    [av(\"NS\"),av(\"\"),    av(\"NS\"),  av(\"\"), av(\"NS\")],\n    [av(\"NES\"),av(\"WE\"),av(\"NEWS\"),av(\"WE\"),av(\"NWS\")],\n    [av(\"NS\"),av(\"\"),av(\"NS\"),av(\"\"),av(\"NS\")],\n    [av(\"NE\"),av(\"WE\"),av(\"WEN\"),av(\"WE\"),av(\"WN\")],\n]\na = np.array(a)\nprint(\"AFTER\")\nprint(a)",
        "detail": "gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "gym_maze.envs.my_maze_generator",
        "description": "gym_maze.envs.my_maze_generator",
        "peekOfCode": "a = np.array(a)\nprint(\"AFTER\")\nprint(a)\nprint(actions_to_value(\"NEWS\"),actions_to_value(\"\"))\nnp.save(\"gym_maze/envs/maze_samples/maze2d_001.npy\",a)\nNROWS = 43\nNCOLS = 43\nOBS_BLOCKS = 6\n# Each block can be considered 20m x 20m \ndef cell_value(r,c,obs_blocks=1,street_blocks=1):",
        "detail": "gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "NROWS",
        "kind": 5,
        "importPath": "gym_maze.envs.my_maze_generator",
        "description": "gym_maze.envs.my_maze_generator",
        "peekOfCode": "NROWS = 43\nNCOLS = 43\nOBS_BLOCKS = 6\n# Each block can be considered 20m x 20m \ndef cell_value(r,c,obs_blocks=1,street_blocks=1):\n    if(obs_blocks ==1):\n        if r %2 ==0 or c %2 ==0:\n            return 15\n        elif r != 0 and c !=0 and r != NROWS -1 and c != NCOLS -1 :\n            return 0",
        "detail": "gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "NCOLS",
        "kind": 5,
        "importPath": "gym_maze.envs.my_maze_generator",
        "description": "gym_maze.envs.my_maze_generator",
        "peekOfCode": "NCOLS = 43\nOBS_BLOCKS = 6\n# Each block can be considered 20m x 20m \ndef cell_value(r,c,obs_blocks=1,street_blocks=1):\n    if(obs_blocks ==1):\n        if r %2 ==0 or c %2 ==0:\n            return 15\n        elif r != 0 and c !=0 and r != NROWS -1 and c != NCOLS -1 :\n            return 0\n        else:",
        "detail": "gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "OBS_BLOCKS",
        "kind": 5,
        "importPath": "gym_maze.envs.my_maze_generator",
        "description": "gym_maze.envs.my_maze_generator",
        "peekOfCode": "OBS_BLOCKS = 6\n# Each block can be considered 20m x 20m \ndef cell_value(r,c,obs_blocks=1,street_blocks=1):\n    if(obs_blocks ==1):\n        if r %2 ==0 or c %2 ==0:\n            return 15\n        elif r != 0 and c !=0 and r != NROWS -1 and c != NCOLS -1 :\n            return 0\n        else:\n            return 15",
        "detail": "gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "aa",
        "kind": 5,
        "importPath": "gym_maze.envs.my_maze_generator",
        "description": "gym_maze.envs.my_maze_generator",
        "peekOfCode": "aa = [ [cell_value(r,c,obs_blocks=OBS_BLOCKS) for c in range(NCOLS) ] for r in range(NROWS)]\naa = np.array(aa)\nprint('aa BEF: \\n', aa)  \nfor r in range(len(aa)):\n    for c in range( len(aa[0] )):\n        cell = aa[r,c]\n        if r -1 < 0 or  aa[r-1,c] == 0:\n            cell = remove_action( cell,\"N\") \n        if r+1 >= len(aa) or aa[r+1,c] == 0:\n            cell = remove_action( cell,\"S\") ",
        "detail": "gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "aa",
        "kind": 5,
        "importPath": "gym_maze.envs.my_maze_generator",
        "description": "gym_maze.envs.my_maze_generator",
        "peekOfCode": "aa = np.array(aa)\nprint('aa BEF: \\n', aa)  \nfor r in range(len(aa)):\n    for c in range( len(aa[0] )):\n        cell = aa[r,c]\n        if r -1 < 0 or  aa[r-1,c] == 0:\n            cell = remove_action( cell,\"N\") \n        if r+1 >= len(aa) or aa[r+1,c] == 0:\n            cell = remove_action( cell,\"S\") \n        if c -1 < 0 or  aa[r,c-1] == 0:",
        "detail": "gym_maze.envs.my_maze_generator",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "gym_maze.__init__",
        "description": "gym_maze.__init__",
        "peekOfCode": "df = pandas.read_csv(\"fixed_goals.csv\", index_col='name')\n# print(df)\nfixed_goals = df.to_numpy()\ndf = pandas.read_csv(\"init_pos.csv\", index_col='name')\n# print(df)\nfixed_init_pos_list = df.to_numpy()\n# register(\n#      id='uav-maze-v0',\n#      entry_point='gym_maze.envs:MazeEnv',\n#      max_episode_steps=1000,",
        "detail": "gym_maze.__init__",
        "documentation": {}
    },
    {
        "label": "fixed_goals",
        "kind": 5,
        "importPath": "gym_maze.__init__",
        "description": "gym_maze.__init__",
        "peekOfCode": "fixed_goals = df.to_numpy()\ndf = pandas.read_csv(\"init_pos.csv\", index_col='name')\n# print(df)\nfixed_init_pos_list = df.to_numpy()\n# register(\n#      id='uav-maze-v0',\n#      entry_point='gym_maze.envs:MazeEnv',\n#      max_episode_steps=1000,\n# kwargs={\n#     \"maze_file\":\"maze2d_004.npy\",",
        "detail": "gym_maze.__init__",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "gym_maze.__init__",
        "description": "gym_maze.__init__",
        "peekOfCode": "df = pandas.read_csv(\"init_pos.csv\", index_col='name')\n# print(df)\nfixed_init_pos_list = df.to_numpy()\n# register(\n#      id='uav-maze-v0',\n#      entry_point='gym_maze.envs:MazeEnv',\n#      max_episode_steps=1000,\n# kwargs={\n#     \"maze_file\":\"maze2d_004.npy\",\n#     \"enable_render\":False,",
        "detail": "gym_maze.__init__",
        "documentation": {}
    },
    {
        "label": "fixed_init_pos_list",
        "kind": 5,
        "importPath": "gym_maze.__init__",
        "description": "gym_maze.__init__",
        "peekOfCode": "fixed_init_pos_list = df.to_numpy()\n# register(\n#      id='uav-maze-v0',\n#      entry_point='gym_maze.envs:MazeEnv',\n#      max_episode_steps=1000,\n# kwargs={\n#     \"maze_file\":\"maze2d_004.npy\",\n#     \"enable_render\":False,\n#     \"do_track_trajectories\":True,\"num_goals\":None, \"measure_distance\" : True,\n#     \"verbose\" : False,\"n_trajs\":1,\"random_pos\" : False,\"seed_num\" : 12,",
        "detail": "gym_maze.__init__",
        "documentation": {}
    },
    {
        "label": "myInterpolate",
        "kind": 2,
        "importPath": "qtrajectories.script",
        "description": "qtrajectories.script",
        "peekOfCode": "def myInterpolate(arr, n_samples=10 ):\n    res = []\n    for i,p in enumerate(arr):\n        if(i+1 >= len(arr)):\n            break\n        x1,y1,z1 = p[0],p[1],p[2]\n        x2,y2,z2 = arr[i+1][0],arr[i+1][1],arr[i+1][2]\n        step_length = max(abs(x2-x1),abs(y2-y1)) / n_samples\n        for i in range(n_samples):\n            if(x2 > x1):",
        "detail": "qtrajectories.script",
        "documentation": {}
    },
    {
        "label": "simplify_traj",
        "kind": 2,
        "importPath": "qtrajectories.script",
        "description": "qtrajectories.script",
        "peekOfCode": "def simplify_traj(arr):\n    arr = [tuple(x) for x in arr]\n    print(\"ARR\",arr[:20])\n    print(\"\\n\\n\")\n    print(\"UNI:\",np.unique(arr[:20], axis=0) )\n    return np.unique(arr, axis=0)\nfilename = \"q_traj_20202020-12-17--13-36.csv\"\ndf=pandas.read_csv(\"qtrajectories\\csv\\\\\"+filename,delimiter=\",\",usecols=[1,2,3])\nprint(df)\narr = df.to_numpy(dtype=int)",
        "detail": "qtrajectories.script",
        "documentation": {}
    },
    {
        "label": "filename",
        "kind": 5,
        "importPath": "qtrajectories.script",
        "description": "qtrajectories.script",
        "peekOfCode": "filename = \"q_traj_20202020-12-17--13-36.csv\"\ndf=pandas.read_csv(\"qtrajectories\\csv\\\\\"+filename,delimiter=\",\",usecols=[1,2,3])\nprint(df)\narr = df.to_numpy(dtype=int)\n# print('arr: ', arr)\n# st = simplify_traj(arr)\nit = myInterpolate(arr)\n# print(it)\nnp.save(\"qtrajectories\\interpolated\\\\\"+ filename[:-4],it)\n# print(\"myInterpolate\", myInterpolate(arr))",
        "detail": "qtrajectories.script",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "qtrajectories.script",
        "description": "qtrajectories.script",
        "peekOfCode": "arr = df.to_numpy(dtype=int)\n# print('arr: ', arr)\n# st = simplify_traj(arr)\nit = myInterpolate(arr)\n# print(it)\nnp.save(\"qtrajectories\\interpolated\\\\\"+ filename[:-4],it)\n# print(\"myInterpolate\", myInterpolate(arr))\n# x = [p[0] for p in arr]\n# print('x: ', x)\n# y = [p[1] for p in arr]",
        "detail": "qtrajectories.script",
        "documentation": {}
    },
    {
        "label": "it",
        "kind": 5,
        "importPath": "qtrajectories.script",
        "description": "qtrajectories.script",
        "peekOfCode": "it = myInterpolate(arr)\n# print(it)\nnp.save(\"qtrajectories\\interpolated\\\\\"+ filename[:-4],it)\n# print(\"myInterpolate\", myInterpolate(arr))\n# x = [p[0] for p in arr]\n# print('x: ', x)\n# y = [p[1] for p in arr]\n# print( interp1d(x, y, kind='cubic'))\n# pathXY = [0 0; 1 1; 10 2; 12 3]\n# stepLengths = sqrt(sum(diff(pathXY,[],1).^2,2))",
        "detail": "qtrajectories.script",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "results.plot",
        "description": "results.plot",
        "peekOfCode": "x = []\ny = []\nwith open('rewards.csv','r') as csvfile:\n    plots = csv.reader(csvfile, delimiter=',')\n    for i,row in enumerate(plots):\n        if(i==0 or row[0]==\"E\"):\n            continue\n        x.append(int(row[0]))\n        y.append( float(row[1]))\n# plt.plot(x,y, label='Loaded from file!')",
        "detail": "results.plot",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "results.plot",
        "description": "results.plot",
        "peekOfCode": "y = []\nwith open('rewards.csv','r') as csvfile:\n    plots = csv.reader(csvfile, delimiter=',')\n    for i,row in enumerate(plots):\n        if(i==0 or row[0]==\"E\"):\n            continue\n        x.append(int(row[0]))\n        y.append( float(row[1]))\n# plt.plot(x,y, label='Loaded from file!')\nplt.plot(x,y)",
        "detail": "results.plot",
        "documentation": {}
    },
    {
        "label": "rng",
        "kind": 5,
        "importPath": "scripts.test_tree",
        "description": "scripts.test_tree",
        "peekOfCode": "rng = np.random.RandomState(0)\nX = rng.random_sample((10, 3))  # 10 points in 3 dimensions\nX = np.vstack( (X,np.array([0.1,0.1,0.1])) )\nX = np.vstack( (X,np.array([-0.1,-0.1,-0.1])) )\n# X = np.array(X)\nprint(X)\ntree = KDTree(X, leaf_size=2)     # doctest: +SKIP\nres =tree.query_radius([[0,0,0]], r=0.3, count_only=True)\nprint(res)\nprint([ X[i] for i in res])  # indices of neighbors within distance 0.3",
        "detail": "scripts.test_tree",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 5,
        "importPath": "scripts.test_tree",
        "description": "scripts.test_tree",
        "peekOfCode": "X = rng.random_sample((10, 3))  # 10 points in 3 dimensions\nX = np.vstack( (X,np.array([0.1,0.1,0.1])) )\nX = np.vstack( (X,np.array([-0.1,-0.1,-0.1])) )\n# X = np.array(X)\nprint(X)\ntree = KDTree(X, leaf_size=2)     # doctest: +SKIP\nres =tree.query_radius([[0,0,0]], r=0.3, count_only=True)\nprint(res)\nprint([ X[i] for i in res])  # indices of neighbors within distance 0.3",
        "detail": "scripts.test_tree",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 5,
        "importPath": "scripts.test_tree",
        "description": "scripts.test_tree",
        "peekOfCode": "X = np.vstack( (X,np.array([0.1,0.1,0.1])) )\nX = np.vstack( (X,np.array([-0.1,-0.1,-0.1])) )\n# X = np.array(X)\nprint(X)\ntree = KDTree(X, leaf_size=2)     # doctest: +SKIP\nres =tree.query_radius([[0,0,0]], r=0.3, count_only=True)\nprint(res)\nprint([ X[i] for i in res])  # indices of neighbors within distance 0.3",
        "detail": "scripts.test_tree",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 5,
        "importPath": "scripts.test_tree",
        "description": "scripts.test_tree",
        "peekOfCode": "X = np.vstack( (X,np.array([-0.1,-0.1,-0.1])) )\n# X = np.array(X)\nprint(X)\ntree = KDTree(X, leaf_size=2)     # doctest: +SKIP\nres =tree.query_radius([[0,0,0]], r=0.3, count_only=True)\nprint(res)\nprint([ X[i] for i in res])  # indices of neighbors within distance 0.3",
        "detail": "scripts.test_tree",
        "documentation": {}
    },
    {
        "label": "tree",
        "kind": 5,
        "importPath": "scripts.test_tree",
        "description": "scripts.test_tree",
        "peekOfCode": "tree = KDTree(X, leaf_size=2)     # doctest: +SKIP\nres =tree.query_radius([[0,0,0]], r=0.3, count_only=True)\nprint(res)\nprint([ X[i] for i in res])  # indices of neighbors within distance 0.3",
        "detail": "scripts.test_tree",
        "documentation": {}
    },
    {
        "label": "check_pos",
        "kind": 2,
        "importPath": "scripts.track_trajectories",
        "description": "scripts.track_trajectories",
        "peekOfCode": "def check_pos(vName):\n    p = client.simGetGroundTruthKinematics(vehicle_name = vName).position\n    ts = time.time()\n    print(\"[\",vName,\"]\",(p.x_val,p.y_val,p.z_val) )\n    return p,ts\ndef signal_handler(sig, frame):\n    print('You pressed Ctrl+C! Exiting...')\n    utils.pkl_save_obj(trajectories,\"trajectory_\",file_timestamp)\n    sys.exit(0)\nif __name__ == \"__main__\":",
        "detail": "scripts.track_trajectories",
        "documentation": {}
    },
    {
        "label": "signal_handler",
        "kind": 2,
        "importPath": "scripts.track_trajectories",
        "description": "scripts.track_trajectories",
        "peekOfCode": "def signal_handler(sig, frame):\n    print('You pressed Ctrl+C! Exiting...')\n    utils.pkl_save_obj(trajectories,\"trajectory_\",file_timestamp)\n    sys.exit(0)\nif __name__ == \"__main__\":\n    signal.signal(signal.SIGINT, signal_handler)\n    print('Press Ctrl+C TO STOP')\n    client = airsim.MultirotorClient()\n    # connect to the AirSim simulator\n    print(client.confirmConnection() )",
        "detail": "scripts.track_trajectories",
        "documentation": {}
    },
    {
        "label": "timestep",
        "kind": 5,
        "importPath": "scripts.track_trajectories",
        "description": "scripts.track_trajectories",
        "peekOfCode": "timestep = 0.1 # s\nmonitor_timeout =  20 * 60 # s\nmonitor_iterations = int(monitor_timeout // timestep)\ndoTimestamp = False\ndef check_pos(vName):\n    p = client.simGetGroundTruthKinematics(vehicle_name = vName).position\n    ts = time.time()\n    print(\"[\",vName,\"]\",(p.x_val,p.y_val,p.z_val) )\n    return p,ts\ndef signal_handler(sig, frame):",
        "detail": "scripts.track_trajectories",
        "documentation": {}
    },
    {
        "label": "monitor_timeout",
        "kind": 5,
        "importPath": "scripts.track_trajectories",
        "description": "scripts.track_trajectories",
        "peekOfCode": "monitor_timeout =  20 * 60 # s\nmonitor_iterations = int(monitor_timeout // timestep)\ndoTimestamp = False\ndef check_pos(vName):\n    p = client.simGetGroundTruthKinematics(vehicle_name = vName).position\n    ts = time.time()\n    print(\"[\",vName,\"]\",(p.x_val,p.y_val,p.z_val) )\n    return p,ts\ndef signal_handler(sig, frame):\n    print('You pressed Ctrl+C! Exiting...')",
        "detail": "scripts.track_trajectories",
        "documentation": {}
    },
    {
        "label": "monitor_iterations",
        "kind": 5,
        "importPath": "scripts.track_trajectories",
        "description": "scripts.track_trajectories",
        "peekOfCode": "monitor_iterations = int(monitor_timeout // timestep)\ndoTimestamp = False\ndef check_pos(vName):\n    p = client.simGetGroundTruthKinematics(vehicle_name = vName).position\n    ts = time.time()\n    print(\"[\",vName,\"]\",(p.x_val,p.y_val,p.z_val) )\n    return p,ts\ndef signal_handler(sig, frame):\n    print('You pressed Ctrl+C! Exiting...')\n    utils.pkl_save_obj(trajectories,\"trajectory_\",file_timestamp)",
        "detail": "scripts.track_trajectories",
        "documentation": {}
    },
    {
        "label": "doTimestamp",
        "kind": 5,
        "importPath": "scripts.track_trajectories",
        "description": "scripts.track_trajectories",
        "peekOfCode": "doTimestamp = False\ndef check_pos(vName):\n    p = client.simGetGroundTruthKinematics(vehicle_name = vName).position\n    ts = time.time()\n    print(\"[\",vName,\"]\",(p.x_val,p.y_val,p.z_val) )\n    return p,ts\ndef signal_handler(sig, frame):\n    print('You pressed Ctrl+C! Exiting...')\n    utils.pkl_save_obj(trajectories,\"trajectory_\",file_timestamp)\n    sys.exit(0)",
        "detail": "scripts.track_trajectories",
        "documentation": {}
    },
    {
        "label": "TRAJECTORIES_FOLDER",
        "kind": 5,
        "importPath": "scripts.trajectories_fix",
        "description": "scripts.trajectories_fix",
        "peekOfCode": "TRAJECTORIES_FOLDER = \"./trajectories/\"\nAIRSIM_SETTINGS_FOLDER = 'C:/Users/gioca/OneDrive/Documents/Airsim/'\nif __name__ == \"__main__\":  \n    parser = argparse.ArgumentParser(description='Traj fixer')\n    parser.add_argument('--folder', type=str, required = True,\n        help='folder of trajectory (default: %(default)s)')\n    # parser.add_argument('--debug', type=bool, default=False,\n    # help='Log into file (default: %(default)s)')\n    # parser.add_argument('--track-trajectories', type=bool, default=True,\n    #     help='Track trajectories into file (default: %(default)s)')",
        "detail": "scripts.trajectories_fix",
        "documentation": {}
    },
    {
        "label": "AIRSIM_SETTINGS_FOLDER",
        "kind": 5,
        "importPath": "scripts.trajectories_fix",
        "description": "scripts.trajectories_fix",
        "peekOfCode": "AIRSIM_SETTINGS_FOLDER = 'C:/Users/gioca/OneDrive/Documents/Airsim/'\nif __name__ == \"__main__\":  \n    parser = argparse.ArgumentParser(description='Traj fixer')\n    parser.add_argument('--folder', type=str, required = True,\n        help='folder of trajectory (default: %(default)s)')\n    # parser.add_argument('--debug', type=bool, default=False,\n    # help='Log into file (default: %(default)s)')\n    # parser.add_argument('--track-trajectories', type=bool, default=True,\n    #     help='Track trajectories into file (default: %(default)s)')\n    args = parser.parse_args()",
        "detail": "scripts.trajectories_fix",
        "documentation": {}
    },
    {
        "label": "traj_files_list",
        "kind": 5,
        "importPath": "2d_to_airsim_simulate",
        "description": "2d_to_airsim_simulate",
        "peekOfCode": "traj_files_list = os.listdir(TRAJECTORIES_FOLDER)\ntrajs = []\nfor tf in traj_files_list:\n        df = pandas.read_csv(TRAJECTORIES_FOLDER+tf,delimiter=\",\",index_col=\"index\")\n        # print(df)\n        traj = df.to_numpy()\n        trajs.append(traj)\nprint(trajs)\ntrees = utils.build_trees(trajs)\ntrajs3d, zs = utils.avoid_collision(trajs,trees,300,0,20,3)",
        "detail": "2d_to_airsim_simulate",
        "documentation": {}
    },
    {
        "label": "trajs",
        "kind": 5,
        "importPath": "2d_to_airsim_simulate",
        "description": "2d_to_airsim_simulate",
        "peekOfCode": "trajs = []\nfor tf in traj_files_list:\n        df = pandas.read_csv(TRAJECTORIES_FOLDER+tf,delimiter=\",\",index_col=\"index\")\n        # print(df)\n        traj = df.to_numpy()\n        trajs.append(traj)\nprint(trajs)\ntrees = utils.build_trees(trajs)\ntrajs3d, zs = utils.avoid_collision(trajs,trees,300,0,20,3)\nfor idx,traj in enumerate(trajs3d):",
        "detail": "2d_to_airsim_simulate",
        "documentation": {}
    },
    {
        "label": "trees",
        "kind": 5,
        "importPath": "2d_to_airsim_simulate",
        "description": "2d_to_airsim_simulate",
        "peekOfCode": "trees = utils.build_trees(trajs)\ntrajs3d, zs = utils.avoid_collision(trajs,trees,300,0,20,3)\nfor idx,traj in enumerate(trajs3d):\n        traj = np.array(traj)\n        df = pandas.DataFrame({'x_pos': traj[:, 0], 'y_pos': traj[:, 1],\n        'z_pos': traj[:, 2]})\n        df.index.name = \"index\"\n        df.to_csv(\"trajectories_3d/csv/\"+traj_files_list[idx])",
        "detail": "2d_to_airsim_simulate",
        "documentation": {}
    },
    {
        "label": "a_logger",
        "kind": 5,
        "importPath": "3dGenerator",
        "description": "3dGenerator",
        "peekOfCode": "a_logger = logging.getLogger(\"collisionTesterLog\")\na_logger.setLevel(logging.DEBUG)\noutput_file_handler = logging.FileHandler(\"finalCollisionTimeTester.log\")\nstdout_handler = logging.StreamHandler(sys.stdout)\na_logger.addHandler(output_file_handler)\na_logger.addHandler(stdout_handler)\na_logger.debug(\n   \"\\nRUNNING EXP at: \" + str(datetime.datetime.now().strftime('%Y-%m-%d--%H:%M:%S'))+\"\\n\"\n)\n# RANDOM SEED",
        "detail": "3dGenerator",
        "documentation": {}
    },
    {
        "label": "output_file_handler",
        "kind": 5,
        "importPath": "3dGenerator",
        "description": "3dGenerator",
        "peekOfCode": "output_file_handler = logging.FileHandler(\"finalCollisionTimeTester.log\")\nstdout_handler = logging.StreamHandler(sys.stdout)\na_logger.addHandler(output_file_handler)\na_logger.addHandler(stdout_handler)\na_logger.debug(\n   \"\\nRUNNING EXP at: \" + str(datetime.datetime.now().strftime('%Y-%m-%d--%H:%M:%S'))+\"\\n\"\n)\n# RANDOM SEED\n# a_logger.debug(\"SEED: \"+ str(trajs_utils.setRandomSeed())  )\na_logger.debug(\"SEED: \"+ str(trajs_utils.setSeed(999))  )",
        "detail": "3dGenerator",
        "documentation": {}
    },
    {
        "label": "stdout_handler",
        "kind": 5,
        "importPath": "3dGenerator",
        "description": "3dGenerator",
        "peekOfCode": "stdout_handler = logging.StreamHandler(sys.stdout)\na_logger.addHandler(output_file_handler)\na_logger.addHandler(stdout_handler)\na_logger.debug(\n   \"\\nRUNNING EXP at: \" + str(datetime.datetime.now().strftime('%Y-%m-%d--%H:%M:%S'))+\"\\n\"\n)\n# RANDOM SEED\n# a_logger.debug(\"SEED: \"+ str(trajs_utils.setRandomSeed())  )\na_logger.debug(\"SEED: \"+ str(trajs_utils.setSeed(999))  )\ntolerances = [0,0.2]",
        "detail": "3dGenerator",
        "documentation": {}
    },
    {
        "label": "tolerances",
        "kind": 5,
        "importPath": "3dGenerator",
        "description": "3dGenerator",
        "peekOfCode": "tolerances = [0,0.2]\nn_trajectories = [300,300,10,10,50,50,100,100]\nNUM_TESTS = 6\nOUT_FOLDER = \"randTrajs/\"\nexp_path = OUT_FOLDER + \"experiment/\"\ncreated = False\ni=1\nwhile(not created ):\n   try:\n      exp_path = exp_path[:-1]+ str(i) +\"/\"",
        "detail": "3dGenerator",
        "documentation": {}
    },
    {
        "label": "n_trajectories",
        "kind": 5,
        "importPath": "3dGenerator",
        "description": "3dGenerator",
        "peekOfCode": "n_trajectories = [300,300,10,10,50,50,100,100]\nNUM_TESTS = 6\nOUT_FOLDER = \"randTrajs/\"\nexp_path = OUT_FOLDER + \"experiment/\"\ncreated = False\ni=1\nwhile(not created ):\n   try:\n      exp_path = exp_path[:-1]+ str(i) +\"/\"\n      os.mkdir(exp_path)",
        "detail": "3dGenerator",
        "documentation": {}
    },
    {
        "label": "NUM_TESTS",
        "kind": 5,
        "importPath": "3dGenerator",
        "description": "3dGenerator",
        "peekOfCode": "NUM_TESTS = 6\nOUT_FOLDER = \"randTrajs/\"\nexp_path = OUT_FOLDER + \"experiment/\"\ncreated = False\ni=1\nwhile(not created ):\n   try:\n      exp_path = exp_path[:-1]+ str(i) +\"/\"\n      os.mkdir(exp_path)\n      print (\"Successfully created the directory %s \" % exp_path)",
        "detail": "3dGenerator",
        "documentation": {}
    },
    {
        "label": "OUT_FOLDER",
        "kind": 5,
        "importPath": "3dGenerator",
        "description": "3dGenerator",
        "peekOfCode": "OUT_FOLDER = \"randTrajs/\"\nexp_path = OUT_FOLDER + \"experiment/\"\ncreated = False\ni=1\nwhile(not created ):\n   try:\n      exp_path = exp_path[:-1]+ str(i) +\"/\"\n      os.mkdir(exp_path)\n      print (\"Successfully created the directory %s \" % exp_path)\n      created = True",
        "detail": "3dGenerator",
        "documentation": {}
    },
    {
        "label": "exp_path",
        "kind": 5,
        "importPath": "3dGenerator",
        "description": "3dGenerator",
        "peekOfCode": "exp_path = OUT_FOLDER + \"experiment/\"\ncreated = False\ni=1\nwhile(not created ):\n   try:\n      exp_path = exp_path[:-1]+ str(i) +\"/\"\n      os.mkdir(exp_path)\n      print (\"Successfully created the directory %s \" % exp_path)\n      created = True\n   except OSError:",
        "detail": "3dGenerator",
        "documentation": {}
    },
    {
        "label": "created",
        "kind": 5,
        "importPath": "3dGenerator",
        "description": "3dGenerator",
        "peekOfCode": "created = False\ni=1\nwhile(not created ):\n   try:\n      exp_path = exp_path[:-1]+ str(i) +\"/\"\n      os.mkdir(exp_path)\n      print (\"Successfully created the directory %s \" % exp_path)\n      created = True\n   except OSError:\n      print (\"Creation of the directory %s failed\" % exp_path)",
        "detail": "3dGenerator",
        "documentation": {}
    },
    {
        "label": "SaveOnBestTrainingRewardCallback",
        "kind": 6,
        "importPath": "baseline_main",
        "description": "baseline_main",
        "peekOfCode": "class SaveOnBestTrainingRewardCallback(BaseCallback):\n    \"\"\"\n    Callback for saving a model (the check is done every ``check_freq`` steps)\n    based on the training reward (in practice, we recommend using ``EvalCallback``).\n    :param check_freq: (int)\n    :param log_dir: (str) Path to the folder where the model will be saved.\n      It must contains the file created by the ``Monitor`` wrapper.\n    :param verbose: (int)\n    \"\"\"\n    def __init__(self, check_freq: int, log_dir: str, verbose=1):",
        "detail": "baseline_main",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "baseline_main",
        "description": "baseline_main",
        "peekOfCode": "parser = argparse.ArgumentParser(description='RL for ma-gym')\nparser.add_argument('--episodes', type=int, default=100,\n                    help='episodes (default: %(default)s)')\nparser.add_argument('--n-goals', type=int, default=1,\n                    help='episodes (default: %(default)s)')\nparser.add_argument('--actions-timeout', type=int, default=100,\n                    help='episodes (default: %(default)s)')\nparser.add_argument(\"--n-trajs\",type=int, default=5,\n                        help='num trajs to track (default: %(default)s)')\nparser.add_argument('--n-agents', type=int, default=1,",
        "detail": "baseline_main",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "baseline_main",
        "description": "baseline_main",
        "peekOfCode": "args = parser.parse_args()\n# env = gym.make(\"AirSimEnv-v1\")\nif(args.debug):\n    logger = utils.initiate_logger()\n    print = logger.info\ndf = pandas.read_csv(\"fixed_goals.csv\", index_col='name')\n# print(df)\nfixed_goals = df.to_numpy()\nif(len(fixed_goals)<1):\n    raise Exception(\"Inavalid num of goals\")",
        "detail": "baseline_main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "baseline_main",
        "description": "baseline_main",
        "peekOfCode": "df = pandas.read_csv(\"fixed_goals.csv\", index_col='name')\n# print(df)\nfixed_goals = df.to_numpy()\nif(len(fixed_goals)<1):\n    raise Exception(\"Inavalid num of goals\")\n# print('fixed_goals: ', fixed_goals)\ndf = pandas.read_csv(\"init_pos.csv\", index_col='name')\n# print(df)\nfixed_init_pos_list = df.to_numpy()\n# print('fixed_goals: ', fixed_goals)",
        "detail": "baseline_main",
        "documentation": {}
    },
    {
        "label": "fixed_goals",
        "kind": 5,
        "importPath": "baseline_main",
        "description": "baseline_main",
        "peekOfCode": "fixed_goals = df.to_numpy()\nif(len(fixed_goals)<1):\n    raise Exception(\"Inavalid num of goals\")\n# print('fixed_goals: ', fixed_goals)\ndf = pandas.read_csv(\"init_pos.csv\", index_col='name')\n# print(df)\nfixed_init_pos_list = df.to_numpy()\n# print('fixed_goals: ', fixed_goals)\nepisode_cooldown = 3\nACTION_TO_IDX = {\"LEFT\":0, \"FRONT\":1, \"RIGHT\":2,\"BACK\" : 3}",
        "detail": "baseline_main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "baseline_main",
        "description": "baseline_main",
        "peekOfCode": "df = pandas.read_csv(\"init_pos.csv\", index_col='name')\n# print(df)\nfixed_init_pos_list = df.to_numpy()\n# print('fixed_goals: ', fixed_goals)\nepisode_cooldown = 3\nACTION_TO_IDX = {\"LEFT\":0, \"FRONT\":1, \"RIGHT\":2,\"BACK\" : 3}\nIDX_TO_ACTION =  {0:\"LEFT\",1:\"FRONT\",2:\"RIGHT\",3:\"BACK\"}\nSTD_MAZE = \"maze2d_002.npy\"\nINTERACTIVE = False\nOUT_FORMAT = \"csv\"",
        "detail": "baseline_main",
        "documentation": {}
    },
    {
        "label": "fixed_init_pos_list",
        "kind": 5,
        "importPath": "baseline_main",
        "description": "baseline_main",
        "peekOfCode": "fixed_init_pos_list = df.to_numpy()\n# print('fixed_goals: ', fixed_goals)\nepisode_cooldown = 3\nACTION_TO_IDX = {\"LEFT\":0, \"FRONT\":1, \"RIGHT\":2,\"BACK\" : 3}\nIDX_TO_ACTION =  {0:\"LEFT\",1:\"FRONT\",2:\"RIGHT\",3:\"BACK\"}\nSTD_MAZE = \"maze2d_002.npy\"\nINTERACTIVE = False\nOUT_FORMAT = \"csv\"\nSEED = 12\nTIMESTEPS = int(1e5)",
        "detail": "baseline_main",
        "documentation": {}
    },
    {
        "label": "episode_cooldown",
        "kind": 5,
        "importPath": "baseline_main",
        "description": "baseline_main",
        "peekOfCode": "episode_cooldown = 3\nACTION_TO_IDX = {\"LEFT\":0, \"FRONT\":1, \"RIGHT\":2,\"BACK\" : 3}\nIDX_TO_ACTION =  {0:\"LEFT\",1:\"FRONT\",2:\"RIGHT\",3:\"BACK\"}\nSTD_MAZE = \"maze2d_002.npy\"\nINTERACTIVE = False\nOUT_FORMAT = \"csv\"\nSEED = 12\nTIMESTEPS = int(1e5)\nmaze_file = STD_MAZE\nmode = \"train\"",
        "detail": "baseline_main",
        "documentation": {}
    },
    {
        "label": "ACTION_TO_IDX",
        "kind": 5,
        "importPath": "baseline_main",
        "description": "baseline_main",
        "peekOfCode": "ACTION_TO_IDX = {\"LEFT\":0, \"FRONT\":1, \"RIGHT\":2,\"BACK\" : 3}\nIDX_TO_ACTION =  {0:\"LEFT\",1:\"FRONT\",2:\"RIGHT\",3:\"BACK\"}\nSTD_MAZE = \"maze2d_002.npy\"\nINTERACTIVE = False\nOUT_FORMAT = \"csv\"\nSEED = 12\nTIMESTEPS = int(1e5)\nmaze_file = STD_MAZE\nmode = \"train\"\nfor fixed_init_pos in fixed_init_pos_list:",
        "detail": "baseline_main",
        "documentation": {}
    },
    {
        "label": "IDX_TO_ACTION",
        "kind": 5,
        "importPath": "baseline_main",
        "description": "baseline_main",
        "peekOfCode": "IDX_TO_ACTION =  {0:\"LEFT\",1:\"FRONT\",2:\"RIGHT\",3:\"BACK\"}\nSTD_MAZE = \"maze2d_002.npy\"\nINTERACTIVE = False\nOUT_FORMAT = \"csv\"\nSEED = 12\nTIMESTEPS = int(1e5)\nmaze_file = STD_MAZE\nmode = \"train\"\nfor fixed_init_pos in fixed_init_pos_list:\n    env = MazeEnv( maze_file = maze_file,                  ",
        "detail": "baseline_main",
        "documentation": {}
    },
    {
        "label": "STD_MAZE",
        "kind": 5,
        "importPath": "baseline_main",
        "description": "baseline_main",
        "peekOfCode": "STD_MAZE = \"maze2d_002.npy\"\nINTERACTIVE = False\nOUT_FORMAT = \"csv\"\nSEED = 12\nTIMESTEPS = int(1e5)\nmaze_file = STD_MAZE\nmode = \"train\"\nfor fixed_init_pos in fixed_init_pos_list:\n    env = MazeEnv( maze_file = maze_file,                  \n                # maze_file=\"maze\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M') ),",
        "detail": "baseline_main",
        "documentation": {}
    },
    {
        "label": "INTERACTIVE",
        "kind": 5,
        "importPath": "baseline_main",
        "description": "baseline_main",
        "peekOfCode": "INTERACTIVE = False\nOUT_FORMAT = \"csv\"\nSEED = 12\nTIMESTEPS = int(1e5)\nmaze_file = STD_MAZE\nmode = \"train\"\nfor fixed_init_pos in fixed_init_pos_list:\n    env = MazeEnv( maze_file = maze_file,                  \n                # maze_file=\"maze\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M') ),\n                                            maze_size=(640, 640), ",
        "detail": "baseline_main",
        "documentation": {}
    },
    {
        "label": "OUT_FORMAT",
        "kind": 5,
        "importPath": "baseline_main",
        "description": "baseline_main",
        "peekOfCode": "OUT_FORMAT = \"csv\"\nSEED = 12\nTIMESTEPS = int(1e5)\nmaze_file = STD_MAZE\nmode = \"train\"\nfor fixed_init_pos in fixed_init_pos_list:\n    env = MazeEnv( maze_file = maze_file,                  \n                # maze_file=\"maze\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M') ),\n                                            maze_size=(640, 640), \n                                            enable_render= args.enable_render if(mode==\"train\") else True,",
        "detail": "baseline_main",
        "documentation": {}
    },
    {
        "label": "SEED",
        "kind": 5,
        "importPath": "baseline_main",
        "description": "baseline_main",
        "peekOfCode": "SEED = 12\nTIMESTEPS = int(1e5)\nmaze_file = STD_MAZE\nmode = \"train\"\nfor fixed_init_pos in fixed_init_pos_list:\n    env = MazeEnv( maze_file = maze_file,                  \n                # maze_file=\"maze\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M') ),\n                                            maze_size=(640, 640), \n                                            enable_render= args.enable_render if(mode==\"train\") else True,\n                                            do_track_trajectories=True,num_goals=args.n_goals, measure_distance = True,",
        "detail": "baseline_main",
        "documentation": {}
    },
    {
        "label": "TIMESTEPS",
        "kind": 5,
        "importPath": "baseline_main",
        "description": "baseline_main",
        "peekOfCode": "TIMESTEPS = int(1e5)\nmaze_file = STD_MAZE\nmode = \"train\"\nfor fixed_init_pos in fixed_init_pos_list:\n    env = MazeEnv( maze_file = maze_file,                  \n                # maze_file=\"maze\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M') ),\n                                            maze_size=(640, 640), \n                                            enable_render= args.enable_render if(mode==\"train\") else True,\n                                            do_track_trajectories=True,num_goals=args.n_goals, measure_distance = True,\n                                            verbose = args.v,n_trajs=args.n_trajs,random_pos = args.random_pos,seed_num = SEED,",
        "detail": "baseline_main",
        "documentation": {}
    },
    {
        "label": "maze_file",
        "kind": 5,
        "importPath": "baseline_main",
        "description": "baseline_main",
        "peekOfCode": "maze_file = STD_MAZE\nmode = \"train\"\nfor fixed_init_pos in fixed_init_pos_list:\n    env = MazeEnv( maze_file = maze_file,                  \n                # maze_file=\"maze\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M') ),\n                                            maze_size=(640, 640), \n                                            enable_render= args.enable_render if(mode==\"train\") else True,\n                                            do_track_trajectories=True,num_goals=args.n_goals, measure_distance = True,\n                                            verbose = args.v,n_trajs=args.n_trajs,random_pos = args.random_pos,seed_num = SEED,\n                                            fixed_goals = fixed_goals,fixed_init_pos = fixed_init_pos)",
        "detail": "baseline_main",
        "documentation": {}
    },
    {
        "label": "mode",
        "kind": 5,
        "importPath": "baseline_main",
        "description": "baseline_main",
        "peekOfCode": "mode = \"train\"\nfor fixed_init_pos in fixed_init_pos_list:\n    env = MazeEnv( maze_file = maze_file,                  \n                # maze_file=\"maze\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M') ),\n                                            maze_size=(640, 640), \n                                            enable_render= args.enable_render if(mode==\"train\") else True,\n                                            do_track_trajectories=True,num_goals=args.n_goals, measure_distance = True,\n                                            verbose = args.v,n_trajs=args.n_trajs,random_pos = args.random_pos,seed_num = SEED,\n                                            fixed_goals = fixed_goals,fixed_init_pos = fixed_init_pos)\n    # Create log dir",
        "detail": "baseline_main",
        "documentation": {}
    },
    {
        "label": "generate_flight_id",
        "kind": 2,
        "importPath": "eurocontrolConverter",
        "description": "eurocontrolConverter",
        "peekOfCode": "def generate_flight_id():\n    # Generate a unique ID for a flight.\n    id = uuid.uuid1()\n    flight_id = id.fields[0]\n    return flight_id\ndef flights_points( data, file_name):\n    # 'data' is an ordered list represented in this way --> [ [flights_IDs], [number_waypoints_sequence], \n    #    [crossingg_waypoints_times], [flights_levels], [Latitudes], [Longitutes] ].\n    # This method take 'data' as input and put it into a .csv file (by creating it) according to the Eurocontrol standard template.\n    header = True",
        "detail": "eurocontrolConverter",
        "documentation": {}
    },
    {
        "label": "flights_points",
        "kind": 2,
        "importPath": "eurocontrolConverter",
        "description": "eurocontrolConverter",
        "peekOfCode": "def flights_points( data, file_name):\n    # 'data' is an ordered list represented in this way --> [ [flights_IDs], [number_waypoints_sequence], \n    #    [crossingg_waypoints_times], [flights_levels], [Latitudes], [Longitutes] ].\n    # This method take 'data' as input and put it into a .csv file (by creating it) according to the Eurocontrol standard template.\n    header = True\n    d = {}\n    fields = len(COLUMNS_NAMES)\n    for flight in data:\n        for field in range(fields):\n            d[COLUMNS_NAMES[field]] = flight[field]",
        "detail": "eurocontrolConverter",
        "documentation": {}
    },
    {
        "label": "data_to_csv",
        "kind": 2,
        "importPath": "eurocontrolConverter",
        "description": "eurocontrolConverter",
        "peekOfCode": "def data_to_csv(data,filename,header=True):\n   d={}\n   fields = len(COLUMNS_NAMES)\n   for row in data:\n        for field in range(fields):\n            if COLUMNS_NAMES[field] not in d:\n               d[COLUMNS_NAMES[field]] = [row[field]]\n            else:\n               d[COLUMNS_NAMES[field]].append( row[field])\n   df = pd.DataFrame.from_dict(d)",
        "detail": "eurocontrolConverter",
        "documentation": {}
    },
    {
        "label": "extract_waypoints_from_flights_points_csv",
        "kind": 2,
        "importPath": "eurocontrolConverter",
        "description": "eurocontrolConverter",
        "peekOfCode": "def extract_waypoints_from_flights_points_csv( file_name):\n    # Read a .csv file (according to the Eurocontrol standard template) and return a dictionary in which each key is a flight ID and\n    # the corresponding values are the Z,Y,X coordinates of the crossed waypoints for that considered flight. \n    n_names = len(COLUMNS_NAMES)\n    file = pd.read_csv(file_name, header=0)\n    flights_and_coords = [[] for i in range(4)] # 4 = flightID + Z + Y + X\n    flights_and_coords[0] = file[COLUMNS_NAMES[0]].values\n    flights_and_coords[1] = file[COLUMNS_NAMES[3]].values\n    flights_and_coords[2] = file[COLUMNS_NAMES[4]].values\n    flights_and_coords[3] = file[COLUMNS_NAMES[5]].values",
        "detail": "eurocontrolConverter",
        "documentation": {}
    },
    {
        "label": "create_eurocontrol_file2",
        "kind": 2,
        "importPath": "eurocontrolConverter",
        "description": "eurocontrolConverter",
        "peekOfCode": "def create_eurocontrol_file2(trajs,filename,header = True):\n   if(trajs is None): raise Exception(\"Invalid input\")\n   if( trajs == [] or trajs[0] is None or \n      trajs[0] == []  or trajs[0][0] is None or \n      trajs[0][0] == [] ): \n      raise Exception(\"Invalid input\")\n   dimensions = len(trajs[0][0])\n   if(dimensions <2 or dimensions >3): raise Exception(\"Only 2D or 3D, received\", dimensions)\n   offset=3\n   print(\"Found\",len(trajs),\"trajectories with dimensions of num.:\", dimensions)",
        "detail": "eurocontrolConverter",
        "documentation": {}
    },
    {
        "label": "create_eurocontrol_file",
        "kind": 2,
        "importPath": "eurocontrolConverter",
        "description": "eurocontrolConverter",
        "peekOfCode": "def create_eurocontrol_file(trajs,dimensions,filename,header = True):\n   if(dimensions <2 or dimensions >3): raise Exception(\"Only 2D or 3D\")\n   d = {}\n   offset=3\n   for traj in trajs:\n      id = generate_flight_id()\n      for i in range(len(traj)):\n         # Time over is N/A right now\n         row = [id,i,None]\n         for field in range(0,len(fields)):",
        "detail": "eurocontrolConverter",
        "documentation": {}
    },
    {
        "label": "COLUMNS_NAMES",
        "kind": 5,
        "importPath": "eurocontrolConverter",
        "description": "eurocontrolConverter",
        "peekOfCode": "COLUMNS_NAMES = ['ECTRL ID',\n                'Sequence Number',\n                'Time Over',\n                'Flight Level', # Actually is Z coordinate\n                'Latitude',     # Actually is Y coordinate\n                'Longitude']    # Actually is X coordinate\nCOLUMNS_NAMES2 = ['id',\n                'time',\n                'x',\n                'y', ",
        "detail": "eurocontrolConverter",
        "documentation": {}
    },
    {
        "label": "COLUMNS_NAMES2",
        "kind": 5,
        "importPath": "eurocontrolConverter",
        "description": "eurocontrolConverter",
        "peekOfCode": "COLUMNS_NAMES2 = ['id',\n                'time',\n                'x',\n                'y', \n                'z',     \n               #  'th', #NA\n               #  \"tv\", #NA\n               #  \"rv\", #NA\n               ] \nFILE_DIR = \"eurocontrol/\"",
        "detail": "eurocontrolConverter",
        "documentation": {}
    },
    {
        "label": "FILE_DIR",
        "kind": 5,
        "importPath": "eurocontrolConverter",
        "description": "eurocontrolConverter",
        "peekOfCode": "FILE_DIR = \"eurocontrol/\"\ndef generate_flight_id():\n    # Generate a unique ID for a flight.\n    id = uuid.uuid1()\n    flight_id = id.fields[0]\n    return flight_id\ndef flights_points( data, file_name):\n    # 'data' is an ordered list represented in this way --> [ [flights_IDs], [number_waypoints_sequence], \n    #    [crossingg_waypoints_times], [flights_levels], [Latitudes], [Longitutes] ].\n    # This method take 'data' as input and put it into a .csv file (by creating it) according to the Eurocontrol standard template.",
        "detail": "eurocontrolConverter",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "layer1",
        "description": "layer1",
        "peekOfCode": "def main(mode, fixed_init_pos=None, trainedQtable=None,visited_cells = [],i_trajectory = None):\n    assert(mode in [\"train\",\"test\",\"random\"])\n    if(args.load_maze):\n        maze_file = args.load_maze\n    else:\n        maze_file = STD_MAZE\n    env = MazeEnv( maze_file = maze_file,                  \n        # maze_file=\"maze\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M') ),\n                                    maze_size=(640, 640), \n                                    enable_render= ( args.render_train if(mode in [\"train\",\"random\"]) else args.render_test ),",
        "detail": "layer1",
        "documentation": {}
    },
    {
        "label": "cell_value",
        "kind": 2,
        "importPath": "layer1",
        "description": "layer1",
        "peekOfCode": "def cell_value(r,c,obs_blocks=1,street_blocks=1):\n    if(obs_blocks ==1):\n        if r %2 ==0 or c %2 ==0:\n            return 15\n        elif r != 0 and c !=0 and r != NROWS -1 and c != NCOLS -1 :\n            return 0\n        else:\n            return 15\n    else:\n        if(r % ( obs_blocks+1)==0 or c % (obs_blocks +1 ) == 0 ):",
        "detail": "layer1",
        "documentation": {}
    },
    {
        "label": "IDX_TO_ACTION",
        "kind": 5,
        "importPath": "layer1",
        "description": "layer1",
        "peekOfCode": "IDX_TO_ACTION =  {0:\"LEFT\",1:\"FRONT\",2:\"RIGHT\",3:\"BACK\"}\nSTD_MAZE = \"maze2d_004.npy\"\nINTERACTIVE = False\nOUT_FORMAT = \"csv\"\nRANDOM_TRAJECTORIES_FOLDER = \"rtrajectories/csv/\"\nTRAJECTORIES_FOLDER = \"qtrajectories/csv/\" \nTRAJECTORIES_3D_FOLDER = \"trajectories_3d/csv/\"\nEXPERIMENT_DATE =  datetime.datetime.now().strftime('%Y-%m-%d--%H-%M')\ndef main(mode, fixed_init_pos=None, trainedQtable=None,visited_cells = [],i_trajectory = None):\n    assert(mode in [\"train\",\"test\",\"random\"])",
        "detail": "layer1",
        "documentation": {}
    },
    {
        "label": "STD_MAZE",
        "kind": 5,
        "importPath": "layer1",
        "description": "layer1",
        "peekOfCode": "STD_MAZE = \"maze2d_004.npy\"\nINTERACTIVE = False\nOUT_FORMAT = \"csv\"\nRANDOM_TRAJECTORIES_FOLDER = \"rtrajectories/csv/\"\nTRAJECTORIES_FOLDER = \"qtrajectories/csv/\" \nTRAJECTORIES_3D_FOLDER = \"trajectories_3d/csv/\"\nEXPERIMENT_DATE =  datetime.datetime.now().strftime('%Y-%m-%d--%H-%M')\ndef main(mode, fixed_init_pos=None, trainedQtable=None,visited_cells = [],i_trajectory = None):\n    assert(mode in [\"train\",\"test\",\"random\"])\n    if(args.load_maze):",
        "detail": "layer1",
        "documentation": {}
    },
    {
        "label": "INTERACTIVE",
        "kind": 5,
        "importPath": "layer1",
        "description": "layer1",
        "peekOfCode": "INTERACTIVE = False\nOUT_FORMAT = \"csv\"\nRANDOM_TRAJECTORIES_FOLDER = \"rtrajectories/csv/\"\nTRAJECTORIES_FOLDER = \"qtrajectories/csv/\" \nTRAJECTORIES_3D_FOLDER = \"trajectories_3d/csv/\"\nEXPERIMENT_DATE =  datetime.datetime.now().strftime('%Y-%m-%d--%H-%M')\ndef main(mode, fixed_init_pos=None, trainedQtable=None,visited_cells = [],i_trajectory = None):\n    assert(mode in [\"train\",\"test\",\"random\"])\n    if(args.load_maze):\n        maze_file = args.load_maze",
        "detail": "layer1",
        "documentation": {}
    },
    {
        "label": "OUT_FORMAT",
        "kind": 5,
        "importPath": "layer1",
        "description": "layer1",
        "peekOfCode": "OUT_FORMAT = \"csv\"\nRANDOM_TRAJECTORIES_FOLDER = \"rtrajectories/csv/\"\nTRAJECTORIES_FOLDER = \"qtrajectories/csv/\" \nTRAJECTORIES_3D_FOLDER = \"trajectories_3d/csv/\"\nEXPERIMENT_DATE =  datetime.datetime.now().strftime('%Y-%m-%d--%H-%M')\ndef main(mode, fixed_init_pos=None, trainedQtable=None,visited_cells = [],i_trajectory = None):\n    assert(mode in [\"train\",\"test\",\"random\"])\n    if(args.load_maze):\n        maze_file = args.load_maze\n    else:",
        "detail": "layer1",
        "documentation": {}
    },
    {
        "label": "RANDOM_TRAJECTORIES_FOLDER",
        "kind": 5,
        "importPath": "layer1",
        "description": "layer1",
        "peekOfCode": "RANDOM_TRAJECTORIES_FOLDER = \"rtrajectories/csv/\"\nTRAJECTORIES_FOLDER = \"qtrajectories/csv/\" \nTRAJECTORIES_3D_FOLDER = \"trajectories_3d/csv/\"\nEXPERIMENT_DATE =  datetime.datetime.now().strftime('%Y-%m-%d--%H-%M')\ndef main(mode, fixed_init_pos=None, trainedQtable=None,visited_cells = [],i_trajectory = None):\n    assert(mode in [\"train\",\"test\",\"random\"])\n    if(args.load_maze):\n        maze_file = args.load_maze\n    else:\n        maze_file = STD_MAZE",
        "detail": "layer1",
        "documentation": {}
    },
    {
        "label": "TRAJECTORIES_FOLDER",
        "kind": 5,
        "importPath": "layer1",
        "description": "layer1",
        "peekOfCode": "TRAJECTORIES_FOLDER = \"qtrajectories/csv/\" \nTRAJECTORIES_3D_FOLDER = \"trajectories_3d/csv/\"\nEXPERIMENT_DATE =  datetime.datetime.now().strftime('%Y-%m-%d--%H-%M')\ndef main(mode, fixed_init_pos=None, trainedQtable=None,visited_cells = [],i_trajectory = None):\n    assert(mode in [\"train\",\"test\",\"random\"])\n    if(args.load_maze):\n        maze_file = args.load_maze\n    else:\n        maze_file = STD_MAZE\n    env = MazeEnv( maze_file = maze_file,                  ",
        "detail": "layer1",
        "documentation": {}
    },
    {
        "label": "TRAJECTORIES_3D_FOLDER",
        "kind": 5,
        "importPath": "layer1",
        "description": "layer1",
        "peekOfCode": "TRAJECTORIES_3D_FOLDER = \"trajectories_3d/csv/\"\nEXPERIMENT_DATE =  datetime.datetime.now().strftime('%Y-%m-%d--%H-%M')\ndef main(mode, fixed_init_pos=None, trainedQtable=None,visited_cells = [],i_trajectory = None):\n    assert(mode in [\"train\",\"test\",\"random\"])\n    if(args.load_maze):\n        maze_file = args.load_maze\n    else:\n        maze_file = STD_MAZE\n    env = MazeEnv( maze_file = maze_file,                  \n        # maze_file=\"maze\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M') ),",
        "detail": "layer1",
        "documentation": {}
    },
    {
        "label": "EXPERIMENT_DATE",
        "kind": 5,
        "importPath": "layer1",
        "description": "layer1",
        "peekOfCode": "EXPERIMENT_DATE =  datetime.datetime.now().strftime('%Y-%m-%d--%H-%M')\ndef main(mode, fixed_init_pos=None, trainedQtable=None,visited_cells = [],i_trajectory = None):\n    assert(mode in [\"train\",\"test\",\"random\"])\n    if(args.load_maze):\n        maze_file = args.load_maze\n    else:\n        maze_file = STD_MAZE\n    env = MazeEnv( maze_file = maze_file,                  \n        # maze_file=\"maze\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M') ),\n                                    maze_size=(640, 640), ",
        "detail": "layer1",
        "documentation": {}
    },
    {
        "label": "TRAJECTORIES_3D_FOLDER",
        "kind": 5,
        "importPath": "layer2",
        "description": "layer2",
        "peekOfCode": "TRAJECTORIES_3D_FOLDER = \"trajectories_3d/csv/\"\nif __name__ == \"__main__\":\n   parser = argparse.ArgumentParser(description='Layer 2')\n   parser.add_argument('-sx', type=int,required=True,\n                     help='Starting x coordinate of agent to choose correct trajectory to follow')\n   parser.add_argument('-sy', type=int,required=True,\n                     help='Starting y coordinate of agent to choose correct trajectory to follow')\n   parser.add_argument('--velocity',default = 10, type=float,required=False,\n                     help='Speed value')\n   # parser.add_argument( '--debug',action='store_true',  default=False,",
        "detail": "layer2",
        "documentation": {}
    },
    {
        "label": "TRAJECTORIES_3D_FOLDER",
        "kind": 5,
        "importPath": "layer3",
        "description": "layer3",
        "peekOfCode": "TRAJECTORIES_3D_FOLDER = \"trajectories_3d/csv/\"\nif __name__ == \"__main__\":\n   parser = argparse.ArgumentParser(description='Layer 2')\n   parser.add_argument('--lat', type=float,required=True,\n                     help='Starting latitude coordinate of agent to choose correct trajectory to follow')\n   parser.add_argument('--lon', type=float,required=True,\n                     help='Starting longitude coordinate of agent to choose correct trajectory to follow')\n   parser.add_argument('--velocity',default = 10, type=float,required=False,\n                     help='Speed value')\n   args = parser.parse_args()",
        "detail": "layer3",
        "documentation": {}
    },
    {
        "label": "myjoint_TAKEOFF",
        "kind": 2,
        "importPath": "multiThreadFlight",
        "description": "multiThreadFlight",
        "peekOfCode": "def myjoint_TAKEOFF(goalx, goaly, goalz, Vel,vehicle_name):\n    dist=(abs(goalz) - abs(client.simGetGroundTruthKinematics(vehicle_name).position.z_val))\n    time.sleep(abs(dist)/Vel)  \n#################################################################### NAVIGATE\ndef myjoint(goalx,goaly,goalz,Vel,vehicle_name):\n    global lk\n    lk.acquire()\n    pos = client.simGetGroundTruthKinematics(vehicle_name)\n    lk.release()\n    dist = ((np.sqrt(np.power((goalx -pos.position.x_val),2) + np.power((goaly - pos.position.y_val),2)+ np.power((goalz - pos.position.z_val),2))))",
        "detail": "multiThreadFlight",
        "documentation": {}
    },
    {
        "label": "myjoint",
        "kind": 2,
        "importPath": "multiThreadFlight",
        "description": "multiThreadFlight",
        "peekOfCode": "def myjoint(goalx,goaly,goalz,Vel,vehicle_name):\n    global lk\n    lk.acquire()\n    pos = client.simGetGroundTruthKinematics(vehicle_name)\n    lk.release()\n    dist = ((np.sqrt(np.power((goalx -pos.position.x_val),2) + np.power((goaly - pos.position.y_val),2)+ np.power((goalz - pos.position.z_val),2))))\n    print (\"waiting \",int(abs(dist)/Vel), vehicle_name)\n    time.sleep(int(abs(dist)/Vel))\n    lk.acquire()\n    pos = client.simGetGroundTruthKinematics(vehicle_name)",
        "detail": "multiThreadFlight",
        "documentation": {}
    },
    {
        "label": "move_drone",
        "kind": 2,
        "importPath": "multiThreadFlight",
        "description": "multiThreadFlight",
        "peekOfCode": "def move_drone(n):\n    global lk\n    name=[\"Drone1\", \"Drone2\"]\n    positions=[[[15,0,-4],[15,5,-4],[0,5,-4],[0,0,-4]],\n               [[12,0,-3],[12,5,-3],[0,5,-3],[0,0,-3]]]\n    for x,y,z in positions[n]:\n        lk.acquire()\n        client.moveToPositionAsync(x,y,z, V, vehicle_name=name[n])\n        lk.release()\n        print(\"goint to\", x,y,z,name[n])",
        "detail": "multiThreadFlight",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "multiThreadFlight",
        "description": "multiThreadFlight",
        "peekOfCode": "client = airsim.MultirotorClient()\nglobal V, Vt, eps\nVt=1\nV=2\neps=0.1\n#move_drone\nglobal d\nd=[]\nlk=threading.Lock()\n#################################################################### TAKE-OFF",
        "detail": "multiThreadFlight",
        "documentation": {}
    },
    {
        "label": "DrivetrainType",
        "kind": 6,
        "importPath": "newMyAirSimClient",
        "description": "newMyAirSimClient",
        "peekOfCode": "class DrivetrainType:\n    MaxDegreeOfFreedom = 0\n    ForwardOnly = 1\nclass AirSimImageType:    \n    Scene = 0\n    DepthPlanner = 1\n    DepthPerspective = 2\n    DepthVis = 3\n    DisparityNormalized = 4\n    Segmentation = 5",
        "detail": "newMyAirSimClient",
        "documentation": {}
    },
    {
        "label": "AirSimImageType",
        "kind": 6,
        "importPath": "newMyAirSimClient",
        "description": "newMyAirSimClient",
        "peekOfCode": "class AirSimImageType:    \n    Scene = 0\n    DepthPlanner = 1\n    DepthPerspective = 2\n    DepthVis = 3\n    DisparityNormalized = 4\n    Segmentation = 5\n    SurfaceNormals = 6\nlock = threading.Lock()\nclass NewMyAirSimClient(MultirotorClient):",
        "detail": "newMyAirSimClient",
        "documentation": {}
    },
    {
        "label": "NewMyAirSimClient",
        "kind": 6,
        "importPath": "newMyAirSimClient",
        "description": "newMyAirSimClient",
        "peekOfCode": "class NewMyAirSimClient(MultirotorClient):\n    deg_to_rad = lambda d_angle: d_angle * math.pi / 180.0\n    def __init__(self,trajColFlag,canDrawTrajectories,crabMode,thickness):        \n        MultirotorClient.__init__(self)\n        MultirotorClient.confirmConnection(self)\n        self.drones_names = [ v for v in utils.g_airsim_settings[\"Vehicles\"] ]\n        for i,dn in enumerate( self.drones_names ):\n            self.enableApiControl(True,vehicle_name=dn)\n            self.armDisarm(True,vehicle_name=dn)\n        self.trajColFlag = trajColFlag",
        "detail": "newMyAirSimClient",
        "documentation": {}
    },
    {
        "label": "lock",
        "kind": 5,
        "importPath": "newMyAirSimClient",
        "description": "newMyAirSimClient",
        "peekOfCode": "lock = threading.Lock()\nclass NewMyAirSimClient(MultirotorClient):\n    deg_to_rad = lambda d_angle: d_angle * math.pi / 180.0\n    def __init__(self,trajColFlag,canDrawTrajectories,crabMode,thickness):        \n        MultirotorClient.__init__(self)\n        MultirotorClient.confirmConnection(self)\n        self.drones_names = [ v for v in utils.g_airsim_settings[\"Vehicles\"] ]\n        for i,dn in enumerate( self.drones_names ):\n            self.enableApiControl(True,vehicle_name=dn)\n            self.armDisarm(True,vehicle_name=dn)",
        "detail": "newMyAirSimClient",
        "documentation": {}
    },
    {
        "label": "custom_random",
        "kind": 2,
        "importPath": "random_main",
        "description": "random_main",
        "peekOfCode": "def custom_random(past_action):\n    action = env.action_space.sample() # Random actions DEBUG ONLY            \n    if(past_action and past_action != ACTION_TO_IDX[\"FRONT\"] ):\n        while(action == past_action):\n            action = env.action_space.sample() # Random actions DEBUG ONLY                    \n    return action\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='RL for ma-gym')\n    parser.add_argument('--episodes', type=int, default=10,\n                        help='episodes (default: %(default)s)')",
        "detail": "random_main",
        "documentation": {}
    },
    {
        "label": "episode_cooldown",
        "kind": 5,
        "importPath": "random_main",
        "description": "random_main",
        "peekOfCode": "episode_cooldown = 3\nACTION_TO_IDX = {\"LEFT\":0, \"FRONT\":1, \"RIGHT\":2,\"BACK\" : 3}\nIDX_TO_ACTION =  {0:\"LEFT\",1:\"FRONT\",2:\"RIGHT\",3:\"BACK\"}\ndef custom_random(past_action):\n    action = env.action_space.sample() # Random actions DEBUG ONLY            \n    if(past_action and past_action != ACTION_TO_IDX[\"FRONT\"] ):\n        while(action == past_action):\n            action = env.action_space.sample() # Random actions DEBUG ONLY                    \n    return action\nif __name__ == '__main__':",
        "detail": "random_main",
        "documentation": {}
    },
    {
        "label": "ACTION_TO_IDX",
        "kind": 5,
        "importPath": "random_main",
        "description": "random_main",
        "peekOfCode": "ACTION_TO_IDX = {\"LEFT\":0, \"FRONT\":1, \"RIGHT\":2,\"BACK\" : 3}\nIDX_TO_ACTION =  {0:\"LEFT\",1:\"FRONT\",2:\"RIGHT\",3:\"BACK\"}\ndef custom_random(past_action):\n    action = env.action_space.sample() # Random actions DEBUG ONLY            \n    if(past_action and past_action != ACTION_TO_IDX[\"FRONT\"] ):\n        while(action == past_action):\n            action = env.action_space.sample() # Random actions DEBUG ONLY                    \n    return action\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='RL for ma-gym')",
        "detail": "random_main",
        "documentation": {}
    },
    {
        "label": "IDX_TO_ACTION",
        "kind": 5,
        "importPath": "random_main",
        "description": "random_main",
        "peekOfCode": "IDX_TO_ACTION =  {0:\"LEFT\",1:\"FRONT\",2:\"RIGHT\",3:\"BACK\"}\ndef custom_random(past_action):\n    action = env.action_space.sample() # Random actions DEBUG ONLY            \n    if(past_action and past_action != ACTION_TO_IDX[\"FRONT\"] ):\n        while(action == past_action):\n            action = env.action_space.sample() # Random actions DEBUG ONLY                    \n    return action\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='RL for ma-gym')\n    parser.add_argument('--episodes', type=int, default=10,",
        "detail": "random_main",
        "documentation": {}
    },
    {
        "label": "Agent",
        "kind": 6,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "class Agent: \n    def __init__(self, method, env,start_alpha = 0.3, start_gamma = 0.9, start_epsilon = 0.5):\n        \"\"\"method: one of 'q_learning', 'sarsa' or 'expected_sarsa' \"\"\"\n        self.method = method\n        self.env = env\n        self.n_squares = env.maze_view.maze_size[0] * env.maze_view.maze_size[1] \n        self.n_actions = self.env.action_space.n\n        self.epsilon = start_epsilon\n        self.gamma = start_gamma\n        self.alpha = start_alpha",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "get_explore_rate",
        "kind": 2,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "def get_explore_rate(t):\n    return max(MIN_EXPLORE_RATE, min(0.8, 1.0 - math.log10((t+1)/DECAY_FACTOR)))\ndef get_learning_rate(t):\n    return max(MIN_LEARNING_RATE, min(0.8, 1.0 - math.log10((t+1)/DECAY_FACTOR)))\n# class SarsaAgent():\n#     def __init__(self,env): \n#         self.env = env\n#         self.maze=env.maze_view\n#         nrow=self.maze.maze_size[0]\n#         ncol=self.maze.maze_size[1]",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "get_learning_rate",
        "kind": 2,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "def get_learning_rate(t):\n    return max(MIN_LEARNING_RATE, min(0.8, 1.0 - math.log10((t+1)/DECAY_FACTOR)))\n# class SarsaAgent():\n#     def __init__(self,env): \n#         self.env = env\n#         self.maze=env.maze_view\n#         nrow=self.maze.maze_size[0]\n#         ncol=self.maze.maze_size[1]\n#         state_number = nrow*ncol\n#         action_number = env.actions.n",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "train_agent",
        "kind": 2,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "def train_agent(agent: Agent, n_episodes= 50000, epsilon_decay = 0.99995, alpha_decay = 0.99995, print_trace = False):\n    r_sums = []\n    if(args.enable_render):\n        env.render()\n    print(\"Training is starting ...\")\n    for ep in range(n_episodes): \n        print(\"Episode:\", ep)\n        r_sum = agent.simulate_episode()\n        # decrease epsilon and learning rate \n        # agent.epsilon *= epsilon_decay",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "parser = argparse.ArgumentParser(description='RL for ma-gym')\nparser.add_argument('--episodes', type=int, default=100,\n                    help='episodes (default: %(default)s)')\nparser.add_argument('--n-goals', type=int, default=1,\n                    help='episodes (default: %(default)s)')\nparser.add_argument('--actions-timeout', type=int, default=100,\n                    help='episodes (default: %(default)s)')\nparser.add_argument(\"--n-trajs\",type=int, default=5,\n                        help='num trajs to track (default: %(default)s)')\nparser.add_argument('--n-agents', type=int, default=1,",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "args = parser.parse_args()\n# env = gym.make(\"AirSimEnv-v1\")\nMAZE_SIZE = None\nDECAY_FACTOR = None\nMIN_EXPLORE_RATE = 0.001\nMIN_LEARNING_RATE = 0.2\ndef get_explore_rate(t):\n    return max(MIN_EXPLORE_RATE, min(0.8, 1.0 - math.log10((t+1)/DECAY_FACTOR)))\ndef get_learning_rate(t):\n    return max(MIN_LEARNING_RATE, min(0.8, 1.0 - math.log10((t+1)/DECAY_FACTOR)))",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "MAZE_SIZE",
        "kind": 5,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "MAZE_SIZE = None\nDECAY_FACTOR = None\nMIN_EXPLORE_RATE = 0.001\nMIN_LEARNING_RATE = 0.2\ndef get_explore_rate(t):\n    return max(MIN_EXPLORE_RATE, min(0.8, 1.0 - math.log10((t+1)/DECAY_FACTOR)))\ndef get_learning_rate(t):\n    return max(MIN_LEARNING_RATE, min(0.8, 1.0 - math.log10((t+1)/DECAY_FACTOR)))\n# class SarsaAgent():\n#     def __init__(self,env): ",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "DECAY_FACTOR",
        "kind": 5,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "DECAY_FACTOR = None\nMIN_EXPLORE_RATE = 0.001\nMIN_LEARNING_RATE = 0.2\ndef get_explore_rate(t):\n    return max(MIN_EXPLORE_RATE, min(0.8, 1.0 - math.log10((t+1)/DECAY_FACTOR)))\ndef get_learning_rate(t):\n    return max(MIN_LEARNING_RATE, min(0.8, 1.0 - math.log10((t+1)/DECAY_FACTOR)))\n# class SarsaAgent():\n#     def __init__(self,env): \n#         self.env = env",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "MIN_EXPLORE_RATE",
        "kind": 5,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "MIN_EXPLORE_RATE = 0.001\nMIN_LEARNING_RATE = 0.2\ndef get_explore_rate(t):\n    return max(MIN_EXPLORE_RATE, min(0.8, 1.0 - math.log10((t+1)/DECAY_FACTOR)))\ndef get_learning_rate(t):\n    return max(MIN_LEARNING_RATE, min(0.8, 1.0 - math.log10((t+1)/DECAY_FACTOR)))\n# class SarsaAgent():\n#     def __init__(self,env): \n#         self.env = env\n#         self.maze=env.maze_view",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "MIN_LEARNING_RATE",
        "kind": 5,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "MIN_LEARNING_RATE = 0.2\ndef get_explore_rate(t):\n    return max(MIN_EXPLORE_RATE, min(0.8, 1.0 - math.log10((t+1)/DECAY_FACTOR)))\ndef get_learning_rate(t):\n    return max(MIN_LEARNING_RATE, min(0.8, 1.0 - math.log10((t+1)/DECAY_FACTOR)))\n# class SarsaAgent():\n#     def __init__(self,env): \n#         self.env = env\n#         self.maze=env.maze_view\n#         nrow=self.maze.maze_size[0]",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "df = pandas.read_csv(\"fixed_goals.csv\", index_col='name')\n# print(df)\nfixed_goals = df.to_numpy()\nif(len(fixed_goals)<1):\n    raise Exception(\"Inavalid num of goals\")\n# print('fixed_goals: ', fixed_goals)\ndf = pandas.read_csv(\"init_pos.csv\", index_col='name')\n# print(df)\nfixed_init_pos_list = df.to_numpy()\n# print('fixed_goals: ', fixed_goals)",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "fixed_goals",
        "kind": 5,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "fixed_goals = df.to_numpy()\nif(len(fixed_goals)<1):\n    raise Exception(\"Inavalid num of goals\")\n# print('fixed_goals: ', fixed_goals)\ndf = pandas.read_csv(\"init_pos.csv\", index_col='name')\n# print(df)\nfixed_init_pos_list = df.to_numpy()\n# print('fixed_goals: ', fixed_goals)\nepisode_cooldown = 3\nACTION_TO_IDX = {\"LEFT\":0, \"FRONT\":1, \"RIGHT\":2,\"BACK\" : 3}",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "df = pandas.read_csv(\"init_pos.csv\", index_col='name')\n# print(df)\nfixed_init_pos_list = df.to_numpy()\n# print('fixed_goals: ', fixed_goals)\nepisode_cooldown = 3\nACTION_TO_IDX = {\"LEFT\":0, \"FRONT\":1, \"RIGHT\":2,\"BACK\" : 3}\nIDX_TO_ACTION =  {0:\"LEFT\",1:\"FRONT\",2:\"RIGHT\",3:\"BACK\"}\nSTD_MAZE = \"maze2d_004.npy\"\nINTERACTIVE = False\nOUT_FORMAT = \"csv\"",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "fixed_init_pos_list",
        "kind": 5,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "fixed_init_pos_list = df.to_numpy()\n# print('fixed_goals: ', fixed_goals)\nepisode_cooldown = 3\nACTION_TO_IDX = {\"LEFT\":0, \"FRONT\":1, \"RIGHT\":2,\"BACK\" : 3}\nIDX_TO_ACTION =  {0:\"LEFT\",1:\"FRONT\",2:\"RIGHT\",3:\"BACK\"}\nSTD_MAZE = \"maze2d_004.npy\"\nINTERACTIVE = False\nOUT_FORMAT = \"csv\"\nSEED = 12\nTIMESTEPS = 100000",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "episode_cooldown",
        "kind": 5,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "episode_cooldown = 3\nACTION_TO_IDX = {\"LEFT\":0, \"FRONT\":1, \"RIGHT\":2,\"BACK\" : 3}\nIDX_TO_ACTION =  {0:\"LEFT\",1:\"FRONT\",2:\"RIGHT\",3:\"BACK\"}\nSTD_MAZE = \"maze2d_004.npy\"\nINTERACTIVE = False\nOUT_FORMAT = \"csv\"\nSEED = 12\nTIMESTEPS = 100000\nmaze_file = STD_MAZE\nmode = \"train\"",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "ACTION_TO_IDX",
        "kind": 5,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "ACTION_TO_IDX = {\"LEFT\":0, \"FRONT\":1, \"RIGHT\":2,\"BACK\" : 3}\nIDX_TO_ACTION =  {0:\"LEFT\",1:\"FRONT\",2:\"RIGHT\",3:\"BACK\"}\nSTD_MAZE = \"maze2d_004.npy\"\nINTERACTIVE = False\nOUT_FORMAT = \"csv\"\nSEED = 12\nTIMESTEPS = 100000\nmaze_file = STD_MAZE\nmode = \"train\"\n# Approccio 1 RL per init SOLO 2D ",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "IDX_TO_ACTION",
        "kind": 5,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "IDX_TO_ACTION =  {0:\"LEFT\",1:\"FRONT\",2:\"RIGHT\",3:\"BACK\"}\nSTD_MAZE = \"maze2d_004.npy\"\nINTERACTIVE = False\nOUT_FORMAT = \"csv\"\nSEED = 12\nTIMESTEPS = 100000\nmaze_file = STD_MAZE\nmode = \"train\"\n# Approccio 1 RL per init SOLO 2D \nfor fixed_init_pos in fixed_init_pos_list:",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "STD_MAZE",
        "kind": 5,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "STD_MAZE = \"maze2d_004.npy\"\nINTERACTIVE = False\nOUT_FORMAT = \"csv\"\nSEED = 12\nTIMESTEPS = 100000\nmaze_file = STD_MAZE\nmode = \"train\"\n# Approccio 1 RL per init SOLO 2D \nfor fixed_init_pos in fixed_init_pos_list:\n    env = MazeEnv( maze_file = maze_file,                  ",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "INTERACTIVE",
        "kind": 5,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "INTERACTIVE = False\nOUT_FORMAT = \"csv\"\nSEED = 12\nTIMESTEPS = 100000\nmaze_file = STD_MAZE\nmode = \"train\"\n# Approccio 1 RL per init SOLO 2D \nfor fixed_init_pos in fixed_init_pos_list:\n    env = MazeEnv( maze_file = maze_file,                  \n                # maze_file=\"maze\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M') ),",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "OUT_FORMAT",
        "kind": 5,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "OUT_FORMAT = \"csv\"\nSEED = 12\nTIMESTEPS = 100000\nmaze_file = STD_MAZE\nmode = \"train\"\n# Approccio 1 RL per init SOLO 2D \nfor fixed_init_pos in fixed_init_pos_list:\n    env = MazeEnv( maze_file = maze_file,                  \n                # maze_file=\"maze\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M') ),\n                                            maze_size=(640, 640), ",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "SEED",
        "kind": 5,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "SEED = 12\nTIMESTEPS = 100000\nmaze_file = STD_MAZE\nmode = \"train\"\n# Approccio 1 RL per init SOLO 2D \nfor fixed_init_pos in fixed_init_pos_list:\n    env = MazeEnv( maze_file = maze_file,                  \n                # maze_file=\"maze\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M') ),\n                                            maze_size=(640, 640), \n                                            enable_render= args.enable_render if(mode==\"train\") else True,",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "TIMESTEPS",
        "kind": 5,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "TIMESTEPS = 100000\nmaze_file = STD_MAZE\nmode = \"train\"\n# Approccio 1 RL per init SOLO 2D \nfor fixed_init_pos in fixed_init_pos_list:\n    env = MazeEnv( maze_file = maze_file,                  \n                # maze_file=\"maze\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M') ),\n                                            maze_size=(640, 640), \n                                            enable_render= args.enable_render if(mode==\"train\") else True,\n                                            do_track_trajectories=True,num_goals=args.n_goals, measure_distance = True,",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "maze_file",
        "kind": 5,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "maze_file = STD_MAZE\nmode = \"train\"\n# Approccio 1 RL per init SOLO 2D \nfor fixed_init_pos in fixed_init_pos_list:\n    env = MazeEnv( maze_file = maze_file,                  \n                # maze_file=\"maze\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M') ),\n                                            maze_size=(640, 640), \n                                            enable_render= args.enable_render if(mode==\"train\") else True,\n                                            do_track_trajectories=True,num_goals=args.n_goals, measure_distance = True,\n                                            verbose = args.v,n_trajs=args.n_trajs,random_pos = args.random_pos,seed_num = SEED,",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "mode",
        "kind": 5,
        "importPath": "sarsa_main",
        "description": "sarsa_main",
        "peekOfCode": "mode = \"train\"\n# Approccio 1 RL per init SOLO 2D \nfor fixed_init_pos in fixed_init_pos_list:\n    env = MazeEnv( maze_file = maze_file,                  \n                # maze_file=\"maze\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M') ),\n                                            maze_size=(640, 640), \n                                            enable_render= args.enable_render if(mode==\"train\") else True,\n                                            do_track_trajectories=True,num_goals=args.n_goals, measure_distance = True,\n                                            verbose = args.v,n_trajs=args.n_trajs,random_pos = args.random_pos,seed_num = SEED,\n                                            fixed_goals = fixed_goals,fixed_init_pos = fixed_init_pos)",
        "detail": "sarsa_main",
        "documentation": {}
    },
    {
        "label": "sfp",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "sfp = utils.AIRSIM_SETTINGS_FOLDER + \"settings.json\"\nwith open(sfp, \"r\") as jsonFile:\n    data = json.load(jsonFile)\nprint(data[\"Vehicles\"]) \n#  Set uavs positions based on gps positions specified inside utils module\nfor i,v in enumerate(data[\"Vehicles\"]):\n    gps = utils.init_gps[i]\n    ned = utils.lonlatToAirSim(*gps)\n    v[\"X\"] = ned[0]\n    v[\"Y\"] =  ned[1]",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "TrajectoryTrackerClient",
        "kind": 6,
        "importPath": "trajectoryTrackerClient",
        "description": "trajectoryTrackerClient",
        "peekOfCode": "class TrajectoryTrackerClient(MultirotorClient):\n    def __init__(self):        \n        MultirotorClient.__init__(self)\n        MultirotorClient.confirmConnection(self)\n        self.drones_names = [ v for v in utils.g_airsim_settings[\"Vehicles\"] ]\n        self.trajectory = []\n        self.episode = 0\n        self.isTracking = False\n        self.folder_timestamp =str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M'))\n        self.timestep = 0.1",
        "detail": "trajectoryTrackerClient",
        "documentation": {}
    },
    {
        "label": "setSeed",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def setSeed(seed):\n   global SEED\n   SEED=seed\n   random.seed(SEED)\n   np.random.seed(seed=SEED)\ndef setRandomSeed():\n    s = random.randint(0,int(10e8))\n    setSeed(s)\n    return SEED\ndef myInterpolate2D(trajs, n_samples=10,step_size=20 ):",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "setRandomSeed",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def setRandomSeed():\n    s = random.randint(0,int(10e8))\n    setSeed(s)\n    return SEED\ndef myInterpolate2D(trajs, n_samples=10,step_size=20 ):\n    n_collisions = []\n    for arr in trajs:\n        res_t = []\n        for i,p in enumerate(arr):\n            if(i+1 >= len(arr)):",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "myInterpolate2D",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def myInterpolate2D(trajs, n_samples=10,step_size=20 ):\n    n_collisions = []\n    for arr in trajs:\n        res_t = []\n        for i,p in enumerate(arr):\n            if(i+1 >= len(arr)):\n                break\n            x1,y1 = p[0], p[1]\n            x2,y2 = arr[i+1][0], arr[i+1][1] \n            # if(i==0):",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "build_trees",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def build_trees(trajectories):\n    _trees = []\n    for traj in trajectories:\n        _trees.append(KDTree(np.array(traj)))\n    return _trees\ndef build_tree_dict(trajectories,fixed_h = None):\n    if(trajectories is None or trajectories==[]):\n        return {},{}\n    _trees = dict()\n    _tree_by_id = dict()",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "build_tree_dict",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def build_tree_dict(trajectories,fixed_h = None):\n    if(trajectories is None or trajectories==[]):\n        return {},{}\n    _trees = dict()\n    _tree_by_id = dict()\n    dimensions = len(trajectories[0][0])\n    for idx,traj in enumerate(trajectories):\n        arr2d = np.array( traj )\n        if(dimensions==3):\n            arr2d = np.delete( arr2d ,np.s_[2:3], axis=1)",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "check_trees_collision",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def check_trees_collision(fId,point,trees,radius):\n    n_collisions = 0\n    for idx,_tree in enumerate(trees): \n        if(idx == fId):\n            # E' quella attuale\n            continue\n        n_collisions = _tree.query_radius( [point],r=radius,count_only = True )\n        if(n_collisions > 0):\n            return n_collisions\n    return n_collisions",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "complex_avoid_collision_in_busy_space",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def complex_avoid_collision_in_busy_space(trajs_2d,assigned_trajs,min_height,max_height,\n    sep_h,min_safe_points,radius=30,simpleMode=True):\n    print(\"Started col avoidance in busy space...\")\n    # First remove the points not interesting by height constraints\n    assigned_points = []\n    for traj in assigned_trajs:\n        for p in traj:\n            if min_height<=p[2]<=max_height : assigned_points.append(p)\n    zs = [[] for t in range(len(trajs_2d))]\n    trajs_3d =   []",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "avoid_collision_in_busy_space",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def avoid_collision_in_busy_space(trajs_2d,assigned_trajs,min_height,max_height,\n    sep_h,min_safe_points,radius=30,simpleMode=True,n_pool_traj=3):\n    '''\n    - trajectories are [[p11,p12,...],[p21,p22,...],...]\n      pij is a point j-th in 2d: [x,y]  for i-th flight\n    - read only assigned_trajs are [[p11,p12,...],[p21,p22,...],...]\n      pij is a point j-th in 3d: [x,y,z]  for i-th flight (they are assumed to be generated compatible with this algo)\n    - trees are built using build_trees function, they are k-d trees \n    - max_height,min_height are bounds for allocation, it starts from max and allocates towards min\n    - sep_h is the amount of height separating two trajectories with same x,y",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "avoid_collision_complex",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def avoid_collision_complex(new_trajs_2d,min_height,max_height,\n    sep_h,assigned_trajs=[],radius=10, n_trajs_pool=None,seed=None,\n    tolerance = 0):\n    \"\"\"\n    ASSUMPTIONS\n    - assigned_trajs follows this convention\n    - threshold value is the max value of problematic points before traj\n    is considered colliding \n    \"\"\"\n    print(\"Loaded\" ,len(assigned_trajs),\"fixed trajectories\")",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "print_z_head",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def print_z_head(arr):\n    print(\"heights are:\")\n    for idx,t in enumerate(arr):\n        print(\"\\t id:\",idx,\"z\",t[0][2])\nfrom scipy.stats import poisson\ndef random_gen_2d(xmin,xmax,ymin,ymax,zmin=None,zmax=None,step=120,n_points=None,n_trajs=5):\n    \"\"\"\n    normal to choose action with (mean=0,std=1)\n    \"\"\"\n    n_drones = n_trajs",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "random_gen_2d",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def random_gen_2d(xmin,xmax,ymin,ymax,zmin=None,zmax=None,step=120,n_points=None,n_trajs=5):\n    \"\"\"\n    normal to choose action with (mean=0,std=1)\n    \"\"\"\n    n_drones = n_trajs\n    trajs = [[] for i in range(n_drones)]\n    if( n_points is None):\n        n_constant = False\n    else:\n        n_constant = True",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "umb_random_gen2d",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def umb_random_gen2d(xmin,xmax,ymin,ymax,zmin=None,zmax=None,step=120,n_points=100,n_trajs=5):\n    n_drones = n_trajs\n    trajs = [[] for i in range(n_drones)]\n    for i in range(n_drones):\n        if(n_points==None):\n            n_points = random.randrange(xmin, xmax+1,1 )\n        xs = []\n        ys = []\n        if(zmin is not None and zmax is not None):\n            z_value = random.randrange(zmin, zmax+1,1 )",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "interpolate_trajs",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def interpolate_trajs(trajs,doPlot=False):\n    trajs = myInterpolate2D(trajs,step_size=STEP_SIZE)\n    if(doPlot):\n        fig = plt.figure()\n        for i in range(len(trajs)):\n            plt.plot(*zip(*trajs[i]),\"-o\")\n        plt.title(\"interpolated\" )\n        plt.show()\n    return trajs\n# def height_algo(trajs):",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "get_action",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def get_action(s0,s1):\n    x0,y0 = s0[0],s0[1]\n    x1,y1 = s1[0],s1[1]\n    if(x1 > x0): return AINDEX[\"E\"]\n    elif(x0 > x1): return AINDEX[\"W\"]\n    elif(y1 > y0): return AINDEX[\"N\"]\n    elif(y0 > y1): return AINDEX[\"S\"]\n    # else: raise Exception(\"NOT MOVED NOT ACCEPTABLE\")\n    else: return -1\ndef are_opposite_actions(a1,a2):",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "are_opposite_actions",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def are_opposite_actions(a1,a2):\n    return a1!=a2 \\\n        and ( (ACTION[a1]==\"N\" and ACTION[a2] ==\"S\") or  \n            (ACTION[a1]==\"S\" and ACTION[a2] ==\"N\") or \n            (ACTION[a1]==\"E\" and ACTION[a2] ==\"W\") or  \n            (ACTION[a1]==\"W\" and ACTION[a2] ==\"E\") )  \ndef fix_traj(trajs):\n    \"\"\"\n        Remove states going back (indecisions in agent)\n    \"\"\"",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "fix_traj",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def fix_traj(trajs):\n    \"\"\"\n        Remove states going back (indecisions in agent)\n    \"\"\"\n    for i in range(len(trajs)):\n        last_action = None\n        last_state = None\n        history = dict()\n        j=0\n        while(j < len(trajs[i]) ):",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "plot_2d",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def plot_2d(trajs):\n    \"\"\" 2D plot of trajectories trajs = [t1,...,tn] \"\"\"\n    for i in range(len(trajs)):\n        plt.plot(*zip(*trajs[i]),\"-o\")\n        # for j in range(len(trajs[i])):\n        #     if(j+1>=len(trajs[i])): break\n        #     plt.arrow(*trajs[i][j],*trajs[i][j+1],  head_width = 0.2, )\n    print('trajs: ', trajs)\n    # plt.grid()\n    plt.title(\"not interpolated\" )",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "plot_3d",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def plot_3d(trajs,also2d=False,doSave=False,name=\"\",exploded=False): \n    \"\"\" 3D plot of trajectories trajs = [t1,...,tn] \"\"\"\n    fig = plt.figure(figsize=(20,10))\n    ax = fig.gca(projection='3d')\n    # fig = matplotlib.pyplot.gcf()\n    # fig.set_size_inches(18.5, 10.5)\n    altitudes = dict()\n    for i in range(len(trajs)):\n        # print(\"xs\",xs[-10:],\"ys\",ys[-10:],\"zs\",zs[-10:])\n        if(exploded):",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "plot_z",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def plot_z(trajs, second_axis,doSave=False,name=\"\"):\n    \"\"\" 2D plot of zs depending second_axis (z = f(second_axis)) \"\"\"\n    if not (0 <= second_axis <= 1 ): raise Exception(\"Invalid axis\")\n    fig = plt.figure(figsize=(20,10))\n    ax = fig.add_subplot(111)\n    plt.grid()\n    for id,t in enumerate( trajs ):\n        t = [ [p[second_axis],p[2]] for p in t]\n        plt.plot(*zip(* t ),\"-o\")\n        ax.text(t[0][0], t[0][1], str(id), style='italic')",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "plot_z_id",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def plot_z_id(zs):\n    \"\"\" 2D plot of zs depending on fligth id \"\"\"\n    fig = plt.figure()\n    for i in range(len(zs)):\n        z_t = [ [t,z] for t,z in enumerate(zs[i])]\n        print(z_t)\n        plt.plot(*zip(*z_t),\"-o\")\n    plt.title(\"height\" )\n    plt.show()\ndef np_remove_z(arr):",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "np_remove_z",
        "kind": 2,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "def np_remove_z(arr):\n    return np.delete( np.array( arr ),np.s_[2:3], axis=1)\nif __name__ == \"__main__\":\n    d1 = [[0,0],[1,0],[2,0],[1,0],[2,0],[1,0],[0,0],[0,1],[0,2],[0,1],[0,0],[0,1],[0,2],[0,3],[0,4]]\n    d2 = [[1,0],[2,0],[2,1],[2,2],[2,3],[1,3],[0,3],[0,4]]\n    d3 = [[4,0,1],[4,1,1],[4,2,1],[4,3,1],[3,3,1],[2,3,1],[1,3,1],[0,3,1]]\n    d4 = [[5,0,1],[5,1,1],[5,2,1],[5,3,1],[4,3,1],[3,3,1],[3,2,1],[3,1,1],[3,0,1]]\n    trajectories = [d1,d2]\n    d3 = np.array(d3)\n    d3[:,1] += 3",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "SEED",
        "kind": 5,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "SEED = 668\nN_DRONES=5\nN_POINTS = 100\nSTEP_SIZE = 20\nACTION = [\"N\",\"S\", \"E\", \"W\"]\nAINDEX = {\"N\":0,\"S\":1, \"E\":2, \"W\":3}\n# random.seed(SEED)\n# np.random.seed(seed=SEED)\ndef setSeed(seed):\n   global SEED",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "N_POINTS",
        "kind": 5,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "N_POINTS = 100\nSTEP_SIZE = 20\nACTION = [\"N\",\"S\", \"E\", \"W\"]\nAINDEX = {\"N\":0,\"S\":1, \"E\":2, \"W\":3}\n# random.seed(SEED)\n# np.random.seed(seed=SEED)\ndef setSeed(seed):\n   global SEED\n   SEED=seed\n   random.seed(SEED)",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "STEP_SIZE",
        "kind": 5,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "STEP_SIZE = 20\nACTION = [\"N\",\"S\", \"E\", \"W\"]\nAINDEX = {\"N\":0,\"S\":1, \"E\":2, \"W\":3}\n# random.seed(SEED)\n# np.random.seed(seed=SEED)\ndef setSeed(seed):\n   global SEED\n   SEED=seed\n   random.seed(SEED)\n   np.random.seed(seed=SEED)",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "ACTION",
        "kind": 5,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "ACTION = [\"N\",\"S\", \"E\", \"W\"]\nAINDEX = {\"N\":0,\"S\":1, \"E\":2, \"W\":3}\n# random.seed(SEED)\n# np.random.seed(seed=SEED)\ndef setSeed(seed):\n   global SEED\n   SEED=seed\n   random.seed(SEED)\n   np.random.seed(seed=SEED)\ndef setRandomSeed():",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "AINDEX",
        "kind": 5,
        "importPath": "trajs_utils",
        "description": "trajs_utils",
        "peekOfCode": "AINDEX = {\"N\":0,\"S\":1, \"E\":2, \"W\":3}\n# random.seed(SEED)\n# np.random.seed(seed=SEED)\ndef setSeed(seed):\n   global SEED\n   SEED=seed\n   random.seed(SEED)\n   np.random.seed(seed=SEED)\ndef setRandomSeed():\n    s = random.randint(0,int(10e8))",
        "detail": "trajs_utils",
        "documentation": {}
    },
    {
        "label": "play_audio_notification",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def play_audio_notification(n_beeps=3,frequency=2000,beep_duration=250):\n    for _ in range(n_beeps):\n        winsound.Beep(frequency, beep_duration)\n        time.sleep(0.1)\ndef initiate_logger():\n    logging.basicConfig(filename=LOG_FOLDER+\"log\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M'))+\".txt\",\n                                filemode='w',\n                                format='%(asctime)s,%(msecs)d %(name)s %(levelname)s %(message)s',\n                                datefmt='%H:%M:%S',\n                                level=logging.DEBUG)",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "initiate_logger",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def initiate_logger():\n    logging.basicConfig(filename=LOG_FOLDER+\"log\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M'))+\".txt\",\n                                filemode='w',\n                                format='%(asctime)s,%(msecs)d %(name)s %(levelname)s %(message)s',\n                                datefmt='%H:%M:%S',\n                                level=logging.DEBUG)\n    logger = logging.getLogger('multiAirGym')\n    logger.debug('Experiment Date: {}'.format(datetime.datetime.now().strftime('%Y-%m-%d  %H:%M') ) )\n    return logger\ndef ConvertIfStringIsInt(input_string):",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "ConvertIfStringIsInt",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def ConvertIfStringIsInt(input_string):\n    try:\n        float(input_string)\n        try:\n            if int(input_string) == float(input_string):\n                return int(input_string)\n            else:\n                return float(input_string)\n        except ValueError:\n            return float(input_string)",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "read_cfg",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def read_cfg(config_filename='configs/map_config.cfg', verbose=False):\n    parser = ConfigParser()\n    parser.optionxform = str\n    parser.read(config_filename)\n    cfg = DotMap()\n    if verbose:\n        hyphens = '-' * int((80 - len(config_filename))/2)\n        print(hyphens + ' ' + config_filename + ' ' + hyphens)\n    for section_name in parser.sections():\n        if verbose:",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "projToAirSim",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def projToAirSim( x, y, z):\n    x_airsim = (x + o_x ) \n    y_airsim = (y - o_y) \n    z_airsim = (-z + o_z) \n    return (x_airsim, -y_airsim, z_airsim)\ndef lonlatToProj( lon, lat, z, inverse=False):\n    proj_coords = Proj(init=SRID)(lon, lat, inverse=inverse)\n    return proj_coords + (z,)\ndef lonlatToAirSim( lon, lat, z):\n    return projToAirSim(*lonlatToProj(lon, lat, z)   )",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "lonlatToProj",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def lonlatToProj( lon, lat, z, inverse=False):\n    proj_coords = Proj(init=SRID)(lon, lat, inverse=inverse)\n    return proj_coords + (z,)\ndef lonlatToAirSim( lon, lat, z):\n    return projToAirSim(*lonlatToProj(lon, lat, z)   )\ndef nedToProj( x, y, z):\n    \"\"\"\n    Converts NED coordinates to the projected map coordinates\n    Takes care of offset origin, inverted z, as well as inverted y axis\n    \"\"\"",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "lonlatToAirSim",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def lonlatToAirSim( lon, lat, z):\n    return projToAirSim(*lonlatToProj(lon, lat, z)   )\ndef nedToProj( x, y, z):\n    \"\"\"\n    Converts NED coordinates to the projected map coordinates\n    Takes care of offset origin, inverted z, as well as inverted y axis\n    \"\"\"\n    x_proj = x + o_x\n    y_proj = -y + o_y\n    z_proj = -z + o_z",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "nedToProj",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def nedToProj( x, y, z):\n    \"\"\"\n    Converts NED coordinates to the projected map coordinates\n    Takes care of offset origin, inverted z, as well as inverted y axis\n    \"\"\"\n    x_proj = x + o_x\n    y_proj = -y + o_y\n    z_proj = -z + o_z\n    return (x_proj, y_proj, z_proj)\ndef nedToGps( x, y, z):",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "nedToGps",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def nedToGps( x, y, z):\n    return lonlatToProj(* nedToProj(x, y, z), inverse=True)\ndef dronePrint(idx,s):\n    print(\"[Drone\"+str(idx)+\"]\",s)\ndef addToDict(d: dict,k,v):\n    if k not in d:\n        d[k] = []\n    d[k].append(v)\ndef pkl_save_obj(obj, name,file_timestamp ):\n    with open(TRAJECTORIES_FOLDER + name + file_timestamp + '.pkl', 'wb') as f:",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "dronePrint",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def dronePrint(idx,s):\n    print(\"[Drone\"+str(idx)+\"]\",s)\ndef addToDict(d: dict,k,v):\n    if k not in d:\n        d[k] = []\n    d[k].append(v)\ndef pkl_save_obj(obj, name,file_timestamp ):\n    with open(TRAJECTORIES_FOLDER + name + file_timestamp + '.pkl', 'wb') as f:\n        pickle.dump(obj, f, pickle.HIGHEST_PROTOCOL)\ndef pkl_load_obj(name=None,file_timestamp=None,filename=None):",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "addToDict",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def addToDict(d: dict,k,v):\n    if k not in d:\n        d[k] = []\n    d[k].append(v)\ndef pkl_save_obj(obj, name,file_timestamp ):\n    with open(TRAJECTORIES_FOLDER + name + file_timestamp + '.pkl', 'wb') as f:\n        pickle.dump(obj, f, pickle.HIGHEST_PROTOCOL)\ndef pkl_load_obj(name=None,file_timestamp=None,filename=None):\n    if filename:\n        with open(TRAJECTORIES_FOLDER +filename, 'rb') as f:",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "pkl_save_obj",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def pkl_save_obj(obj, name,file_timestamp ):\n    with open(TRAJECTORIES_FOLDER + name + file_timestamp + '.pkl', 'wb') as f:\n        pickle.dump(obj, f, pickle.HIGHEST_PROTOCOL)\ndef pkl_load_obj(name=None,file_timestamp=None,filename=None):\n    if filename:\n        with open(TRAJECTORIES_FOLDER +filename, 'rb') as f:\n            return pickle.load(f)\n    elif name and file_timestamp:\n        with open(TRAJECTORIES_FOLDER + name + file_timestamp+ '.pkl', 'rb') as f:\n            return pickle.load(f)",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "pkl_load_obj",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def pkl_load_obj(name=None,file_timestamp=None,filename=None):\n    if filename:\n        with open(TRAJECTORIES_FOLDER +filename, 'rb') as f:\n            return pickle.load(f)\n    elif name and file_timestamp:\n        with open(TRAJECTORIES_FOLDER + name + file_timestamp+ '.pkl', 'rb') as f:\n            return pickle.load(f)\n    else:\n        raise Exception(\"Specify file name\")\ndef numpy_save(arr,folder_timestamp,filename):",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "numpy_save",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def numpy_save(arr,folder_timestamp,filename):\n    file_path = TRAJECTORIES_FOLDER+\"trajectories_\"+folder_timestamp\n    if not os.path.exists(file_path):\n        os.makedirs(file_path)\n    data = np.asarray(arr)\n    # save to npy file\n    print(\"Saving\",os.path.join(file_path, filename))\n    np.save(os.path.join(file_path, filename) , data)\ndef position_to_list(position_vector) -> list:\n    return [position_vector.x_val, position_vector.y_val, position_vector.z_val]",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "position_to_list",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def position_to_list(position_vector) -> list:\n    return [position_vector.x_val, position_vector.y_val, position_vector.z_val]\ndef list_to_position(l,wcell_in_meters=20,hcell_in_meters=20) -> Vector3r:\n    x = int(l[0]*wcell_in_meters)\n    y = int(l[1]*hcell_in_meters)\n    z = int(l[2])\n    if len(l) != 3:\n        raise Exception(\"REQUIRED EXACTLY 3 elements\")\n    return Vector3r(x,y,z)\ndef set_offset_position(pos):",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "list_to_position",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def list_to_position(l,wcell_in_meters=20,hcell_in_meters=20) -> Vector3r:\n    x = int(l[0]*wcell_in_meters)\n    y = int(l[1]*hcell_in_meters)\n    z = int(l[2])\n    if len(l) != 3:\n        raise Exception(\"REQUIRED EXACTLY 3 elements\")\n    return Vector3r(x,y,z)\ndef set_offset_position(pos):\n    _v = g_vehicles[\"Drone0\"]\n    _offset_x = _v[\"X\"] ",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "set_offset_position",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def set_offset_position(pos):\n    _v = g_vehicles[\"Drone0\"]\n    _offset_x = _v[\"X\"] \n    _offset_y = _v[\"Y\"]\n    _offset_z = _v[\"Z\"]\n    pos.x_val += _offset_x\n    pos.y_val += _offset_y\n    pos.z_val += _offset_z\ndef _colorize(idx): \n    if idx == 0:",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "xy_distance",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def xy_distance(point1, point2):\n    if type(point1) == Vector3r:\n        point1 = [point1.x_val,point1.y_val] \n    if type(point2) == Vector3r:\n        point2 = [point2.x_val,point2.y_val] \n    return   np.linalg.norm(point1 - point2) \ndef myInterpolate(arr, n_samples=10 ):\n    res = []\n    for i,p in enumerate(arr):\n        if(i+1 >= len(arr)):",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "myInterpolate",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def myInterpolate(arr, n_samples=10 ):\n    res = []\n    for i,p in enumerate(arr):\n        if(i+1 >= len(arr)):\n            break\n        x1,y1,z1 = p[0], p[1], p[2]\n        x2,y2,z2 = arr[i+1][0], arr[i+1][1], arr[i+1][2] \n        step_length = max(abs(x2-x1),abs(y2-y1)) / n_samples\n        for i in range(n_samples):\n            if(x2 > x1):",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "myInterpolate2D",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def myInterpolate2D(trajs, n_samples=10,step_size=20 ):\n    res = []\n    for arr in trajs:\n        res_t = []\n        for i,p in enumerate(arr):\n            if(i+1 >= len(arr)):\n                break\n            x1,y1 = p[0], p[1]\n            x2,y2 = arr[i+1][0], arr[i+1][1] \n            # if(i==0):",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "build_trees",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def build_trees(trajectories):\n    _trees = []\n    for traj in trajectories:\n        _trees.append(KDTree(np.array(traj)))\n    return _trees\ndef avoid_collision(trajectories,trees,min_height,max_height,\n    sep_h,min_safe_points,radius=30,simpleMode=True):\n    Tmax = max([len(traj) for traj in trajectories])\n    drones = range(len(trajectories))\n    points = {}",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "avoid_collision",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def avoid_collision(trajectories,trees,min_height,max_height,\n    sep_h,min_safe_points,radius=30,simpleMode=True):\n    Tmax = max([len(traj) for traj in trajectories])\n    drones = range(len(trajectories))\n    points = {}\n    zs=[[] for d in drones] \n    trajs_3d =[[] for d in drones] \n    colliding_trajs = dict()\n    for d in drones:\n        for t in range(len(trajectories[d])):",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "AIRSIM_SETTINGS_FOLDER",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "AIRSIM_SETTINGS_FOLDER = 'C:/Users/gioca/OneDrive/Documents/Airsim/'\nCONFIGS_FOLDER = \"./configs/\"\nLOG_FOLDER = \"./logs/\"\nTRAJECTORIES_FOLDER = \"./qtrajectories/\"\nwith open(AIRSIM_SETTINGS_FOLDER + 'settings.json', 'r') as jsonFile:\n    g_airsim_settings = json.load(jsonFile)\ng_vehicles = g_airsim_settings[\"Vehicles\"]\ng_config = ConfigParser()\ng_config.read(CONFIGS_FOLDER + 'config.ini')\nmap_filename = \"overlayMap.png\"",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "CONFIGS_FOLDER",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "CONFIGS_FOLDER = \"./configs/\"\nLOG_FOLDER = \"./logs/\"\nTRAJECTORIES_FOLDER = \"./qtrajectories/\"\nwith open(AIRSIM_SETTINGS_FOLDER + 'settings.json', 'r') as jsonFile:\n    g_airsim_settings = json.load(jsonFile)\ng_vehicles = g_airsim_settings[\"Vehicles\"]\ng_config = ConfigParser()\ng_config.read(CONFIGS_FOLDER + 'config.ini')\nmap_filename = \"overlayMap.png\"\nSRID = \"EPSG:5555\"",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "LOG_FOLDER",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "LOG_FOLDER = \"./logs/\"\nTRAJECTORIES_FOLDER = \"./qtrajectories/\"\nwith open(AIRSIM_SETTINGS_FOLDER + 'settings.json', 'r') as jsonFile:\n    g_airsim_settings = json.load(jsonFile)\ng_vehicles = g_airsim_settings[\"Vehicles\"]\ng_config = ConfigParser()\ng_config.read(CONFIGS_FOLDER + 'config.ini')\nmap_filename = \"overlayMap.png\"\nSRID = \"EPSG:5555\"\nORIGIN = (",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "TRAJECTORIES_FOLDER",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "TRAJECTORIES_FOLDER = \"./qtrajectories/\"\nwith open(AIRSIM_SETTINGS_FOLDER + 'settings.json', 'r') as jsonFile:\n    g_airsim_settings = json.load(jsonFile)\ng_vehicles = g_airsim_settings[\"Vehicles\"]\ng_config = ConfigParser()\ng_config.read(CONFIGS_FOLDER + 'config.ini')\nmap_filename = \"overlayMap.png\"\nSRID = \"EPSG:5555\"\nORIGIN = (\n    12.457480,",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "g_vehicles",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "g_vehicles = g_airsim_settings[\"Vehicles\"]\ng_config = ConfigParser()\ng_config.read(CONFIGS_FOLDER + 'config.ini')\nmap_filename = \"overlayMap.png\"\nSRID = \"EPSG:5555\"\nORIGIN = (\n    12.457480,\n    41.902243,\n    0 )\nDEST = (",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "g_config",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "g_config = ConfigParser()\ng_config.read(CONFIGS_FOLDER + 'config.ini')\nmap_filename = \"overlayMap.png\"\nSRID = \"EPSG:5555\"\nORIGIN = (\n    12.457480,\n    41.902243,\n    0 )\nDEST = (\n    12.466382,",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "map_filename",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "map_filename = \"overlayMap.png\"\nSRID = \"EPSG:5555\"\nORIGIN = (\n    12.457480,\n    41.902243,\n    0 )\nDEST = (\n    12.466382,\n    41.902491,\n    80) ",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "SRID",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "SRID = \"EPSG:5555\"\nORIGIN = (\n    12.457480,\n    41.902243,\n    0 )\nDEST = (\n    12.466382,\n    41.902491,\n    80) \nNEW_TRAJ_PENALTY = 25 # negative reward for collision points of a new trajectory",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "ORIGIN",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "ORIGIN = (\n    12.457480,\n    41.902243,\n    0 )\nDEST = (\n    12.466382,\n    41.902491,\n    80) \nNEW_TRAJ_PENALTY = 25 # negative reward for collision points of a new trajectory\n# GPS init position of uavs",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "DEST",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "DEST = (\n    12.466382,\n    41.902491,\n    80) \nNEW_TRAJ_PENALTY = 25 # negative reward for collision points of a new trajectory\n# GPS init position of uavs\ninit_gps = [\n    (\n        12.45727300643921,\n        41.90169011784915,",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "NEW_TRAJ_PENALTY",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "NEW_TRAJ_PENALTY = 25 # negative reward for collision points of a new trajectory\n# GPS init position of uavs\ninit_gps = [\n    (\n        12.45727300643921,\n        41.90169011784915,\n        0\n    ),\n    (\n        12.457227408885958,",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "init_gps",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "init_gps = [\n    (\n        12.45727300643921,\n        41.90169011784915,\n        0\n    ),\n    (\n        12.457227408885958,\n        41.90276414312537,\n        0",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "red_color",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "red_color = [1.0,0.0,0.0]\ngreen_color = [0.0,0.5,0.0]\nblue_color = [0.0,0.0,1.0]\ndef play_audio_notification(n_beeps=3,frequency=2000,beep_duration=250):\n    for _ in range(n_beeps):\n        winsound.Beep(frequency, beep_duration)\n        time.sleep(0.1)\ndef initiate_logger():\n    logging.basicConfig(filename=LOG_FOLDER+\"log\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M'))+\".txt\",\n                                filemode='w',",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "green_color",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "green_color = [0.0,0.5,0.0]\nblue_color = [0.0,0.0,1.0]\ndef play_audio_notification(n_beeps=3,frequency=2000,beep_duration=250):\n    for _ in range(n_beeps):\n        winsound.Beep(frequency, beep_duration)\n        time.sleep(0.1)\ndef initiate_logger():\n    logging.basicConfig(filename=LOG_FOLDER+\"log\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M'))+\".txt\",\n                                filemode='w',\n                                format='%(asctime)s,%(msecs)d %(name)s %(levelname)s %(message)s',",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "blue_color",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "blue_color = [0.0,0.0,1.0]\ndef play_audio_notification(n_beeps=3,frequency=2000,beep_duration=250):\n    for _ in range(n_beeps):\n        winsound.Beep(frequency, beep_duration)\n        time.sleep(0.1)\ndef initiate_logger():\n    logging.basicConfig(filename=LOG_FOLDER+\"log\"+str(datetime.datetime.now().strftime('%Y-%m-%d--%H-%M'))+\".txt\",\n                                filemode='w',\n                                format='%(asctime)s,%(msecs)d %(name)s %(levelname)s %(message)s',\n                                datefmt='%H:%M:%S',",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "env_cfg",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "env_cfg = read_cfg(config_filename = CONFIGS_FOLDER + 'map_config.cfg')\no_x = env_cfg[\"o_x\"]\no_y = env_cfg[\"o_y\"]\no_z = env_cfg[\"o_z\"]\ndef projToAirSim( x, y, z):\n    x_airsim = (x + o_x ) \n    y_airsim = (y - o_y) \n    z_airsim = (-z + o_z) \n    return (x_airsim, -y_airsim, z_airsim)\ndef lonlatToProj( lon, lat, z, inverse=False):",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "o_x",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "o_x = env_cfg[\"o_x\"]\no_y = env_cfg[\"o_y\"]\no_z = env_cfg[\"o_z\"]\ndef projToAirSim( x, y, z):\n    x_airsim = (x + o_x ) \n    y_airsim = (y - o_y) \n    z_airsim = (-z + o_z) \n    return (x_airsim, -y_airsim, z_airsim)\ndef lonlatToProj( lon, lat, z, inverse=False):\n    proj_coords = Proj(init=SRID)(lon, lat, inverse=inverse)",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "o_y",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "o_y = env_cfg[\"o_y\"]\no_z = env_cfg[\"o_z\"]\ndef projToAirSim( x, y, z):\n    x_airsim = (x + o_x ) \n    y_airsim = (y - o_y) \n    z_airsim = (-z + o_z) \n    return (x_airsim, -y_airsim, z_airsim)\ndef lonlatToProj( lon, lat, z, inverse=False):\n    proj_coords = Proj(init=SRID)(lon, lat, inverse=inverse)\n    return proj_coords + (z,)",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "o_z",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "o_z = env_cfg[\"o_z\"]\ndef projToAirSim( x, y, z):\n    x_airsim = (x + o_x ) \n    y_airsim = (y - o_y) \n    z_airsim = (-z + o_z) \n    return (x_airsim, -y_airsim, z_airsim)\ndef lonlatToProj( lon, lat, z, inverse=False):\n    proj_coords = Proj(init=SRID)(lon, lat, inverse=inverse)\n    return proj_coords + (z,)\ndef lonlatToAirSim( lon, lat, z):",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "distance",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "distance = lambda p1, p2: np.norm(p1-p2)\ndef xy_distance(point1, point2):\n    if type(point1) == Vector3r:\n        point1 = [point1.x_val,point1.y_val] \n    if type(point2) == Vector3r:\n        point2 = [point2.x_val,point2.y_val] \n    return   np.linalg.norm(point1 - point2) \ndef myInterpolate(arr, n_samples=10 ):\n    res = []\n    for i,p in enumerate(arr):",
        "detail": "utils",
        "documentation": {}
    }
]